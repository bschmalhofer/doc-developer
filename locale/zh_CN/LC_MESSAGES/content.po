# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019 OTRS AG, https://otrs.com/
# This file is distributed under the same license as the OTRS Developer Manual package.
#
# Translators:
# Chenry Lee <chenrylee@qq.com>, 2016
# 汇民 王 <whuim@163.com>, 2017
# 汇民 王 <whuim@qq.com>, 2018-2019
# 陈德文 <sggggy@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: OTRS\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-24 13:01+0200\n"
"PO-Revision-Date: 2020-04-12 09:01+0000\n"
"Last-Translator: Huimin Wang <whuim@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://translate.app.otrs.com/projects/"
"otrs-7/developer-manual/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 3.11.3\n"

#: ../../content/additional-resources.rst:2
msgid "Additional Resources"
msgstr "其它资源"

#: ../../content/additional-resources.rst:5
msgid "otrs.com"
msgstr "otrs.com"

#: ../../content/additional-resources.rst:5
msgid ""
"The OTRS website with source code, documentation and news is available at "
"`www.otrs.com <https://www.otrs.com/>`__. Here you can also find information "
"about professional services and OTRS administrator training seminars from "
"OTRS Group, the creator of OTRS."
msgstr ""
"含有源代码、文档和新闻的OTRS网站为 `www.otrs.com <https://www.otrs.com/"
">`__。 在这里，您还可以找到来自OTRS创始人--OTRS集团关于专业服务和OTRS管理员培"
"训研讨会的信息。"

#: ../../content/additional-resources.rst:11
msgid "Online API Library"
msgstr "在线API库"

#: ../../content/additional-resources.rst:8
msgid ""
"The OTRS developer API documentation is available for `Perl`_ and "
"`JavaScript`_."
msgstr ""

#: ../../content/additional-resources.rst:13
msgid "Developer Mailing List"
msgstr "开发者邮件列表"

#: ../../content/additional-resources.rst:14
#, fuzzy
#| msgid ""
#| "The OTRS developer mailing list is available at http://lists.otrs.org/."
msgid ""
"The OTRS developer mailing list is available at https://lists.otrs.org/."
msgstr "可在http://lists.otrs.org/上找到OTRS开发者邮件列表。"

#: ../../content/contributing.rst:2
msgid "Contributing to OTRS"
msgstr "为OTRS做出贡献"

#: ../../content/contributing.rst:4
msgid ""
"This chapter will show how you can contribute to the OTRS framework, so that "
"other users will be able to benefit from your work."
msgstr "本章将介绍如何为OTRS框架做出贡献，以便其它用户能够从您的工作中获益。"

#: ../../content/contributing.rst:6 ../../content/documentation.rst:8
#: ../../content/get-started.rst:8 ../../content/how-it-works.rst:4
#: ../../content/how-to-extend-otrs.rst:4
#: ../../content/how-to-publish-otrs-extensions.rst:4 ../../content/index.rst:9
msgid "Contents"
msgstr "目录"

#: ../../content/contributing/accessibility.rst:2
msgid "Accessibility Guide"
msgstr "无障碍环境指南"

#: ../../content/contributing/accessibility.rst:4
msgid ""
"This document is supposed to explain basics about accessibility issues and "
"give guidelines for contributions to OTRS."
msgstr ""
"本文试图解释关于无障碍环境问题的基础知识，并给予指导方针，以便为OTRS做出贡"
"献。"

#: ../../content/contributing/accessibility.rst:7
msgid "Accessibility Basics"
msgstr "无障碍环境基础"

#: ../../content/contributing/accessibility.rst:10
msgid "What is Accessibility?"
msgstr "什么是无障碍环境？"

#: ../../content/contributing/accessibility.rst:12
msgid ""
"Accessibility is a general term used to describe the degree to which a "
"product, device, service or environment is accessible by as many people as "
"possible. Accessibility can be viewed as the *ability to access* and "
"possible benefit of some system or entity. Accessibility is often used to "
"focus on people with disabilities and their right of access to entities, "
"often through use of assistive technology."
msgstr ""
"无障碍环境是一个通用术语，用于描述尽可能多的人可以访问产品、设备、服务或环境"
"的程度。 无障碍环境可被视为*访问*的能力以及某些系统或实体的可能益处。 可访问"
"性通常用于关注残疾人及其访问实体的权利，通常通过使用辅助技术。"

#: ../../content/contributing/accessibility.rst:14
msgid ""
"In the context of web development, accessibility has a focus on enabling "
"people with impairments full access to web interfaces. For example, this "
"group of people can include partially visually impaired or completely blind "
"people. While the former can still partially use the GUI, the latter have to "
"completely rely on assistive technologies such as software which reads the "
"screen to them (screen readers)."
msgstr ""
"在Web开发的上下文中，无障碍环境集中于使受损害的人能够完全访问Web界面。 例如，"
"这群人可能包括部分视力障碍或完全失明的人。 虽然前者仍然可以部分使用GUI，但是"
"后者必须完全依赖辅助技术，例如向他们读屏幕的软件（屏幕阅读软件）。"

#: ../../content/contributing/accessibility.rst:18
msgid "Why is it important for OTRS?"
msgstr "为什么它对OTRS很重要？"

#: ../../content/contributing/accessibility.rst:20
msgid ""
"To enable impaired users access to OTRS systems is a valid goal in itself. "
"It shows respect."
msgstr "使受损用户访问OTRS系统本身是一个有效的目标。 它体现了尊重。"

#: ../../content/contributing/accessibility.rst:22
msgid ""
"Furthermore, fulfilling accessibility standards is becoming increasingly "
"important in the public sector (government institutions) and large "
"companies, which both belong to the target markets of OTRS."
msgstr ""
"此外，在属于OTRS目标市场的公共部门（政府机构）和大型公司，实现无障碍环境标准"
"变得越来越重要。"

#: ../../content/contributing/accessibility.rst:26
msgid ""
"How can I successfully work on accessibility issues even if I am not "
"disabled?"
msgstr "如果我没有受损，我如何成功地处理无障碍环境问题？"

#: ../../content/contributing/accessibility.rst:28
msgid "This is very simple. Pretend to be blind."
msgstr "这很简单， 假装失明。"

#: ../../content/contributing/accessibility.rst:30
msgid "Don't use the mouse."
msgstr "不要使用鼠标。"

#: ../../content/contributing/accessibility.rst:31
msgid "Don't look at the screen."
msgstr "不要看屏幕。"

#: ../../content/contributing/accessibility.rst:33
msgid ""
"Then try to use OTRS with the help of a screen reader and your keyboard "
"only. This should give you an idea of how it will feel for a blind person."
msgstr ""
"然后尝试在屏幕阅读器和键盘的帮助下使用OTRS。 这应该可以让您了解盲人的感受。"

#: ../../content/contributing/accessibility.rst:37
msgid "Ok, but I don't have a screen reader!"
msgstr "好的，但我没有屏幕阅读软件！"

#: ../../content/contributing/accessibility.rst:39
msgid ""
"While commercial screen readers such as JAWS (perhaps the best known one) "
"can be extremely expensive, there are open source screen readers which you "
"can install and use:"
msgstr ""
"虽然诸如JAWS（可能是最著名的）的商业屏幕阅读软件可能非常昂贵，但是有一些可以"
"安装和使用的开源屏幕阅读软件："

#: ../../content/contributing/accessibility.rst:41
msgid "`NVDA <http://www.nvaccess.org/>`__, a screen reader for Windows."
msgstr "`NVDA <http://www.nvaccess.org/>`__，用于Windows的屏幕阅读器。"

#: ../../content/contributing/accessibility.rst:42
msgid ""
"`ORCA <https://wiki.gnome.org/Projects/Orca>`__, a screen reader for Gnome/"
"Linux."
msgstr ""
"`ORCA <https://wiki.gnome.org/Projects/Orca>`__，用于Gnome/Linux的屏幕阅读"
"器。"

#: ../../content/contributing/accessibility.rst:44
msgid "Now you don't have an excuse any more. ;)"
msgstr "现在你再没有借口了。 ;)"

#: ../../content/contributing/accessibility.rst:48
msgid "Accessibility Standards"
msgstr "无障碍环境标准"

#: ../../content/contributing/accessibility.rst:50
msgid ""
"This section is included for reference only, you do not have to study the "
"standards themselves to be able to work on accessibility issues in OTRS. "
"We'll try to extract the relevant guidelines in this document."
msgstr ""
"本部分仅供参考，您无需研究标准本身就能够处理OTRS中的可访问性问题。 我们将尝试"
"在本文档中提取相关指南。"

#: ../../content/contributing/accessibility.rst:54
msgid "Web Content Accessibility Guidelines (WCAG)"
msgstr "网页内容无障碍环境指南（WCAG）"

#: ../../content/contributing/accessibility.rst:56
msgid ""
"This W3C standard gives general guidelines for how to create accessible web "
"pages."
msgstr "这个W3C标准为如何创建可访问的网页提供了通用指南。"

#: ../../content/contributing/accessibility.rst:58
msgid "`WCAG 2.0 <http://www.w3.org/TR/WCAG20/>`__"
msgstr "`WCAG 2.0 <http://www.w3.org/TR/WCAG20/>`__"

#: ../../content/contributing/accessibility.rst:59
msgid "`How to Meet WCAG 2.0 <http://www.w3.org/WAI/WCAG20/quickref/>`__"
msgstr "`如何满足 WCAG 2.0 <http://www.w3.org/WAI/WCAG20/quickref/>`__"

#: ../../content/contributing/accessibility.rst:60
msgid "`Understanding WCAG 2.0 <http://www.w3.org/TR/UNDERSTANDING-WCAG20/>`__"
msgstr "`理解 WCAG 2.0 <http://www.w3.org/TR/UNDERSTANDING-WCAG20/>`__"

#: ../../content/contributing/accessibility.rst:62
msgid ""
"WCAG has different levels of accessibility support. We currently plan to "
"support level A, as AA and AAA deal with matters that seem not relevant for "
"OTRS."
msgstr ""
"WCAG具有不同级别的可访问性支持。 我们目前计划支持A级，因为AA和AAA处理与OTRS无"
"关的事项。"

#: ../../content/contributing/accessibility.rst:66
msgid "Accessible Rich Internet Applications (WAI-ARIA) 1.0"
msgstr "可访问的互联网应用（WAI-ARIA）1.0"

#: ../../content/contributing/accessibility.rst:68
msgid ""
"This standard deals with the special issues arising from the shift away from "
"static content to dynamic web applications. It deals with questions like how "
"a user can be notified of changes in the user interface resulting from AJAX "
"requests, for example."
msgstr ""
"本标准涉及从静态内容转移到动态Web应用程序引起的特殊问题。 它处理诸如用户如何"
"从AJAX请求产生的用户界面变化得到通知之类的问题。"

#: ../../content/contributing/accessibility.rst:70
msgid "`WAI-ARIA 1.0 <http://www.w3.org/TR/wai-aria/>`__"
msgstr "`WAI-ARIA 1.0 <http://www.w3.org/TR/wai-aria/>`__"

#: ../../content/contributing/accessibility.rst:74
msgid "Implementation guidelines"
msgstr "实施指南"

#: ../../content/contributing/accessibility.rst:77
msgid "Provide alternatives for non-text content"
msgstr "提供非文本内容的替代方案"

#: ../../content/contributing/accessibility.rst:79
msgid ""
"Goal: *All non-text content that is presented to the user has a text "
"alternative that serves the equivalent purpose.* (WCAG 1.1.1)"
msgstr ""
"目标： *呈现给用户的所有非文本内容都有一个文本替代方案，用于同等目的* （WCAG "
"1.1.1）"

#: ../../content/contributing/accessibility.rst:81
msgid ""
"It is very important to understand that screen readers can only present "
"textual information and available metadata to the user. To give you an "
"example, whenever a screen reader sees ``<a href=\"#\" class=\"CloseLink\"></"
"a>``, it can only read *link* to the user, but not the target of this link. "
"With a slight improvement, it would be accessible: ``<a href=\"#\" class="
"\"CloseLink\" title=\"Close this widget\"></a>``. In this case the user "
"would hear *link close this widget*, voila!"
msgstr ""
"理解屏幕阅读器只能向用户呈现文本信息和可用元数据是非常重要的。 举个例子，每当"
"屏幕阅读器看到 ``<a href=\"#\" class=\"CloseLink\"></a>`` 时，它只能读取* 链"
"接 *给用户，而不是这个链接的目标。 稍微改进一下就可以访问：``<a href=\"#\" "
"class=\"CloseLink\" title=\"关闭这个小部件\"></a>``。 在这种情况下，用户会听"
"到*链接 关闭这个小部件*，瞧！"

#: ../../content/contributing/accessibility.rst:83
msgid ""
"It is important to always formulate the text in a most *speaking* way. Just "
"imagine it is the only information that you have. Will it help you? Can you "
"understand its purpose just by hearing it?"
msgstr ""
"始终以最 *口语* 的方式表述文本非常重要。想象一下，这是你拥有的唯一信息，它会"
"帮到你吗？ 你只听到它就能理解它的目的吗？"

#: ../../content/contributing/accessibility.rst:85
msgid "Please follow these rules when working on OTRS:"
msgstr "使用OTRS时请遵从这些规则："

#: ../../content/contributing/accessibility.rst:87
msgid ""
"*Rule*: Wherever possible, use speaking texts and formulate in real, "
"understandable and precise sentences. *Close this widget* is much better "
"than *Close*, because the latter is redundant."
msgstr ""
"*规则*：尽可能使用口头文本并用真实、可理解和精确的句子表达。 *关闭这个小部件"
"* 比 *关闭* 好得多，因为后者是冗余的。"

#: ../../content/contributing/accessibility.rst:88
msgid ""
"*Rule*: Links always must have either text content that is spoken by the "
"screen reader (``<a href=\"#\" >Delete this entry</a>``), or a ``title`` "
"attribute (``<a href=\"#\" title=\"Close this widget\"></a>``)."
msgstr ""
"*规则*：链接始终必须具有屏幕阅读器能说的文本内容（ ``<a href=\"#\">删除此条目"
"</a>``）或 ``title`` 属性（ ``<a href=\"#\" title=\"关闭这个小部件\"></"
"a>`` ）。"

#: ../../content/contributing/accessibility.rst:89
msgid ""
"*Rule*: Images must always have an alternative text that can be read to the "
"user (``<img src=\"house.png\" alt=\"Image of a house\" />``)."
msgstr ""
"*规则*：图片必须始终有一个可以读给用户的替代文本（ ``<img src=\"house.png\" "
"alt=\"一座房子的图片\" />``）。"

#: ../../content/contributing/accessibility.rst:93
msgid "Make navigation easy"
msgstr "使导航变得容易"

#: ../../content/contributing/accessibility.rst:95
msgid ""
"Goal: *Allow the user to easily navigate the current page and the entire "
"application.*"
msgstr "目标：*允许用户轻松浏览当前页面和整个应用程序。*"

#: ../../content/contributing/accessibility.rst:97
msgid ""
"The ``title`` tag is the first thing a user hears from the screen reader "
"when opening a web page. For OTRS, there is also always just one ``h1`` "
"element on the page, indicating the current page (it contains part of the "
"information from ``title``). This navigational information helps the user to "
"understand where they are, and what the purpose of the current page is."
msgstr ""
"``title`` 标签是用户在打开网页时从屏幕阅读器听到的第一项。 对于OTRS，页面上总"
"是只有一个 ``h1`` 元素，表示当前页面（它包含来自 ``title`` 的部分信息）。 该"
"导航信息有助于用户了解它们的位置以及当前页面的用途。"

#: ../../content/contributing/accessibility.rst:99
msgid ""
"*Rule*: Always give a precise title to the page that allows the user to "
"understand where they currently are."
msgstr "*规则*：始终为页面提供一个精确的标题，允许用户了解它们当前的位置。"

#: ../../content/contributing/accessibility.rst:101
msgid ""
"Screen readers can use the built-in document structure of HTML (headings "
"``h1`` to ``h6``) to determine the structure of a document and to allow the "
"user to jump around from section to section. However, this is not enough to "
"reflect the structure of a dynamic web application. That's why ARIA defines "
"several *landmark* roles that can be given to elements to indicate their "
"navigational significance."
msgstr ""
"屏幕阅读器可以使用HTML的内置文档结构（标题 ``h1`` 到 ``h6`` ）来确定文档的结"
"构，并允许用户从一节跳到另一节。但是，这不足以反映动态Web应用程序的结构。这就"
"是为什么ARIA 定义了几个 *地标* 角色，这些角色可以赋予元素以指示其导航意义。"

#: ../../content/contributing/accessibility.rst:103
msgid ""
"To keep the validity of the HTML documents, the ``role`` attributes (ARIA "
"landmark roles) are not inserted into the source code directly, but instead "
"by classes which will later be used by the JavaScript functions in ``OTRS.UI."
"Accessibility`` to set the corresponding ``role`` attributes on the node."
msgstr ""
"为了保持HTML文档的有效性，``role`` 属性（ARIA地标角色）不是直接插入到源代码"
"中，而是通过以后将被 ``OTRS.UIAccessibility`` 中的JavaScript函数使用的类插"
"入，在节点上设置相应的 ``role`` 属性。"

#: ../../content/contributing/accessibility.rst:105
msgid ""
"*Rule*: Use WAI-ARIA Landmark Roles to structure the content for screen "
"readers."
msgstr "*规则*：使用WAI-ARIA 地标角色为屏幕阅读器组织内容。"

#: ../../content/contributing/accessibility.rst:107
msgid ""
"Banner: ``<div class=\"ARIARoleBanner\"></div>`` will become ``<div class="
"\"ARIARoleBanner\" role=\"banner\"></div>``"
msgstr ""
"Banner: ``<div class=\"ARIARoleBanner\"></div>`` 将变成 ``<div class="
"\"ARIARoleBanner\" role=\"banner\"></div>``"

#: ../../content/contributing/accessibility.rst:108
msgid ""
"Navigation: ``<div class=\"ARIARoleNavigation\"></div>`` will become ``<div "
"class=\"ARIARoleNavigation\" role=\"navigation\"></div>``"
msgstr ""
"导航: ``<div class=\"ARIARoleNavigation\"></div>`` 将变成 ``<div class="
"\"ARIARoleNavigation\" role=\"navigation\"></div>``"

#: ../../content/contributing/accessibility.rst:109
msgid ""
"Search function: ``<div class=\"ARIARoleSearch\"></div>`` will become ``<div "
"class=\"ARIARoleSearch\" role=\"search\"></div>``"
msgstr ""
"搜索功能: ``<div class=\"ARIARoleSearch\"></div>`` 将变成 ``<div class="
"\"ARIARoleSearch\" role=\"search\"></div>``"

#: ../../content/contributing/accessibility.rst:110
msgid ""
"Main application area: ``<div class=\"ARIARoleMain\"></div>`` will become "
"``<div class=\"ARIARoleMain\" role=\"main\"></div>``"
msgstr ""
"主应用区域: ``<div class=\"ARIARoleMain\"></div>`` 将变成 ``<div class="
"\"ARIARoleMain\" role=\"main\"></div>``"

#: ../../content/contributing/accessibility.rst:111
msgid ""
"Footer: ``<div class=\"ARIARoleContentinfo\"></div>`` will become ``<div "
"class=\"ARIARoleContentinfo\" role=\"contentinfo\"></div>``"
msgstr ""
"页脚: ``<div class=\"ARIARoleContentinfo\"></div>`` 将变成 ``<div class="
"\"ARIARoleContentinfo\" role=\"contentinfo\"></div>``"

#: ../../content/contributing/accessibility.rst:113
msgid ""
"For navigation inside of ``<form>`` elements, it is necessary for the "
"impaired user to know what each input elements purpose is. This can be "
"achieved by using standard HTML ``<label>`` elements which create a link "
"between the label and the form element."
msgstr ""
"对于 ``<form>`` 元素内部的导航，受损用户必须知道每个输入元素的用途。 这可以通"
"过使用标准HTML ``<label>`` 元素来实现，这些元素在标签和表单元素之间创建链接。"

#: ../../content/contributing/accessibility.rst:115
msgid ""
"When an input element gets focus, the screen reader will usually read the "
"connected label, so that the user can hear its exact purpose. An additional "
"benefit for seeing users is that they can click on the label, and the input "
"element will get focus (especially helpful for checkboxes, for example)."
msgstr ""
"当输入元素获得焦点时，屏幕阅读器通常会读取连接的标签，以便用户可以听到其确切"
"用途。 正常用户的额外好处是，他们可以通过点击标签让此输入元素将获得焦点（例"
"如，对复选框特别有用）。"

#: ../../content/contributing/accessibility.rst:117
msgid ""
"*Rule*: Provide ``<label>`` elements for *all* form element (``input``, "
"``select``, ``textarea``) fields."
msgstr ""
"*规则*：为 *所有的* 表单元素（ ``input文本输入框`` 、 ``select选择框`` 、 "
"``textarea多行文本框`` ）字段提供 ``<label>`` 元素。"

#: ../../content/contributing/accessibility.rst:119
msgid ""
"Example: ``<label for=\"date\">Date:</label><input type=\"text\" name=\"date"
"\" id=\"date\"/>``"
msgstr ""
"例如： ``<label for=\"date\">日期:</label><input type=\"text\" name=\"date\" "
"id=\"date\"/>``"

#: ../../content/contributing/accessibility.rst:123
msgid "Make interaction possible"
msgstr "使交互成为可能"

#: ../../content/contributing/accessibility.rst:125
msgid ""
"Goal: *Allow the user to perform all interactions just by using the keyboard."
"*"
msgstr "目标：*允许用户仅使用键盘执行所有交互。*"

#: ../../content/contributing/accessibility.rst:127
msgid ""
"While it is technically possible to create interactions with JavaScript on "
"arbitrary HTML elements, this must be limited to elements that a user can "
"interact with by using the keyboard. Specifically, they need to be able to "
"give focus to the element and to interact with it. For example, a push "
"button to toggle a widget should not be realized by using a ``span`` element "
"with an attached JavaScript ``onclick`` event listener, but it should be (or "
"contain) an ``a`` tag to make it clear to the screen reader that this "
"element can cause interaction."
msgstr ""
"虽然在技术上可以在任意HTML元素上创建与JavaScript的交互，但这必须限于用户可以"
"使用键盘与之交互的元素。 具体来说，他们需要能够获取元素的焦点并与元素进行交"
"互。 例如，切换小部件的按钮不应该通过使用带有附加的JavaScript ``onclick`` 事"
"件监听器的 ``span`` 元素来实现，而应该是（或包含） ``a`` 标签 使屏幕阅读器清"
"楚这个元素可以引起交互。"

#: ../../content/contributing/accessibility.rst:129
msgid ""
"*Rule*: For interactions, always use elements that can receive focus, such "
"as ``a``, ``input``, ``select`` and ``button``."
msgstr ""
"*规则*：对于交互，总是使用可以获得焦点的元素，例如 ``a`` 、 ``input`` 、 "
"``select`` 和 ``button``。"

#: ../../content/contributing/accessibility.rst:130
msgid ""
"*Rule*: Make sure that the user can always identify the nature of the "
"interaction (see rules about non-textual content and labelling of form "
"elements)."
msgstr ""
"*规则*：确保用户始终能够识别交互的性质（请参阅有关非文本内容和表单元素标签的"
"规则）。"

#: ../../content/contributing/accessibility.rst:132
msgid "Goal: *Make dynamic changes known to the user.*"
msgstr "目标：*让用户了解动态变化。*"

#: ../../content/contributing/accessibility.rst:134
msgid ""
"A special area of accessibility problems are dynamic changes in the user "
"interface, either by JavaScript or also by AJAX calls. The screen reader "
"will not tell the user about changes without special precautions. This is a "
"difficult topic and cannot yet be completely explained here."
msgstr ""
"无障碍环境问题的一个特殊领域是用户界面中的动态更改，可以是JavaScript，也可以"
"是AJAX调用。 如果没有特殊的预防措施，屏幕阅读器不会告诉用户有关变化。 这是一"
"个困难的话题，这里还不能完全解释。"

#: ../../content/contributing/accessibility.rst:136
msgid ""
"*Rule*: Always use the validation framework ``OTRS.Validate`` for form "
"validation."
msgstr "*规则*：始终使用验证框架 ``OTRS.Validate`` 进行表单验证。"

#: ../../content/contributing/accessibility.rst:138
msgid ""
"This will make sure that the error tooltips are being read by the screen "
"reader. That way the blind user a) knows the item which has an error and b) "
"get a text describing the error."
msgstr ""
"这将确保屏幕阅读器读取错误提醒。这样，盲人用户 a）知道有错误的项目，b）得到描"
"述错误的文本。"

#: ../../content/contributing/accessibility.rst:140
msgid ""
"*Rule*: Use the function ``OTRS.UI.Accessibility.AudibleAlert()`` to notify "
"the user about other important UI changes."
msgstr ""
"*规则*：使用函数 ``OTRS.UI.Accessibility.AudibleAlert()`` 通知用户其它重要的"
"用户界面变化。"

#: ../../content/contributing/accessibility.rst:142
msgid ""
"*Rule*: Use the ``OTRS.UI.Dialog`` framework to create modal dialogs. These "
"are already optimized for accessibility."
msgstr ""
"*规则*：使用 ``OTRS.UI.Dialog`` 框架创建模态对话框。这些已经针对无障碍环境进"
"行了优化。"

#: ../../content/contributing/accessibility.rst:146
msgid "General screen reader optimizations"
msgstr "通用屏幕阅读软件优化"

#: ../../content/contributing/accessibility.rst:148
msgid "Goal: *Help screen readers with their work.*"
msgstr "目标：*帮助屏幕阅读器完成工作。*"

#: ../../content/contributing/accessibility.rst:150
msgid ""
"*Rule*: Each page must identify its own main language so that the screen "
"reader can choose the right speech synthesis engine."
msgstr ""
"*规则*：每个页面必须标识自己的主语言，以便屏幕阅读器可以选择正确的语音合成引"
"擎。"

#: ../../content/contributing/accessibility.rst:152
msgid "Example: ``<html lang=\"fr\">...</html>``"
msgstr "例如： ``<html lang=\"fr\">...</html>``"

#: ../../content/contributing/code-style.rst:2
msgid "Code Style Guide"
msgstr "代码样式指南"

#: ../../content/contributing/code-style.rst:4
msgid ""
"In order to preserve the consistent development of the OTRS project, we have "
"set up guidelines regarding style for the different programming languages."
msgstr "为了保持OTRS项目的一致发展，我们为不同的编程语言制定了样式指南。"

#: ../../content/contributing/code-style.rst:9
msgid "Perl"
msgstr "Perl"

#: ../../content/contributing/code-style.rst:12
msgid "Whitespace"
msgstr "空格"

#: ../../content/contributing/code-style.rst:14
msgid "TAB: We use 4 spaces. Examples for braces:"
msgstr "TAB：我们用4个空格。大括号示例："

#: ../../content/contributing/code-style.rst:31
msgid "Length of Lines"
msgstr "每行宽度"

#: ../../content/contributing/code-style.rst:33
msgid ""
"Lines should generally not be longer than 120 characters, unless it is "
"necessary for special reasons."
msgstr "除非出于特殊原因，否则每行通常不应超过120个字符。"

#: ../../content/contributing/code-style.rst:37
msgid "Spaces and Parentheses"
msgstr "空格和圆括号"

#: ../../content/contributing/code-style.rst:39
msgid ""
"To gain more readability, we use spaces between keywords and opening "
"parenthesis."
msgstr "为了获得更多可读性，我们在关键字和左括号之间使用空格。"

#: ../../content/contributing/code-style.rst:46
msgid ""
"If there is just one single variable, the parenthesis enclose the variable "
"with no spaces inside."
msgstr "如果只有一个变量，则括号内不用空格包含变量。"

#: ../../content/contributing/code-style.rst:56
msgid ""
"If the condition is not just one single variable, we use spaces between the "
"parenthesis and the condition. And there is still the space between the "
"keyword (e.g. ``if``) and the opening parenthesis."
msgstr ""
"如果条件不只是一个变量，我们在括号和条件之间使用空格。 关键字（例如 ``if``）"
"和左括号之间仍然存在空格。"

#: ../../content/contributing/code-style.rst:62
msgid "Note that for Perl builtin functions, we do not use parentheses:"
msgstr "请注意，对于Perl内置函数，我们不使用括号："

#: ../../content/contributing/code-style.rst:70
msgid "Source Code Header and Charset"
msgstr "源码文件头和字符集"

#: ../../content/contributing/code-style.rst:72
msgid ""
"Attach the following header to every source file. Source files are saved in "
"UTF-8 charset."
msgstr "将以下头部信息附加到每个源文件。 源文件以UTF-8字符集保存。"

#: ../../content/contributing/code-style.rst:84
msgid "Executable files (``*.pl``) have a special header."
msgstr "可执行文件（ ``*.pl`` ）有一个特殊的文件头。"

#: ../../content/contributing/code-style.rst:108
msgid "Conditions"
msgstr "条件"

#: ../../content/contributing/code-style.rst:110
msgid ""
"Conditions can be quite complex and there can be *chained* conditions "
"(linked with logical *or* or *and* operations). When coding for OTRS, you "
"have to be aware of several situations."
msgstr ""
"条件可能非常复杂，可能存在 *链式* 条件（与逻辑 *or* 或 *and* 操作链接）。 在"
"编写OTRS时，您必须了解几种情况。"

#: ../../content/contributing/code-style.rst:112
msgid ""
"Perl best practices says, that high precedence operators (``&&`` and ``||``) "
"shouldn't mixed up with low precedence operators (``and`` and ``or``). To "
"avoid confusion, we always use the high precedence operators."
msgstr ""
"Perl最佳实践说，高优先级运算符（ ``&&`` 和 ``||``）不应与低优先级运算符"
"（ ``and``和 ``or``）混淆。 为避免混淆，我们总是使用高优先级运算符。"

#: ../../content/contributing/code-style.rst:122
msgid ""
"This means that you have to be aware of traps. Sometimes you need to use "
"parenthesis to make clear what you want."
msgstr "这意味着您必须了解陷阱。 有时您需要使用括号来明确您想要的内容。"

#: ../../content/contributing/code-style.rst:124
msgid ""
"If you have long conditions (line is longer than 120 characters over all), "
"you have to break it in several lines. And the start of the conditions is in "
"a new line (not in the line of the ``if``)."
msgstr ""
"如果条件很长（行总长度超过120个字符），则必须将它分成几行。 条件的开始是一个"
"新的行（不在 ``if`` 的行中）。"

#: ../../content/contributing/code-style.rst:141
msgid ""
"Also note, that the right parenthesis is in a line on its own and the left "
"curly bracket is also in a new line and with the same indentation as the "
"``if``. The operators are at the beginning of a new line! The subsequent "
"examples show how to do it."
msgstr ""
"另请注意，右括号本身在一行中，左括号也在一个新行中，并且与 ``if`` 具有相同的"
"缩进。 运算符处于新行的开头！ 随后的示例显示了如何执行此操作。"

#: ../../content/contributing/code-style.rst:175
msgid "Postfix ``if``"
msgstr "后缀 ``if``"

#: ../../content/contributing/code-style.rst:177
msgid ""
"Generally we use *postfix ``if``* statements to reduce the number of levels. "
"But we don't use it for multiline statements and is only allowed when "
"involves return statements in functions or to end a loop or to go next "
"iteration."
msgstr ""
"通常我们使用 *后缀 ``if``* 语句来减少级别数。 但我们不将它用于多行语句，只有"
"在函数中包含return语句或结束循环或进行下一次迭代时才允许使用它。"

#: ../../content/contributing/code-style.rst:179
#: ../../content/contributing/code-style.rst:203
#: ../../content/contributing/code-style.rst:489
msgid "This is correct:"
msgstr "这样是对的："

#: ../../content/contributing/code-style.rst:185
#: ../../content/contributing/code-style.rst:212
#: ../../content/contributing/code-style.rst:501
msgid "This is wrong:"
msgstr "这样是错的："

#: ../../content/contributing/code-style.rst:194
msgid "This is less maintainable than this:"
msgstr "这样更容易维护："

#: ../../content/contributing/code-style.rst:220
msgid "Restrictions for the Use of Some Perl Builtins"
msgstr "使用某些Perl内置函数的限制"

#: ../../content/contributing/code-style.rst:222
msgid "Some builtin subroutines of Perl may not be used in every place:"
msgstr "Perl的一些内置子程序不适合在每个地方使用："

#: ../../content/contributing/code-style.rst:224
msgid "Don't use ``die`` and ``exit`` in ``.pm`` files."
msgstr "不要在 ``.pm`` 文件中使用 ``die`` 和 ``exit``。"

#: ../../content/contributing/code-style.rst:225
msgid "Don't use the ``Dumper`` function in released files."
msgstr "不要在已发布的文件中使用 ``Dumper`` 函数。"

#: ../../content/contributing/code-style.rst:226
msgid "Don't use ``print`` in ``.pm`` files."
msgstr "不要在 ``.pm`` 文件中使用 ``print``。"

#: ../../content/contributing/code-style.rst:227
msgid "Don't use ``require``, use ``Main::Require()`` instead."
msgstr "不要使用 ``require`` ，而是使用 ``Main::Require()``。"

#: ../../content/contributing/code-style.rst:228
msgid ""
"Use the functions of the ``DateTimeObject`` instead of the builtin functions "
"like ``time()``, ``localtime()``, etc."
msgstr ""
"使用 ``DateTimeObject`` 的函数代替 ``time()`` 、 ``localtime()`` 等内置函数。"

#: ../../content/contributing/code-style.rst:232
msgid "Regular Expressions"
msgstr "正则表达式"

#: ../../content/contributing/code-style.rst:234
msgid ""
"For regular expressions *in the source code*, we always use the ``m//`` "
"operator with curly braces as delimiters. We also use the modifiers ``x``, "
"``m`` and ``s`` by default. The ``x`` modifier allows you to comment your "
"regex and use spaces to visually separate logical groups."
msgstr ""
"对于 *源代码* 中的正则表达式，我们总是使用带有花括号的 ``m//`` 运算符作为分隔"
"符。 我们默认使用修饰符 ``x``、 ``m`` 和 ``s``。 ``x`` 修饰符允许您注释正则表"
"达式并使用空格来可视地分隔逻辑组。"

#: ../../content/contributing/code-style.rst:247
msgid ""
"As the space no longer has a special meaning, you have to use a single "
"character class to match a single space (``[ ]``). If you want to match any "
"whitespace you can use ``\\s``."
msgstr ""
"由于空格不再具有特殊含义，您必须使用单个字符类来匹配单个空格（ ``[ ]``）。 如"
"果你想匹配任何空格，你可以使用 ``\\s``。"

#: ../../content/contributing/code-style.rst:249
msgid ""
"In the regex, the dot (``.``) includes the newline (whereas in regex without "
"``s`` modifier the dot means 'everything but newline'). If you want to match "
"anything but newline, you have to use the negated single character class "
"(``[^\\n]``)."
msgstr ""
"在正则表达式中，点（ ``.``）包括换行符（而在没有 ``s`` 修饰符的正则表达式中，"
"点表示“除了换行符之外的所有内容”）。 如果你想匹配除换行之外的任何东西，你必须"
"使用否定的单个字符类（ ``[^\\n]``）。"

#: ../../content/contributing/code-style.rst:259
msgid ""
"An exception to the convention above applies to all cases where regular "
"expressions are not written statically in the code but instead are *supplied "
"by users* in one form or another (for example via system configuration or in "
"a Postmaster filter configuration). Any evaluation of such a regular "
"expression has to be done without any modifiers (e.g. ``$Variable =~ "
"m{$Regex}``) in order to match the expectation of (mostly inexperienced) "
"users and also to be backwards compatible."
msgstr ""
"上述约定的适用于所有情况，一个例外是正则表达式不是在代码中静态写入，而是由用"
"户 *以一种或另一种形式提供* （例如通过系统配置或邮箱管理员过滤器配置）。 任何"
"对这种正则表达式的评估都必须在没有任何修饰符的情况下完成（例如 ``$Variable "
"=~ m{$Regex}``），以匹配（大部分是没有经验的）用户的期望，并且也是向后兼容"
"的。"

#: ../../content/contributing/code-style.rst:261
msgid ""
"If modifiers are strictly necessary for user supplied regular expressions, "
"it is always possible to use embedded modifiers (e.g. ``(?:(?i)SmAlL oR "
"lArGe)``). For details, please see `perlretut <http://perldoc.perl.org/"
"perlretut.html#Embedding-comments-and-modifiers-in-a-regular-expression>`__."
msgstr ""
"如果修饰符对于用户提供的正则表达式是严格必需的，则始终可以使用嵌入式修饰符"
"（例如 ``(?:(?i)SmAlL oR lArGe)``）。 有关详细信息，请参阅 `perlretut "
"<http://perldoc.perl.org/perlretut.html#Embedding-comments-and-modifiers-in-"
"a-regular-expression>`__。"

#: ../../content/contributing/code-style.rst:263
msgid ""
"Usage of the ``r`` modifier is encouraged, e.g. if you need to extract part "
"of a string into another variable. This modifier keeps the matched variable "
"intact and instead provides the substitution result as a return value."
msgstr ""
"鼓励使用 ``r`` 修饰符，例如 如果您需要将字符串的一部分提取到另一个变量中。 此"
"修饰符使匹配的变量保持不变，而是将替换结果作为返回值提供。"

#: ../../content/contributing/code-style.rst:265
#: ../../content/contributing/code-style.rst:312
#: ../../content/contributing/code-style.rst:431
msgid "Use this:"
msgstr "这样使用："

#: ../../content/contributing/code-style.rst:278
#: ../../content/contributing/code-style.rst:332
#: ../../content/contributing/code-style.rst:440
msgid "Instead of this:"
msgstr "而不是这样使用："

#: ../../content/contributing/code-style.rst:292
msgid ""
"If you want to match for start and end of a **string**, you should generally "
"use ``\\A`` and ``\\z`` instead of the more generic ``^`` and ``$`` unless "
"you really need to match start or end of **lines** within a multiline string."
msgstr ""
"如果你想匹配 **字符串** 的开头和结尾，你通常应该使用 ``\\A`` 和 ``\\z`` 而不"
"是更通用的 ``^`` 和 ``$``，除非你真的需要在多行字符串中匹配 **行** 的开头或结"
"尾。"

#: ../../content/contributing/code-style.rst:310
msgid ""
"Usage of named capture groups is also encouraged, particularly for multi-"
"matches. Named capture groups are easier to read/understand, prevent mix-ups "
"when matching more than one capture group and allow extension without "
"accidentally introducing bugs."
msgstr ""
"还鼓励使用命名捕获组，尤其是对于多个匹配。 命名捕获组更易于阅读/理解，在匹配"
"多个捕获组时防止混淆，并允许扩展而不会意外地引入错误。"

#: ../../content/contributing/code-style.rst:354
msgid "Naming"
msgstr "命名"

#: ../../content/contributing/code-style.rst:356
msgid ""
"Names and comments are written in English. Variables, objects and methods "
"must be descriptive nouns or noun phrases with the first letter set upper "
"case (`CamelCase <https://en.wikipedia.org/wiki/CamelCase>`__)."
msgstr ""
"名称和注释都用英语。 变量、对象和方法必须是描述性名词或名词短语，第一个字母设"
"置为大写（ `驼峰式命名法 <https://en.wikipedia.org/wiki/CamelCase>`__ ）。"

#: ../../content/contributing/code-style.rst:358
msgid ""
"Names should be as descriptive as possible. A reader should be able to say "
"what is meant by a name without digging too deep into the code. E.g. use ``"
"$ConfigItemID`` instead of ``$ID``. Examples: ``@TicketIDs``, ``$Output``, "
"``StateSet()``, etc."
msgstr ""
"名称应尽可能具有描述性。 读者应该能够在不深入挖掘代码的情况下说出名称的含"
"义。 例如。 使用 ``$ConfigItemID`` 而不是 ``$ID`` 。 例如： "
"``@TicketIDs`` 、 ``$Output`` 、 ``StateSet()`` 等。"

#: ../../content/contributing/code-style.rst:362
msgid "Variable Declaration"
msgstr "变量声明"

#: ../../content/contributing/code-style.rst:364
msgid ""
"If you have several variables, you can declare them in one line if they "
"*belong together*:"
msgstr "如果有多个变量且 *属于一起*，则可以在一行中声明它们："

#: ../../content/contributing/code-style.rst:370
msgid "Otherwise break it into separate lines:"
msgstr "否则，将其分成几行："

#: ../../content/contributing/code-style.rst:377
msgid ""
"Do not set to ``undef`` or ``''`` in the declaration as this might hide "
"mistakes in code."
msgstr ""
"不要在声明中设置为 ``undef`` 或 ``''`` ，因为这可能会隐藏代码中的错误。"

#: ../../content/contributing/code-style.rst:387
msgid "You can set a variable to ``''`` if you want to concatenate strings:"
msgstr "如果要连接字符串，可以将变量设置为 ``''``："

#: ../../content/contributing/code-style.rst:396
msgid "Otherwise you would get an *uninitialized* warning."
msgstr "否则你会收到 *uninitialized（未初始化）* 警告。"

#: ../../content/contributing/code-style.rst:400
msgid "Handling of Parameters"
msgstr "处理参数"

#: ../../content/contributing/code-style.rst:402
msgid ""
"To fetch the parameters passed to subroutines, OTRS normally uses the hash ``"
"%Param`` (not ``%Params``). This leads to more readable code as every time "
"we use ``%Param`` in the subroutine code we know it is the parameter hash "
"passed to the subroutine."
msgstr ""
"为了获取传递给子程序的参数，OTRS通常使用散列 ``％Param`` （不是 ``"
"％Params`` ）。 这导致代码更易读，因为每次在子程序代码中使用 ``％Param`` 时我"
"们都知道它是传递给子程序的参数哈希。"

#: ../../content/contributing/code-style.rst:404
msgid ""
"Just in some exceptions a regular list of parameters should be used. So we "
"want to avoid something like this:"
msgstr "除了某些例外情况，应使用常规参数列表。 所以我们想避免这样的事情："

#: ../../content/contributing/code-style.rst:412
msgid "We want to use this instead:"
msgstr "我们想要这样使用："

#: ../../content/contributing/code-style.rst:420
msgid "This has several advantages:"
msgstr "这有几个好处："

#: ../../content/contributing/code-style.rst:422
msgid ""
"We do not have to change the code in the subroutine when a new parameter "
"should be passed."
msgstr "当要传递新参数时，我们不必更改子程序中的代码。"

#: ../../content/contributing/code-style.rst:423
msgid "Calling a function with named parameters is much more readable."
msgstr "使用命名参数调用函数更具可读性。"

#: ../../content/contributing/code-style.rst:427
msgid "Multiple Named Parameters"
msgstr "多个命名参数"

#: ../../content/contributing/code-style.rst:429
msgid ""
"If a function call requires more than one named parameter, split them into "
"multiple lines."
msgstr "如果函数调用需要多个命名参数，请将它们拆分为多行。"

#: ../../content/contributing/code-style.rst:448
msgid "``return`` Statements"
msgstr "``return`` 语句"

#: ../../content/contributing/code-style.rst:450
msgid ""
"Subroutines have to have a ``return`` statement. The explicit ``return`` "
"statement is preferred over the implicit way (result of last statement in "
"subroutine) as this clarifies what the subroutine returns."
msgstr ""
"子程序必须有一个 ``return`` 语句。 显式的 ``return`` 语句优于隐式方式（子程序"
"中最后一个语句的结果），因为这澄清了子程序返回的内容。"

#: ../../content/contributing/code-style.rst:461
msgid "Explicit Return Values"
msgstr "显式返回值"

#: ../../content/contributing/code-style.rst:463
msgid ""
"Explicit return values means that you should not have a ``return`` statement "
"followed by a subroutine call."
msgstr "显式返回值意味着您不应该有一个 ``return`` 语句，后面跟一个子程序调用。"

#: ../../content/contributing/code-style.rst:469
msgid ""
"The following example is better as this says explicitly what is returned. "
"With the example above the reader doesn't know what the return value is as "
"he might not know what ``Do()`` returns."
msgstr ""
"以下示例更好，因为它明确说明了返回的内容。 上面的例子，读者不知道返回值是什"
"么，因为他可能不知道 ``Do()`` 返回什么。"

#: ../../content/contributing/code-style.rst:476
msgid ""
"If you assign the result of a subroutine to a variable, a *good* variable "
"name indicates what was returned:"
msgstr ""
"如果将子程序的结果分配给变量，则一个 *良好的* 变量名称可以表明返回的内容："

#: ../../content/contributing/code-style.rst:485
msgid "``use`` Statements"
msgstr "``use`` 语句"

#: ../../content/contributing/code-style.rst:487
msgid ""
"``use strict`` and ``use warnings`` have to be the first two *uses* in a "
"module."
msgstr "``use strict`` 和 ``use warnings`` 必须是模块中前两个 *use语句*。"

#: ../../content/contributing/code-style.rst:515
msgid "Objects and Their Allocation"
msgstr "对象及其分配"

#: ../../content/contributing/code-style.rst:517
msgid ""
"In OTRS many objects are available. But you should not use every object in "
"every file to keep the front end/back end separation."
msgstr ""
"在OTRS中有许多对象可用。 但是你不应该使用每个文件中的每个对象来保持前端/后端"
"的分离。"

#: ../../content/contributing/code-style.rst:519
msgid "Don't use the ``LayoutObject`` in core modules (``Kernel/System``)."
msgstr "不要在核心模块( ``Kernel/System``)中使用 ``LayoutObject`` 。"

#: ../../content/contributing/code-style.rst:520
msgid "Don't use the ``ParamObject`` in core modules (``Kernel/System``)."
msgstr "不要在核心模块( ``Kernel/System``)中使用 ``ParamObject`` 。"

#: ../../content/contributing/code-style.rst:521
msgid "Don't use the ``DBObject`` in front end modules (``Kernel/Modules``)."
msgstr "不要在核心模块( ``Kernel/System``)中使用 ``DBObject`` 。"

#: ../../content/contributing/code-style.rst:525
msgid "Documenting Back End Modules"
msgstr "后端模块文档记录"

#: ../../content/contributing/code-style.rst:534
msgid "``NAME`` section"
msgstr "``NAME`` 部分"

#: ../../content/contributing/code-style.rst:528
msgid ""
"This section should include the module name, `` - `` as separator and a "
"brief description of the module purpose."
msgstr "本部分应包括模块名称，`` - `` 作为分隔符和模块目的的简要说明。"

#: ../../content/contributing/code-style.rst:558
msgid "``SYNOPSIS`` section"
msgstr "``SYNOPSIS`` 部分"

#: ../../content/contributing/code-style.rst:537
msgid ""
"This section should give a short usage example of commonly used module "
"functions."
msgstr "本部分应提供常用模块功能的简短用法示例。"

#: ../../content/contributing/code-style.rst:539
#: ../../content/contributing/code-style.rst:563
msgid "Usage of this section is optional."
msgstr "使用此部分是可选的。"

#: ../../content/contributing/code-style.rst:574
msgid "``DESCRIPTION`` section"
msgstr "``DESCRIPTION`` 部分"

#: ../../content/contributing/code-style.rst:561
msgid ""
"This section should give more in-depth information about the module if "
"deemed necessary (instead of having a long ``NAME`` section)."
msgstr ""
"如果认为有必要，本部分应该提供有关模块的更多深入信息（而不是有个很长的 "
"``NAME`` 部分）。"

#: ../../content/contributing/code-style.rst:581
msgid "``PUBLIC INTERFACE`` section"
msgstr "``PUBLIC INTERFACE`` 部分"

#: ../../content/contributing/code-style.rst:577
msgid ""
"This section marks the begin of all functions that are part of the API and "
"therefore meant to be used by other modules."
msgstr "本部分标记了作为API一部分的所有函数的开头，因此意味着由其它模块使用。"

#: ../../content/contributing/code-style.rst:593
msgid "``PRIVATE FUNCTIONS`` section"
msgstr "``PRIVATE FUNCTIONS`` 部分"

#: ../../content/contributing/code-style.rst:584
msgid "This section marks the begin of private functions."
msgstr "本部分标志着私有函数的开始。"

#: ../../content/contributing/code-style.rst:586
msgid ""
"Functions below are not part of the API, to be used only within the module "
"and therefore not considered stable."
msgstr "以下函数不是API的一部分，仅在模块中使用，因此不被认为是稳定的。"

#: ../../content/contributing/code-style.rst:588
msgid ""
"It is advisable to use this section whenever one or more private functions "
"exist."
msgstr "只要存在一个或多个私有函数，建议使用此部分。"

#: ../../content/contributing/code-style.rst:596
msgid "Documenting Subroutines"
msgstr "记录子程序"

#: ../../content/contributing/code-style.rst:598
msgid ""
"Subroutines should always be documented. The documentation contains a "
"general description about what the subroutine does, a sample subroutine call "
"and what the subroutine returns. It should be in this order. A sample "
"documentation looks like this:"
msgstr ""
"应始终记录子程序文档。 该文档包含有关子程序的作用、示例子程序调用以及子程序返"
"回的内容的一般说明。 它应该按此顺序排列。 示例文档如下所示："

#: ../../content/contributing/code-style.rst:621
msgid "You can copy and paste a ``Data::Dumper`` output for the return values."
msgstr "您可以复制并粘贴 ``Data::Dumper`` 输出作为返回值。"

#: ../../content/contributing/code-style.rst:625
msgid "Code Comments in Perl"
msgstr "Perl中的代码注释"

#: ../../content/contributing/code-style.rst:627
msgid ""
"In general, you should try to write your code as readable and self-"
"explaining as possible. Don't write a comment to explain what obvious code "
"does, this is unnecessary duplication. Good comments should explain **why** "
"there is some code, possible side effects and anything that might be special "
"or unusually complicated about the code."
msgstr ""
"通常，您应该尝试将代码编写为可读和自我解释。 不要写注释来解释明显代码的作用，"
"这是不必要的重复。 好的注释应该解释 **为什么** 有一些代码、可能的副作用以及任"
"何可能特殊或异常复杂的代码。"

#: ../../content/contributing/code-style.rst:629
msgid "Please adhere to the following guidelines:"
msgstr "请遵守以下准则："

#: ../../content/contributing/code-style.rst:632
msgid "Make the code so readable that comments are not needed, if possible."
msgstr "如果可能的话，使代码具有可读性，以便不需要注释。"

#: ../../content/contributing/code-style.rst:632
msgid ""
"It's always preferable to write code so that it is very readable and self-"
"explaining, for example with precise variable and function names."
msgstr "编写非常易读和自我解释的代码总是比较好，例如使用精确的变量和函数名称。"

#: ../../content/contributing/code-style.rst:642
msgid "Don't say what the code says (DRY -> Don't repeat yourself)."
msgstr "不要说代码所说的（不要重复）。"

#: ../../content/contributing/code-style.rst:635
msgid "Don't repeat (obvious) code in the comments."
msgstr "不要在注释中重复（明显的）代码。"

#: ../../content/contributing/code-style.rst:645
msgid "Document **why** the code is there, not how it works."
msgstr "记录代码 **为什么** 在那里，而不是它的工作方式。"

#: ../../content/contributing/code-style.rst:645
msgid ""
"Usually, code comments should explain the *purpose* of code, not how it "
"works in detail. There might be exceptions for specially complicated code, "
"but in this case also a refactoring to make it more readable could be "
"commendable."
msgstr ""
"通常，代码注释应该解释代码的 *目的*，而不是它的详细工作原理。 特殊复杂代码可"
"能有例外，但在这种情况下，重构以使其更具可读性可能是值得称道的。"

#: ../../content/contributing/code-style.rst:648
msgid "Document pitfalls."
msgstr "记录陷阱。"

#: ../../content/contributing/code-style.rst:648
msgid ""
"Everything that is unclear, tricky or that puzzled you during development "
"should be documented."
msgstr "在开发过程中，所有不清楚、棘手或困扰您的事情都应该记录下来。"

#: ../../content/contributing/code-style.rst:665
msgid "Use full-line sentence-style comments to document algorithm paragraphs."
msgstr "使用整行句子样式注释来记录算法段落。"

#: ../../content/contributing/code-style.rst:651
msgid ""
"Always use full sentences (uppercase first letter and final period). "
"Subsequent lines of a sentence should be indented."
msgstr ""
"始终使用完整句子（大写第一个字母和最后一个句点）。 句子的后续行应缩进。"

#: ../../content/contributing/code-style.rst:677
msgid "Use short end-of-line comments to add detail information."
msgstr "使用简短的行尾注释添加详细信息。"

#: ../../content/contributing/code-style.rst:668
msgid ""
"These can either be a complete sentence (capital first letter and period) or "
"just a phrase (lowercase first letter and no period)."
msgstr ""
"这些可以是一个完整的句子（大写首字母和句点），也可以只是一个短语（小写首字母"
"和无句点）。"

#: ../../content/contributing/code-style.rst:680
msgid "Declaration of SQL Statements"
msgstr "SQL语句的声明"

#: ../../content/contributing/code-style.rst:682
msgid ""
"If there is no chance for changing the SQL statement, it should be used in "
"the ``Prepare`` function. The reason for this is, that the SQL statement and "
"the bind parameters are closer to each other."
msgstr ""
"如果没有机会更改SQL语句，则应在 ``Prepare`` 函数中使用它。 原因是，SQL语句和"
"绑定参数彼此更接近。"

#: ../../content/contributing/code-style.rst:684
msgid ""
"The SQL statement should be written as one nicely indented string without "
"concatenation like this:"
msgstr "SQL语句应该写成一个缩进良好的字符串，没有连接，如下所示："

#: ../../content/contributing/code-style.rst:699
msgid ""
"This is easy to read and modify, and the whitespace can be handled well by "
"our supported DBMSs. For auto-generated SQL code (like in ``TicketSearch``), "
"this indentation is not necessary."
msgstr ""
"这样很容易阅读和修改，我们支持的DBMS可以很好地处理空白。 对于自动生成的SQL代"
"码（如 ``TicketSearch`` ），此缩进不是必需的。"

#: ../../content/contributing/code-style.rst:703
msgid "Returning on Errors"
msgstr "出错时返回"

#: ../../content/contributing/code-style.rst:705
msgid ""
"Whenever you use database functions you should handle errors. If anything "
"goes wrong, return from subroutine:"
msgstr ""
"无论何时使用数据库函数，都应该处理错误。如果出现任何错误，请从子程序返回："

#: ../../content/contributing/code-style.rst:713
msgid "Using Limit"
msgstr "使用Limit"

#: ../../content/contributing/code-style.rst:715
msgid "Use ``Limit => 1`` if you expect just one row to be returned."
msgstr "如果你希望只返回一行，使用 ``Limit => 1`` 。"

#: ../../content/contributing/code-style.rst:727
msgid "Using the ``while`` loop"
msgstr "使用 ``while`` 循环"

#: ../../content/contributing/code-style.rst:729
msgid ""
"Always use the ``while`` loop, even when you expect one row to be returned, "
"as some databases do not release the statement handle and this can lead to "
"weird bugs."
msgstr ""
"总是使用 ``while`` 循环，即使你期望返回一行，因为一些数据库不释放语句句柄，这"
"可能导致奇怪的错误。"

#: ../../content/contributing/code-style.rst:733
msgid "JavaScript"
msgstr "JavaScript"

#: ../../content/contributing/code-style.rst:735
msgid ""
"All JavaScript is loaded in all browsers (no browser hacks in the template "
"files). The code is responsible to decide if it has to skip or execute "
"certain parts of itself only in certain browsers."
msgstr ""
"在所有的浏览器中所有的JavaScript都会加载（模板文件中没有浏览器入侵）。代码负"
"责决定是否必须跳过或仅在某些浏览器中执行其自身的某些部分。"

#: ../../content/contributing/code-style.rst:739
msgid "Directory Structure"
msgstr "目录结构"

#: ../../content/contributing/code-style.rst:741
msgid "Directory structure inside the ``var/httpd/htdocs/js/`` folder:"
msgstr "``var/httpd/htdocs/js/`` 文件夹内的目录结构："

#: ../../content/contributing/code-style.rst:755
msgid "Thirdparty Code"
msgstr "第三方代码"

#: ../../content/contributing/code-style.rst:757
msgid ""
"Every thirdparty module gets its own subdirectory: *module name-version "
"number* (e.g. ckeditor-4.7.0, jquery-3.2.1). Inside of that, file names "
"should not have a version number or postfix included (wrong: ``jquery/"
"jquery-3.2.1.min.js``, right: ``jquery-3.2.1/jquery.js``)."
msgstr ""
"每个第三方模块都有自己的子目录： *模块名称-版本号* （例如，ckeditor-4.7.0、"
"jquery-3.2.1）。其中，文件名不应包含版本号或后缀（错误： ``jquery/"
"jquery-3.2.1.min.js`` ，正确： ``jquery-3.2.1/jquery.js`` ）。"

#: ../../content/contributing/code-style.rst:761
msgid "JavaScript Variables"
msgstr "JavaScript变量"

#: ../../content/contributing/code-style.rst:763
msgid "Variable names should be CamelCase, just like in Perl."
msgstr "变量名应该使用骆驼拼写法，就像在Perl中一样。"

#: ../../content/contributing/code-style.rst:765
msgid ""
"Variables that hold a jQuery object should start with ``$``, for example: ``"
"$Tooltip``."
msgstr "保存jQuery对象的变量应以 ``$`` 开头，例如： ``$Tooltip`` 。"

#: ../../content/contributing/code-style.rst:769
msgid "Functions"
msgstr "函数"

#: ../../content/contributing/code-style.rst:771
msgid "Function names should be CamelCase, just like in Perl."
msgstr "函数名应该使用骆驼拼写法，就像在Perl中一样。"

#: ../../content/contributing/code-style.rst:775
msgid "Namespaces"
msgstr "命名空间"

#: ../../content/contributing/code-style.rst:781
msgid "Code Comments in JavaScript"
msgstr "JavaScript中的代码注释"

#: ../../content/contributing/code-style.rst:783
msgid "The :ref:`Code Comments in Perl` also apply to JavaScript."
msgstr ":ref:`Code Comments in Perl` 也适用于javascript。"

#: ../../content/contributing/code-style.rst:785
msgid "Single line comments are done with ``//``."
msgstr "单行注释用 ``//`` 完成。"

#: ../../content/contributing/code-style.rst:786
msgid "Longer comments are done with ``/* ... */``."
msgstr "使用 ``/ * ... */`` 进行更长的注释。"

#: ../../content/contributing/code-style.rst:787
msgid ""
"If you comment out parts of your JavaScript code, only use ``//`` because ``/"
"* ... */`` can cause  problems with regular expressions in the code."
msgstr ""
"如果你注释掉JavaScript代码的一部分，只使用 ``//`` ，因为 ``/* ... */`` 会导致"
"代码中的正则表达式出现问题。"

#: ../../content/contributing/code-style.rst:791
msgid "Event Handling"
msgstr "事件处理"

#: ../../content/contributing/code-style.rst:793
msgid ""
"Always use ``$.on()`` instead of the event-shorthand methods of jQuery for "
"better readability (wrong: ``$SomeObject.click(...)``, right: ``$SomeObject."
"on('click', ...``)."
msgstr ""
"总是使用 ``$.on()`` 代替jQuery的事件简写方法以获得更好的可读性（错误： ``"
"$SomeObject.click(...)`` ，正确： ``$SomeObject.on('click', ...``)）。"

#: ../../content/contributing/code-style.rst:795
msgid ""
"If you ``$.on()`` events, make sure to ``$.off()`` them beforehand, to make "
"sure that events will not be bound twice, should the code be executed "
"another time."
msgstr ""
"如果你 ``$.on()`` 事件，请确保事先 ``$.off()`` 它们，以确保如果代码再次执行，"
"事件不会绑定两次。"

#: ../../content/contributing/code-style.rst:797
msgid ""
"Make sure to use ``$.on()`` with namespacing, such as ``$.on('click."
"<Name>')``."
msgstr "确保在命名空间中使用 ``$.on()`` ，比如 ``$.on('click.<Name>')`` 。"

#: ../../content/contributing/code-style.rst:801
msgid "HTML"
msgstr "HTML"

#: ../../content/contributing/code-style.rst:803
msgid ""
"Use HTML 5 notation. Don't use self-closing tags for non-void elements (such "
"as ``div``, ``span``, etc.)."
msgstr ""
"使用HTML 5表示法。 不要将自闭合标签用于非空元素（例如 ``div`` 、 ``span`` "
"等）。"

#: ../../content/contributing/code-style.rst:805
msgid ""
"Use proper intendation. Elements which contain other non-void child elements "
"should not be on the same level as their children."
msgstr "使用正确的缩进。 包含其它非空子元素的元素不应与子元素处于同一级别。"

#: ../../content/contributing/code-style.rst:807
msgid ""
"Don't use HTML elements for layout reasons (e.g. using ``br`` elements for "
"adding space to the top or bottom of other elements). Use the proper CSS "
"classes instead."
msgstr ""
"不要出于布局原因使用HTML元素（例如，使用 ``br`` 元素为其它元素的顶部或底部添"
"加空间）。 请改用适当的CSS类。"

#: ../../content/contributing/code-style.rst:809
msgid ""
"Don't use inline CSS. All CSS should either be added by using predefined "
"classes or (if necessary) using JavaScript (e.g. for showing/hiding "
"elements)."
msgstr ""
"不要使用内联CSS。 所有的CSS应该使用预定义的类或者（如果需要的话）使用"
"JavaScript来添加（例如用于显示/隐藏元素）。"

#: ../../content/contributing/code-style.rst:811
msgid ""
"Don't use JavaScript in templates. All needed JavaScript should be part of "
"the proper library for a certain front end module or of a proper global "
"library. If you need to pass JavaScript data to the front end, use ``"
"$LayoutObject->AddJSData()``."
msgstr ""
"不要在模板中使用JavaScript。对于某个前端模块或适当的全局库，所有需要的"
"JavaScript都应该是适当库的一部分。 如果需要将JavaScript数据传递到前端，请使"
"用 ``$LayoutObject->AddJSData()`` 。"

#: ../../content/contributing/code-style.rst:815
msgid "CSS"
msgstr "CSS"

#: ../../content/contributing/code-style.rst:817
msgid "Minimum resolution is 1024x768px."
msgstr "最小分辨率为1024x768像素。"

#: ../../content/contributing/code-style.rst:819
msgid ""
"The layout is liquid, which means that if the screen is wider, the space "
"will be used."
msgstr "布局是流动的，这意味着如果屏幕变宽，空间也会被使用。"

#: ../../content/contributing/code-style.rst:821
msgid ""
"Absolute size measurements should be specified in px to have a consistent "
"look on many platforms and browsers."
msgstr ""
"应该以px（像素）指定绝对大小的测量值，以在许多平台和浏览器上保持一致的外观。"

#: ../../content/contributing/code-style.rst:823
msgid ""
"Documentation is made with CSSDOC (see CSS files for examples). All logical "
"blocks should have a CSSDOC comment."
msgstr ""
"文档是使用CSSDOC制作的（请参阅CSS文件的示例）。 所有的逻辑块应该有一个CSSDOC"
"注释。"

#: ../../content/contributing/code-style.rst:827
msgid "CSS Architecture"
msgstr "CSS体系结构"

#: ../../content/contributing/code-style.rst:829
msgid ""
"We follow the `Object Oriented CSS <http://wiki.github.com/stubbornella/"
"oocss/>`__ approach. In essence, this means that the layout is achieved by "
"combining different generic building blocks to realize a particular design."
msgstr ""
"我们遵循 `面向对象的CSS <http://wiki.github.com/stubbornella/oocss/>`__ 方"
"法。本质上，这意味着布局是通过组合不同的通用构建块来实现特定的设计。"

#: ../../content/contributing/code-style.rst:831
msgid ""
"Wherever possible, module specific design should not be used. Therefore we "
"also do not work with IDs on the ``body`` element, for example, if it can be "
"avoided."
msgstr ""
"只要有可能，就不应使用模块特定的设计。 因此，如果可以避免的话，我们也不使用 "
"``body`` 元素上的ID。"

#: ../../content/contributing/code-style.rst:835
msgid "CSS Style"
msgstr "CSS样式"

#: ../../content/contributing/code-style.rst:837
msgid ""
"All definitions have a ``{`` in the same line as the selector, all rules are "
"defined in one row per rule, the definition ends with a row with a single ``}"
"`` in it."
msgstr ""
"所有定义在选择器的同一行中都有一个 ``{`` ，所有规则都按每个规则一行定义，定义"
"以一个单行的 ``}`` 结束。"

#: ../../content/contributing/code-style.rst:839
msgid "See the following example:"
msgstr "请参阅以下示例："

#: ../../content/contributing/code-style.rst:849
msgid "Between ``:`` and the rule value, there is a space."
msgstr "在 ``:`` 和规则值之间，有一个空格。"

#: ../../content/contributing/code-style.rst:850
msgid "Every rule has an indent of 4 spaces."
msgstr "每条规则都有4个空格的缩进。"

#: ../../content/contributing/code-style.rst:851
msgid ""
"If multiple selectors are specified, separate them with comma and put each "
"one on an own line:"
msgstr "如果指定了多个选择器，请用逗号分隔它们，并且一行一个："

#: ../../content/contributing/code-style.rst:861
msgid ""
"If rules are combinable, combine them (e.g. combine ``background-position``, "
"``background-image``, etc. into ``background``)."
msgstr ""
"如果规则是可组合的，则将它们组合起来（例如将 ``background-position`` 、 "
"``background-image`` 等组合成 ``background`` ）。"

#: ../../content/contributing/code-style.rst:863
msgid ""
"Rules should be in a logical order within a definition (all color specific "
"rule together, all positioning rules together, etc.)."
msgstr ""
"规则应该在定义内按逻辑顺序排列（所有颜色特定规则在一起、所有定位规则在一起"
"等）。"

#: ../../content/contributing/code-style.rst:864
msgid "All IDs and names are written in CamelCase notation:"
msgstr "所有ID和名称都以驼峰式命名法编写："

#: ../../content/contributing/sending-contributions.rst:2
msgid "Sending Contributions"
msgstr "发送贡献"

#: ../../content/contributing/sending-contributions.rst:4
msgid ""
"The source code of ((OTRS)) Community Edition and additional public modules "
"can be found on `GitHub <https://github.com/OTRS>`__. From there you can get "
"to the listing of all available repositories. It also describes the "
"currently active branches and where contributions should go to (stable vs. "
"development branches)."
msgstr ""
"可以在 `GitHub <https://github.com/OTRS>`__ 上找到((OTRS))社区版和其它公共模"
"块的源代码。 从那里，您可以访问所有可用存储库的列表。 它还描述了当前活动的分"
"支以及贡献应该去哪里（稳定分支与开发分支）。"

#: ../../content/contributing/sending-contributions.rst:6
msgid ""
"It is highly recommended that you use the OTRS code quality checker "
"`OTRSCodePolicy <https://github.com/OTRS/otrscodepolicy>`__ as described in "
"the :ref:`Useful Tools` even before sending in your contributions. If your "
"code does not validate against this tool, it will likely not be accepted."
msgstr ""
"强烈建议您在发送贡献之前使用 :ref:`Useful Tools` 中所述的OTRS代码质量检查程"
"序 `OTRSCodePolicy <https://github.com/OTRS/otrscodepolicy>`__ 。如果您的代码"
"没有通过这个工具进行验证，那么它很可能不会被接受。"

#: ../../content/contributing/sending-contributions.rst:8
msgid ""
"The easiest way to send your contributions to the OTRS developer's team is "
"by creating a *pull request* in GitHub. Please take a look at the "
"instructions on `GitHub <https://help.github.com>`__, specifically about "
"`forking a repository and sending pull requests <https://help.github.com/"
"articles/fork-a-repo>`__."
msgstr ""
"将您的贡献发送给OTRS开发人员团队的最简单方法是在Github中创建一个 *pull "
"request*。请查看关于 `GitHub <https://help.github.com>`__，特别是关于 "
"`forking a repository and sending pull requests <https://help.github.com/"
"articles/fork-a-repo>`__ 的说明。"

#: ../../content/contributing/sending-contributions.rst:10
msgid "The basic workflow would look like this:"
msgstr "基础的工作流应看起来像这样："

#: ../../content/contributing/sending-contributions.rst:12
msgid "Register at GitHub, if you have no account yet."
msgstr "如果您还没有帐户，请在GitHub注册。"

#: ../../content/contributing/sending-contributions.rst:13
msgid ""
"Fork the repository you want to contribute to, and checkout the branch that "
"the changes should go in."
msgstr "克隆您要贡献的仓库（Fork），并检出要进行更改的分支。"

#: ../../content/contributing/sending-contributions.rst:14
msgid ""
"Create a new development branch for your fix/feature/contribution, based on "
"the current branch."
msgstr "根据当前分支为您的修订/特色功能/贡献创建一个新的开发分支。"

#: ../../content/contributing/sending-contributions.rst:15
msgid ""
"After you finished your changes and committed them, push your branch to "
"GitHub."
msgstr "完成更改并提交更改后，将分支推送到GitHub。"

#: ../../content/contributing/sending-contributions.rst:16
msgid ""
"Create a pull request. The OTRS dev team will be notified about this, check "
"your pull request and either merge it or give you some feedback about "
"possible improvements."
msgstr ""
"创建一个\"pull request\"， OTRS开发团队将会收到通知，并检查您的\"pull request"
"\"，要么合并更改，要么给您一些关于可能的改进的反馈。"

#: ../../content/contributing/sending-contributions.rst:18
msgid ""
"It might sound complicated, but once you have this workflow set up you'll "
"see that making contributions is extremely easy."
msgstr ""
"这可能听起来很复杂，但一旦你设置了这个工作流程，你会看到做出贡献非常简单。"

#: ../../content/contributing/translate.rst:2
msgid "Translating"
msgstr "翻译"

#: ../../content/contributing/translate.rst:4
msgid ""
"The translations are contributed and maintained mainly by OTRS users, so "
"*your* help is needed."
msgstr "翻译主要由OTRS用户提供和维护，因此需要 *您的* 帮助。"

#: ../../content/contributing/translate.rst:6
#: ../../content/documentation/translate-documentation.rst:4
msgid ""
"All translations of the OTRS GUI, the public extension modules and the "
"documentations are managed using `Weblate <https://translate.otrs.com/>`__."
msgstr ""
"OTRS 图形界面、公共扩展模块和文档的所有翻译都通过 `Weblate <https://"
"translate.otrs.com/>`__ 进行管理。"

#: ../../content/contributing/translate.rst:8
msgid "To contribute to translations:"
msgstr "为翻译做出贡献："

#: ../../content/contributing/translate.rst:10
msgid ""
"Sign up for a free translator account on `Weblate <https://translate.otrs."
"com/>`__."
msgstr "在 `Weblate <https://translate.otrs.com/>`__ 注册一个免费的翻译帐户。"

#: ../../content/contributing/translate.rst:11
msgid "Select a translation component and your language for translation."
msgstr "选择翻译组件和要翻译的语言。"

#: ../../content/contributing/translate.rst:12
msgid ""
"Start updating your translation. No additional software or files required."
msgstr "开始更新您的翻译。 无需其它软件或文件。"

#: ../../content/contributing/translate.rst:16
msgid ""
"If your language is not listed in the dashboard, you can request a language. "
"After it is approved, you can start translating."
msgstr ""
"如果仪表板中未列出您的语言，则可以请求一门语言。经批准后，您就可以开始翻译。"

#: ../../content/contributing/translate.rst:18
#: ../../content/documentation/translate-documentation.rst:6
msgid ""
"From OTRS 7 the documentations are available in *reStructuredText* format, "
"that replaced the old *DocBook* format. Be careful not to break the "
"structure while translating the documentation."
msgstr ""
"从OTRS 7开始，文档以 *reStructuredText* 格式提供，取代了旧的 *DocBook* 格"
"式。 翻译文档时请注意不要破坏结构。"

#: ../../content/contributing/translate.rst:22
msgid "You can find some examples in the :doc:`../documentation` chapter."
msgstr "您可以在 :doc:`../documentation` 一章中找到一些示例。"

#: ../../content/contributing/translate.rst:24
msgid ""
"The OTRS developers will download the translations from time to time into "
"the OTRS source code repositories, you don't have to submit them anywhere."
msgstr "OTRS开发人员会不时将翻译下载到OTRS源代码库中，您无需在任何地方提交。"

#: ../../content/contributing/ui-design.rst:2
msgid "User Interface Design"
msgstr "用户界面设计"

#: ../../content/contributing/ui-design.rst:6
msgid "Capitalization"
msgstr "字母大写样式"

#: ../../content/contributing/ui-design.rst:8
msgid ""
"This section talks about how the different parts of the English user "
"interface should be capitalized. For further information, you may want to "
"review `this helpful page <https://msdn.microsoft.com/en-us/library/dn742478."
"aspx>`__."
msgstr ""
"本节讨论如何将英语用户界面的不同部分大写。 有关详细信息，您可能需要查看 `这个"
"有用的页面 <https://msdn.microsoft.com/en-us/library/dn742478.aspx>`__。"

#: ../../content/contributing/ui-design.rst:10
msgid ""
"Headings (h1-h6) and titles (names, such as *Queue View*) are set in *title "
"style* capitalization, that means all first letters will be capitalized "
"(with a few exceptions such as *this*, *and*, *or* etc.)."
msgstr ""
"标题（h1-h6）和标题（名称，如 *队列视图*）设置为 *标题样式* 大小写，这意味着"
"所有首字母都将大写（少数例外情况，如 *this* 、*and*、*or* 等）。"

#: ../../content/contributing/ui-design.rst:12
#: ../../content/contributing/ui-design.rst:19
msgid "Examples:"
msgstr "例子："

#: ../../content/contributing/ui-design.rst:14
msgid "*Action List*"
msgstr "*Action List*"

#: ../../content/contributing/ui-design.rst:15
msgid "*Manage Customer-Group Relations*"
msgstr "*管理客户-组的关联*"

#: ../../content/contributing/ui-design.rst:17
msgid ""
"Other structural elements such as buttons, labels, tabs, menu items are set "
"in *sentence style* capitalization (only the first letter of a phrase is "
"capitalized), but no final dot is added to complete the phrase as a sentence."
msgstr ""
"按钮、标签、选项卡、菜单项等其它结构元素以 *句子样式* 大写形式设置（只有短语"
"的第一个字母大写），但不添加最后一个点以完成句子形式的短语。"

#: ../../content/contributing/ui-design.rst:21
msgid "*First name*"
msgstr "*名*"

#: ../../content/contributing/ui-design.rst:22
msgid "*Select queue refresh time*"
msgstr "*选择队列刷新时间*"

#: ../../content/contributing/ui-design.rst:23
msgid "*Print this ticket*"
msgstr "*打印此工单*"

#: ../../content/contributing/ui-design.rst:25
msgid ""
"Descriptive texts and tooltip contents are written as complete sentences."
msgstr "描述性文本和提示内容被写为完整句子。"

#: ../../content/contributing/ui-design.rst:27
#: ../../content/get-started/development-environment.rst:63
msgid "Example:"
msgstr "例如："

#: ../../content/contributing/ui-design.rst:29
msgid "*This value is required.*"
msgstr "*此值为必填项。*"

#: ../../content/contributing/ui-design.rst:31
msgid ""
"For translations, it has to be checked if the title style capitalization is "
"also appropriate in the target language. It might have to be changed to "
"sentence style capitalization or something else."
msgstr ""
"翻译时必须检查标题大写样式是否也适合目标语言， 它可能需要改为句子大写样式或别"
"的。"

#: ../../content/contributing/unit-tests.rst:2
msgid "Unit Tests"
msgstr "单元测试"

#: ../../content/contributing/unit-tests.rst:4
msgid ""
"OTRS provides a test suite which can be used to develop and run unit tests "
"for all system related code."
msgstr "OTRS提供了一个测试套件，可用于开发和运行所有系统相关代码的单元测试。"

#: ../../content/contributing/unit-tests.rst:8
msgid "Creating a Test File"
msgstr "创建一个测试文件"

#: ../../content/contributing/unit-tests.rst:10
msgid ""
"The test files are stored in ``.t`` files under ``scripts/test/*.t``. For "
"example, let's take a look at the file ``scripts/test/Calendar.t`` for the "
"*Calendar* class."
msgstr ""
"测试文件存储在 ``scripts/test/*.t`` 下的 ``.t`` 文件中。例如，让我们看一下 "
"*calendar（日历）* 类的文件 ``scripts/test/calendar.t`` 。"

#: ../../content/contributing/unit-tests.rst:12
msgid ""
"Every test file should ideally instantiate unit test helper object at the "
"start, so it can benefit from some built-in methods provided by it:"
msgstr ""
"每个测试文件都应该在开始时实例化单元测试helper对象，以便它可以从它提供的一些"
"内置方法中受益："

#: ../../content/contributing/unit-tests.rst:37
msgid ""
"By providing ``RestoreDatabase`` parameter to helper constructor, any "
"database statement executed during the unit test will be rolled back at the "
"end, making sure no permanent change has been done."
msgstr ""
"通过向helper构造函数提供 ``RestoreDatabase`` 参数，在单元测试期间执行的任何数"
"据库语句都将在结束时回滚，确保没有进行永久性更改。"

#: ../../content/contributing/unit-tests.rst:39
msgid ""
"Like any other test suite, OTRS provides assertion methods which can be used "
"to test conditions. For example, this is how we create a test user and test "
"that it has been indeed created:"
msgstr ""
"像任何其它测试套件一样，OTRS提供了可用于测试条件的断言方法。 例如，下面就是我"
"们如何创建测试用户并测试它确实已经创建的："

#: ../../content/contributing/unit-tests.rst:51
msgid ""
"Please consult API section below for complete list of assertion methods."
msgstr "有关断言方法的完整列表，请参阅下面的API部分。"

#: ../../content/contributing/unit-tests.rst:53
msgid ""
"It's always good practice to create random data in unit tests, which can "
"help distinguish it from previously added data. Use random methods from API "
"to get the strings and include them in your parameters:"
msgstr ""
"在单元测试中创建随机数据总是一个很好的做法，这可以帮助将它与以前添加的数据区"
"分开来。 使用API中的随机方法获取字符串并将其包含在你的参数中："

#: ../../content/contributing/unit-tests.rst:72
msgid ""
"Good developers make their unit test easy to maintain. Consider putting all "
"test cases in an array and then iterate over them with some code. This will "
"provide an easy way to extend the test later:"
msgstr ""
"优秀的开发人员使他们的单元测试易于维护。 考虑将所有的测试用例放在一个数组中，"
"然后用一些代码对它们进行迭代。 这将为以后扩展测试提供一个简单的方法："

#: ../../content/contributing/unit-tests.rst:144
msgid "Prerequisites for Testing"
msgstr "测试的先决条件"

#: ../../content/contributing/unit-tests.rst:146
msgid ""
"To be able to run the unit tests, you need to have all optional environment "
"dependencies (Perl modules and other modules) installed, except those for "
"different database back ends than what you are using. Run ``bin/otrs."
"CheckEnvironment.pl`` to verify your module installation."
msgstr ""
"为了能够运行单元测试，您需要安装所有可选的环境依赖项（Perl模块和其它模块），"
"除了那些用于不同数据库后端的依赖项以外。运行 ``bin/otrs.checkenvironment."
"pl`` 验证模块安装。"

#: ../../content/contributing/unit-tests.rst:148
msgid ""
"You also need to have an instance of the OTRS web front end running on the "
"FQDN that is configured in your local OTRS's ``Config.pm`` file. This OTRS "
"instance must use the same database that is configured for the unit tests."
msgstr ""
"您还需要在本地OTRS的 ``Config.pm`` 文件中配置的FQDN上运行OTRS Web前端的实例。"
"此OTRS实例必须使用为单元测试配置的相同数据库。"

#: ../../content/contributing/unit-tests.rst:152
msgid "Testing"
msgstr "测试"

#: ../../content/contributing/unit-tests.rst:154
msgid ""
"To run your tests, just use ``bin/otrs.Console.pl Dev::UnitTest::Run --test "
"Calendar`` to use ``scripts/test/Calendar.t``."
msgstr ""
"若要运行你的测试，只需执行 ``bin/otrs.Console.pl Dev::UnitTest::Run --test "
"Calendar`` 即可使用 ``scripts/test/Calendar.t``。"

#: ../../content/contributing/unit-tests.rst:168
msgid ""
"You can even run several tests at once, just supply additional ``--test`` "
"arguments to the command:"
msgstr "您甚至可以一次运行多个测试，只需为命令提供额外的 ``--test`` 参数："

#: ../../content/contributing/unit-tests.rst:186
msgid ""
"If you execute ``bin/otrs.Console.pl Dev::UnitTest::Run`` without any "
"argument, it will run all tests found in the system. Please note that this "
"can take some time to finish."
msgstr ""
"如果你不带任何参数执行 ``bin/otrs.Console.pl Dev::UnitTest::Run`` ，它将运行"
"系统中找到的所有测试。请注意，这可能需要一些时间才能完成。"

#: ../../content/contributing/unit-tests.rst:188
msgid ""
"Provide ``--verbose`` argument in order to see messages about successful "
"tests too. Any errors encountered during testing will be displayed "
"regardless of this switch, provided they are actually raised in the test."
msgstr ""
"还提供 ``--verbose`` 参数，以便查看有关成功测试的消息。测试过程中遇到的任何错"
"误都将显示出来，只要它们在测试中被实际引发，而不管是否有这个开关。"

#: ../../content/contributing/unit-tests.rst:192
msgid "Unit Test API"
msgstr "单元测试API"

#: ../../content/contributing/unit-tests.rst:194
msgid ""
"OTRS provides API for unit testing that was used in the previous example. "
"Here we'll list the most important functions, please also see the online API "
"reference of ```Kernel::System::UnitTest`` <https://otrs.github.io/doc/api/"
"otrs/7.0/Perl/Kernel/System/UnitTest.pm.html>`__."
msgstr ""
"OTRS为上一个示例中使用的单元测试提供API。在这里，我们将列出最重要的函数，请参"
"阅 `Kernel::System::UnitTest <https://otrs.github.io/doc/api/otrs/7.0/Perl/"
"Kernel/System/UnitTest.pm.html>`__ 的在线API参考。"

#: ../../content/contributing/unit-tests.rst:204
msgid "``True()``"
msgstr "``True()``"

#: ../../content/contributing/unit-tests.rst:197
msgid "This function tests whether given scalar value is a true value in Perl."
msgstr "这个函数测试给定的标量值在Perl中是否为真值。"

#: ../../content/contributing/unit-tests.rst:214
msgid "``False()``"
msgstr "``False()``"

#: ../../content/contributing/unit-tests.rst:207
msgid ""
"This function tests whether given scalar value is a false value in Perl."
msgstr "这个函数测试给定的标量值在Perl中是否为假值。"

#: ../../content/contributing/unit-tests.rst:225
msgid "``Is()``"
msgstr "``Is()``"

#: ../../content/contributing/unit-tests.rst:217
msgid "This function tests whether the given scalar variables are equal."
msgstr "这个函数测试给定的标量变量是否相等。"

#: ../../content/contributing/unit-tests.rst:236
msgid "``IsNot()``"
msgstr "``IsNot()``"

#: ../../content/contributing/unit-tests.rst:228
msgid "This function tests whether the given scalar variables are unequal."
msgstr "这个函数测试给定的标量变量是否不相等。"

#: ../../content/contributing/unit-tests.rst:247
msgid "``IsDeeply()``"
msgstr "``IsDeeply()``"

#: ../../content/contributing/unit-tests.rst:239
msgid ""
"This function compares complex data structures for equality. ``$A`` and ``"
"$B`` have to be references."
msgstr "这个函数比较复杂的数据结构是否相等。``$A`` 和 ``$B`` 必须是引用。"

#: ../../content/contributing/unit-tests.rst:258
msgid "``IsNotDeeply()``"
msgstr "``IsNotDeeply()``"

#: ../../content/contributing/unit-tests.rst:250
msgid ""
"This function compares complex data structures for inequality. ``$A`` and ``"
"$B`` have to be references."
msgstr "这个函数比较复杂的数据结构是否不相等。 ``$A`` 和 ``$B`` 必须是引用。"

#: ../../content/contributing/unit-tests.rst:260
msgid ""
"Besides this, unit test helper object also provides some helpful methods for "
"common test conditions. For full reference, please see the online API "
"reference of ```Kernel::System::UnitTest::Helper`` <https://doc.otrs.com/doc/"
"api/otrs/7.0/Perl/Kernel/System/UnitTest/Helper.pm.html>`__."
msgstr ""
"除此之外，单元测试helper对象还为常见的测试条件提供了一些有用的方法。 如需完整"
"参考，请参阅 `Kernel::System::UnitTest::Helper <https://doc.otrs.com/doc/api/"
"otrs/7.0/Perl/Kernel/System/UnitTest/Helper.pm.html>`__ 的在线API参考。"

#: ../../content/contributing/unit-tests.rst:272
msgid "``GetRandomID()``"
msgstr "``GetRandomID()``"

#: ../../content/contributing/unit-tests.rst:263
msgid ""
"This function creates a random ID that can be used in tests as a unique "
"identifier. It is guaranteed that within a test this function will never "
"return a duplicate."
msgstr ""
"这个函数创建一个随机ID，可以在测试中用作唯一标识符。 这可以保证在一个测试内，"
"这个函数永远不会返回一个重复。"

#: ../../content/contributing/unit-tests.rst:267
msgid ""
"Please note that these numbers are not really random and should only be used "
"to create test data."
msgstr "请注意，这些数字并不是真正的随机数，只能用于创建测试数据。"

#: ../../content/contributing/unit-tests.rst:282
msgid "``TestUserCreate()``"
msgstr "``TestUserCreate()``"

#: ../../content/contributing/unit-tests.rst:275
msgid ""
"This function creates a test user that can be used in tests. It will be set "
"to invalid automatically during the destructor. It returns the login name of "
"the new user, the password is the same."
msgstr ""
"这个函数创建一个可以在测试中使用的测试用户。 它将在析构函数中自动设置为无"
"效。 它返回新用户的登录名，密码与用户名相同。"

#: ../../content/contributing/unit-tests.rst:295
msgid "``FixedTimeSet()``"
msgstr "``FixedTimeSet()``"

#: ../../content/contributing/unit-tests.rst:285
msgid ""
"This functions makes it possible to override the system time as long as this "
"object lives. You can pass an optional time parameter that should be used, "
"if not, the current system time will be used."
msgstr ""
"只要此对象存在，这个函数就可以覆盖系统时间。 你可以传递要使用的可选时间参数，"
"如果没有参数，则会使用当前系统时间。"

#: ../../content/contributing/unit-tests.rst:289
msgid ""
"All calls to methods of ``Kernel::System::Time`` and ``Kernel::System::"
"DateTime`` will use the given time afterwards."
msgstr ""
"对 ``Kernel::System::Time`` 和 ``Kernel::System::DateTime`` 方法的所有调用都"
"将使用给定的时间。"

#: ../../content/contributing/unit-tests.rst:298
msgid "``FixedTimeUnset()``"
msgstr "``FixedTimeUnset()``"

#: ../../content/contributing/unit-tests.rst:298
msgid "This functions restores the regular system time behavior."
msgstr "这个函数恢复常规的系统时间行为。"

#: ../../content/contributing/unit-tests.rst:301
msgid "``FixedTimeAddSeconds()``"
msgstr "``FixedTimeAddSeconds()``"

#: ../../content/contributing/unit-tests.rst:301
msgid ""
"This functions adds a number of seconds to the fixed system time which was "
"previously set by ``FixedTimeSet()``. You can pass a negative value to go "
"back in time."
msgstr ""
"这个函数为固定时间增加几秒钟，这个时间先前由 ``FixedTimeSet()`` 设置。 您可以"
"通过一个负值返回之前的时间。"

#: ../../content/contributing/unit-tests.rst:316
msgid "``ConfigSettingChange()``"
msgstr "``ConfigSettingChange()``"

#: ../../content/contributing/unit-tests.rst:304
msgid ""
"This functions temporarily changes a configuration setting system wide to "
"another value, both in the current instance of the ``ConfigObject`` and also "
"in the system configuration on disk. This will be reset when the ``Helper`` "
"object is destroyed."
msgstr ""
"这个函数临时将系统范围内的配置设置更改为另一个值，既在 ``ConfigObject`` 的当"
"前实例中，也在磁盘上的系统配置中。当 ``Helper`` 对象被销毁时，这将被重置。"

#: ../../content/contributing/unit-tests.rst:308
#: ../../content/contributing/unit-tests.rst:323
msgid ""
"Please note that this will not work correctly in clustered environments."
msgstr "请注意，这个函数在集群环境中无法正常工作。"

#: ../../content/contributing/unit-tests.rst:345
msgid "``CustomCodeActivate()``"
msgstr "``CustomCodeActivate()``"

#: ../../content/contributing/unit-tests.rst:319
msgid ""
"This function will temporarily include custom code in the system. For "
"example, you may use this to redefine a subroutine from another class. This "
"change will persist for remainder of the test. All code will be removed when "
"the ``Helper`` object is destroyed."
msgstr ""
"这个函数将在系统中临时包含自定义代码。例如，可以使用它从另一个类重新定义子程"
"序。此更改将在测试的其余部分持续。当 ``Helper`` 对象被销毁时，所有代码都将被"
"删除。"

#: ../../content/contributing/unit-tests.rst:372
msgid "``ProvideTestDatabase()``"
msgstr "``ProvideTestDatabase()``"

#: ../../content/contributing/unit-tests.rst:348
msgid ""
"This function will provide a temporary database for the test. Please first "
"define test database settings in ``Kernel/Config.pm``, i.e:"
msgstr ""
"这个函数将为测试提供临时数据库。请首先在 ``Kernel/Config.pm`` 中定义测试数据"
"库设置，如："

#: ../../content/contributing/unit-tests.rst:358
msgid ""
"The method call will override global database configuration for duration of "
"the test, i.e. temporary database will receive all calls sent over system "
"``DBObject``."
msgstr ""
"方法调用将在测试期间覆盖全局数据库配置，即临时数据库将接收通过系统 "
"``DBObject`` 发送的所有调用。"

#: ../../content/contributing/unit-tests.rst:360
msgid ""
"All database contents will be automatically dropped when the ``Helper`` "
"object is destroyed."
msgstr "当 ``Helper`` 对象被销毁时，所有数据库内容都将自动删除。"

#: ../../content/contributing/unit-tests.rst:362
msgid ""
"This method returns ``undef`` in case the test database is not configured. "
"If it is configured, but the supplied XML cannot be read or executed, this "
"method will ``die()`` to interrupt the test with an error."
msgstr ""
"如果未配置测试数据库，此方法将返回 ``undef`` 。 如果它已配置，但无法读取或执"
"行提供的XML，则此方法将调用 ``die()`` 以中断测试并显示错误。"

#: ../../content/documentation.rst:2
msgid "Documentation"
msgstr "文档"

#: ../../content/documentation.rst:4
msgid ""
"From OTRS 7 the documentations are available in *reStructuredText* format, "
"that replaced the old *DocBook* format. Various outputs are available on the "
"`OTRS documentation page <https://doc.otrs.com/doc/index.html>`__, like "
"HTML, EPUB and PDF."
msgstr ""
"从OTRS 7开始，文档以 *reStructuredText* 格式提供，取代了旧的 *DocBook* 格"
"式。 在 `OTRS文档页面 <https://doc.otrs.com/doc/index.html>`__ 上可以获得各种"
"输出格式，如HTML、EPUB和PDF。"

#: ../../content/documentation.rst:6
msgid ""
"The documentation is written in English and translated into many languages."
msgstr "文档是用英语编写的，并翻译成多种语言。"

#: ../../content/documentation/documentation-infrastucture.rst:2
msgid "Documentation Infrastructure"
msgstr "文档基础架构"

#: ../../content/documentation/documentation-infrastucture.rst:4
msgid ""
"OTRS uses `Sphinx <http://www.sphinx-doc.org/>`__ to generate the outputs. "
"The HTML output is generated using the `Read the Docs <https://readthedocs."
"org/>`__ theme."
msgstr ""
"OTRS使用 `Sphinx <http://www.sphinx-doc.org/>`__ 生成输出。 HTML输出是使用 "
"`Read the Docs <https://readthedocs.org/>`__ 主题生成的。"

#: ../../content/documentation/documentation-infrastucture.rst:8
msgid ""
"All outputs are customized on the build server. If you want to setup a "
"developer environment in your local machine for testing and writing the "
"documentation, the outputs can be different."
msgstr ""
"所有输出都在构建服务器上自定义。 如果要在本地计算机中设置开发人员环境以进行测"
"试和编写文档，则输出可能会有所不同。"

#: ../../content/documentation/restructuredtext-primer.rst:2
msgid "reStructuredText Primer"
msgstr "reStructuredText 入门"

#: ../../content/documentation/restructuredtext-primer.rst:4
msgid ""
"The documentation format name is **reStructuredText** (one word, this is the "
"correct spelling). This is an easy to read documentation format using plain "
"text and small inline markers."
msgstr ""
"文档格式名称是 **reStructuredText** （一个单词，这是正确的拼写）。这是一种使"
"用纯文本和小型内联标记的易于阅读的文档格式。"

#: ../../content/documentation/restructuredtext-primer.rst:6
msgid ""
"This short tutorial will guide you through to create or update "
"documentations. To give a full featured tutorial about how to use the "
"*reStructuredText* format is beyond the scope of this document, and many "
"tutorials (e. g. `Sphinx reStructuredText primer <http://www.sphinx-doc.org/"
"en/master/usage/restructuredtext/basics.html>`__ and `reStructuredText user "
"documentation <http://docutils.sourceforge.net/rst.html>`__) and `on-line "
"editors <http://rst.ninjs.org>`__ are available on the internet."
msgstr ""
"这个简短的教程将指导您创建或更新文档。 提供有关如何使用 *reStructuredText* 格"
"式的全功能教程超出了本文档的范围，可在互联网上找到许多教程（例如 `Sphinx "
"reStructuredText primer <http://www.sphinx-doc.org/en/master/usage /"
"restructuredtext/basics.html>`__ 和 `reStructuredText用户文档 <http://"
"docutils.sourceforge.net/rst.html>`__ ）和 `在线编辑器 <http://rst.ninjs."
"org>`__ 。"

#: ../../content/documentation/restructuredtext-primer.rst:8
msgid ""
"The following examples shows the most commonly used documentation elements."
msgstr "以下示例显示了最常用的文档元素。"

#: ../../content/documentation/restructuredtext-primer.rst:12
msgid "Headings"
msgstr "标题"

#: ../../content/documentation/restructuredtext-primer.rst:14
msgid ""
"To use heading in the documentation, you have to underline the titles with "
"special characters. The underline must start from the first letter of the "
"title and end at the last letter of the title. The hierarchy of the special "
"characters are the following: =, -, ~, ^, ."
msgstr ""
"要在文档中使用标题，必须在标题下加上特殊字符。下划线必须从标题的第一个字母开"
"始，并以标题的最后一个字母结束。特殊字符的层次结构如下：=、-、~、^、. 。"

#: ../../content/documentation/restructuredtext-primer.rst:16
msgid "The following example shows the usage of the headings:"
msgstr "以下示例显示了标题的用法："

#: ../../content/documentation/restructuredtext-primer.rst:47
msgid "Paragraphs"
msgstr "段落"

#: ../../content/documentation/restructuredtext-primer.rst:49
msgid ""
"For writing paragraphs, you have to start sentences at the beginning of the "
"line. To create a new paragraph, just leave a blank line between the "
"paragraphs. Example:"
msgstr ""
"要写段落，您必须从行首开始句子。要创建新段落，只需在段落之间留一行空白。示"
"例："

#: ../../content/documentation/restructuredtext-primer.rst:63
msgid "Inline Markups"
msgstr "内联标记"

#: ../../content/documentation/restructuredtext-primer.rst:65
msgid "The standard inline markup is quite simple:"
msgstr "标准的内联标记非常简单："

#: ../../content/documentation/restructuredtext-primer.rst:67
msgid "One asterisk: \\*text\\* for *emphasis* (italics)."
msgstr "一个星号：\\*text\\*表示 *重点* （斜体）。"

#: ../../content/documentation/restructuredtext-primer.rst:68
msgid "Two asterisks: \\*\\*text\\*\\* for **strong emphasis** (boldface)."
msgstr "两个星号：\\*\\*text\\*\\* 表示 **强调** （粗体）。"

#: ../../content/documentation/restructuredtext-primer.rst:69
msgid "Grave accents: \\`\\`text\\`\\` for ``literal texts`` (code samples)."
msgstr "反引号：\\`\\`text\\`\\` 表示 ``常量文本`` （示例代码）。"

#: ../../content/documentation/restructuredtext-primer.rst:71
msgid ""
"If asterisks or grave accents appear in running text which could be confused "
"with inline markup delimiters, they have to be escaped with a backslash, "
"like \\\\*."
msgstr ""
"如果正在运行的文本中出现星号或反引号，可能与内联标记分隔符混淆，则必须使用反"
"斜杠进行转义，例如\\\\*。"

#: ../../content/documentation/restructuredtext-primer.rst:75
msgid "Lists"
msgstr "列表项目"

#: ../../content/documentation/restructuredtext-primer.rst:77
msgid ""
"To create unordered lists, start a line with asterisk (\\*) or dash (-). To "
"create ordered list, start a line with numbers or hash mark (#). If you need "
"nested lists, leave a blank line between the list items and use indentation "
"with 3 spaces. Example:"
msgstr ""
"要创建无序列表，请使用星号（\\*）或短划线（ - ）开始一行。 要创建有序列表，请"
"使用数字或井号（＃）开始一行。 如果需要嵌套列表，请在列表项之间留一个空行，并"
"使用3个空格的缩进。 例："

#: ../../content/documentation/restructuredtext-primer.rst:91
msgid "Nested list example:"
msgstr "嵌套列表的例子："

#: ../../content/documentation/restructuredtext-primer.rst:105
msgid "Literal Blocks"
msgstr "文字块"

#: ../../content/documentation/restructuredtext-primer.rst:107
msgid ""
"Literal blocks are texts that should be displayed as verbatim. To create "
"literal blocks, do the following:"
msgstr "文字块是应逐字显示的文本。 要创建文字块，请执行以下操作："

#: ../../content/documentation/restructuredtext-primer.rst:109
msgid "Type 2 colons (::) in a new line."
msgstr "在新行中输入2冒号（::)。"

#: ../../content/documentation/restructuredtext-primer.rst:110
msgid "Leave a blank line."
msgstr "留一个空行。"

#: ../../content/documentation/restructuredtext-primer.rst:111
msgid "Write the text with indentation of 3 spaces."
msgstr "用3个空格的缩进写出文本。"

#: ../../content/documentation/restructuredtext-primer.rst:113
msgid ""
"Use literal blocks for code snippets, terminal outputs, configuration files, "
"etc. Example:"
msgstr "对代码片段、终端输出、配置文件等使用文本块。示例："

#: ../../content/documentation/restructuredtext-primer.rst:123
msgid ""
"If the language of the code snippet is known, you can specify it for syntax "
"highlighting:"
msgstr "如果代码片段的语言是已知的，则可以将其指定为语法突出显示："

#: ../../content/documentation/restructuredtext-primer.rst:151
msgid "Tables"
msgstr "表格"

#: ../../content/documentation/restructuredtext-primer.rst:153
msgid "To create grid tables, you have to draw the table. Example:"
msgstr "要创建表格，必须绘制表格。示例："

#: ../../content/documentation/restructuredtext-primer.rst:168
msgid "Hyperlinks"
msgstr "超链接"

#: ../../content/documentation/restructuredtext-primer.rst:170
msgid ""
"Hyperlinks can be used inline or referenced. For inline use, encapsulate the "
"text of the link and the URL with grave accents and two trailing underscore "
"characters."
msgstr ""
"超链接可以用于内联或引用。 对于内联使用，请使用反引号和两个尾随下划线字符封装"
"链接的文本和URL。"

#: ../../content/documentation/restructuredtext-primer.rst:176
msgid "The link above will display as: `OTRS website <https://otrs.com>`__."
msgstr "上面的链接将显示为： `OTRS网站 <https://otrs.com>`__。"

#: ../../content/documentation/restructuredtext-primer.rst:178
msgid ""
"To create referenced links, you have to separate the text and the link. "
"Example:"
msgstr "要创建引用的链接，您必须分隔文本和链接。 例："

#: ../../content/documentation/restructuredtext-primer.rst:188
msgid "Images"
msgstr "图片"

#: ../../content/documentation/restructuredtext-primer.rst:190
msgid "To insert an image into the documentation:"
msgstr "要将图片插入文档："

#: ../../content/documentation/restructuredtext-primer.rst:192
msgid "Put the image in the ``images`` folder."
msgstr "将图片放在 ``images`` 文件夹中。"

#: ../../content/documentation/restructuredtext-primer.rst:193
msgid "Create a reference to the image with:"
msgstr "创建对图片的引用："

#: ../../content/documentation/restructuredtext-primer.rst:204
msgid "Colored Boxes"
msgstr "彩色的框"

#: ../../content/documentation/restructuredtext-primer.rst:206
msgid "These boxes have special meanings and will be highlighted as default."
msgstr "这些框具有特殊含义，默认情况下会突出显示。"

#: ../../content/documentation/restructuredtext-primer.rst:208
msgid "Warning box:"
msgstr "警告框："

#: ../../content/documentation/restructuredtext-primer.rst:218
msgid "This is a warning box."
msgstr "这是一个警告框。"

#: ../../content/documentation/restructuredtext-primer.rst:220
msgid "Note box:"
msgstr "备注框："

#: ../../content/documentation/restructuredtext-primer.rst:230
msgid "This is a note box."
msgstr "这是一个备注框。"

#: ../../content/documentation/restructuredtext-primer.rst:232
msgid "See also box:"
msgstr "参见框："

#: ../../content/documentation/restructuredtext-primer.rst:242
msgid "This is a see also box."
msgstr "这是一个参见框。"

#: ../../content/documentation/style-guide.rst:2
msgid "Style Guide"
msgstr "样式指南"

#: ../../content/documentation/style-guide.rst:4
msgid "This part of the documentation is only for visual style and wording."
msgstr "这部分文档仅用于视觉风格和措辞。"

#: ../../content/documentation/style-guide.rst:8
msgid "Writing Content"
msgstr "编写内容"

#: ../../content/documentation/style-guide.rst:10
msgid ""
"There is an internet slang **TL;DR**, which means *too long, didn't read* "
"(see more information on `Wikipedia <https://en.wikipedia.org/wiki/TL;"
"DR>`__). Many people don't like reading long texts, so please keep the "
"documentation as short as possible. Use step-by-step tutorials instead of "
"writing wall of text."
msgstr ""
"有一个互联网俚语 **TL; DR**，这意味着 *太长，不看* （更多信息请参阅 "
"`Wikipedia维基百科 <https://en.wikipedia.org/wiki/TL;DR>`__）。 很多人不喜欢"
"阅读长篇文章，所以请尽量缩短文档。 使用分步教程而不是编写文本墙。"

#: ../../content/documentation/style-guide.rst:12
msgid "For example this is a **wrong** example for writing content:"
msgstr "例如，这是一个 **错误的** 编写内容示例："

#: ../../content/documentation/style-guide.rst:23
msgid "The same content in **suggested** *human understandable* format:"
msgstr "同样的内容采用 **建议的**、 *人类可理解的* 格式："

#: ../../content/documentation/style-guide.rst:35
msgid ""
"The latter is easier to translate, because 6 short sentences will be "
"included in the language file. If a content is changed in one of the "
"sentences, only the changed sentence need to be reviewed and translated "
"again. The first wrong example puts only one huge string to the language "
"file, and if some changes will be made in the source string, the translator "
"needs to review and re-translate the whole string."
msgstr ""
"后者更容易翻译，因为语言文件中将包含6个短句。 如果在其中一个句子中更改了内"
"容，则只需要再次检查和翻译已更改的句子。 第一个错误示例只将一个大字符串放入语"
"言文件中，如果在源字符串中进行某些更改，则翻译程序需要检查并重新翻译整个字符"
"串。"

#: ../../content/documentation/style-guide.rst:39
msgid "Screenshots"
msgstr "屏幕截图"

#: ../../content/documentation/style-guide.rst:41
msgid ""
"Don't use the native resolution of your machine. Usually it is full HD or "
"bigger, so creating a screenshot with this resolution will became unreadable "
"in some output, because all the images have to be shrink to the width of A4 "
"paper in case of PDF. OTRS uses responsive design, so 1025 pixels is the "
"minimum, that OTRS assumes it is a large display. Please use this as width "
"of your screenshots."
msgstr ""
"不要使用电脑的原始分辨率。 通常它是全高清或更高，因此在某些输出中创建具有此分"
"辨率的屏幕截图将变得不可读，因为在PDF的情况下所有图像必须缩小到A4纸的宽度。 "
"OTRS使用响应式设计，因此1025像素是最小的，OTRS假设它是一个大的显示器。 请将此"
"值用作屏幕截图的宽度。"

#: ../../content/documentation/style-guide.rst:45
msgid ""
"The resolution can be set in all web browser with a feature called *mobile "
"mode* or *responsive design*. Check your browser user manual for the usage "
"of the feature and set the width of the screen to 1025 pixels."
msgstr ""
"可以在所有Web浏览器中使用称为 *移动模式* 或 *响应式设计* 的功能设置分辨率。 "
"查看浏览器用户手册以了解该功能的用法，并将屏幕宽度设置为1025像素。"

#: ../../content/documentation/style-guide.rst:47
msgid ""
"This is an example for a **wrong** screenshot, as it has resolution of full "
"HD. Due to the automatic shrinking the texts on the screenshot are hard to "
"read:"
msgstr ""
"这是一个 **错误的** 截图示例，因为它具有全高清分辨率。 由于自动收缩，屏幕截图"
"上的文字难以阅读："

#: ../../content/documentation/style-guide.rst:52
msgid "Agent Dashboard (1920 pixels width)"
msgstr "服务人员仪表板（1920像素宽）"

#: ../../content/documentation/style-guide.rst:54
msgid ""
"The same screenshot with **suggested** resolution. The texts are much easier "
"to read:"
msgstr "与 **建议的** 分辨率相同的屏幕截图。 文本更容易阅读："

#: ../../content/documentation/style-guide.rst:59
msgid "Agent Dashboard (1025 pixels width)"
msgstr "服务人员仪表板（1025像素宽）"

#: ../../content/documentation/style-guide.rst:61
msgid ""
"It is also wrong, if the screenshot has good resolution in pixels, but with "
"high DPI. For example this screenshot is **wrong**, because the texts on it "
"is much bigger than the other texts in the documentation:"
msgstr ""
"如果屏幕截图具有良好的像素分辨率，但具有高DPI，则也是错误的。 例如，这个截图"
"是 **错误的** ，因为它上面的文本比文档中的其它文本大得多："

#: ../../content/documentation/style-guide.rst:66
msgid "Video Invitation Dialog (756 pixels width but with high DPI)"
msgstr "视频邀请对话框（宽度为756像素但具有高DPI）"

#: ../../content/documentation/style-guide.rst:70
msgid "Create Screenshots with Firefox"
msgstr "使用Firefox创建屏幕截图"

#: ../../content/documentation/style-guide.rst:72
msgid ""
"If only a part of the screenshot is required, the screenshot needs to be "
"cropped. The administrator interface of OTRS consist of a left sidebar and a "
"main content column. To create screenshots with Firefox:"
msgstr ""
"如果只需要部分屏幕截图，则需要裁剪屏幕截图。 OTRS的管理员界面由左侧边栏和主内"
"容列组成。 要使用Firefox创建屏幕截图："

#: ../../content/documentation/style-guide.rst:74
msgid "Right click on an element in the browser and select *Inspect element*."
msgstr "右键单击浏览器中的元素，然后选择 *查看元素*。"

#: ../../content/documentation/style-guide.rst:75
msgid "Select the element in the DOM, if it was not selected."
msgstr "如果未选中，则选择DOM中的元素。"

#: ../../content/documentation/style-guide.rst:76
msgid "Right click on the node and select *Screenshot Node*."
msgstr "右键单击节点并选择 *节点截图*。"

#: ../../content/documentation/style-guide.rst:81
msgid "Example screenshot for the main content"
msgstr "主要内容的示例屏幕截图"

#: ../../content/documentation/style-guide.rst:86
msgid "Example screenshot for the left sidebar"
msgstr "左侧边栏的示例屏幕截图"

#: ../../content/documentation/style-guide.rst:91
msgid "Example screenshot for the main content column"
msgstr "主内容列的示例屏幕截图"

#: ../../content/documentation/style-guide.rst:95
msgid "Capitalization in Documentation"
msgstr "文档中的大写"

#: ../../content/documentation/style-guide.rst:97
msgid ""
"For titles always have to use sentence case capitalization, which means, "
"that in titles always capitalize:"
msgstr "对于标题总是必须使用句子大小写，这意味着，标题总是大写："

#: ../../content/documentation/style-guide.rst:99
msgid "Nouns (man, bus, book)."
msgstr "名词（man, bus, book）。"

#: ../../content/documentation/style-guide.rst:100
msgid "Adjectives (angry, lovely, small)."
msgstr "形容词（angry, lovely, small）。"

#: ../../content/documentation/style-guide.rst:101
msgid "Verbs (run, eat, sleep)."
msgstr "动词（run, eat, sleep）。"

#: ../../content/documentation/style-guide.rst:102
msgid "Adverbs (slowly, quickly, quietly)."
msgstr "副词（slowly, quickly, quietly）。"

#: ../../content/documentation/style-guide.rst:103
msgid "Pronouns (he, she, it)."
msgstr "代词（he, she, it）。"

#: ../../content/documentation/style-guide.rst:104
msgid "Subordinating conjunctions (as, because, that)."
msgstr "从属连词（as, because, that）。"

#: ../../content/documentation/style-guide.rst:106
msgid "In titles do not capitalize:"
msgstr "在标题中不大写："

#: ../../content/documentation/style-guide.rst:108
msgid "Articles: a, an, the."
msgstr "冠词： a, an, the。"

#: ../../content/documentation/style-guide.rst:109
msgid "Coordinating conjunctions: and, but, or, for, nor, etc."
msgstr "并列连词： and、 but、 or、 for、 nor 等。"

#: ../../content/documentation/style-guide.rst:110
msgid "Prepositions (fewer than five letters): on, at, to, from, by, etc."
msgstr "介词（少于五个字母）：on、 at、 to、from、 by 等。"

#: ../../content/documentation/style-guide.rst:112
msgid ""
"In normal sentences don't capitalize any words, only names and reference to "
"titles have to be capitalized. This is a **wrong** example:"
msgstr ""
"在普通句子中，不要将任何单词大写，只有名称和标题的引用必须大写。 这是 **错误"
"的** 示例："

#: ../../content/documentation/style-guide.rst:118
msgid ""
"The **suggested** sentence with proper capitalization. Besides, *Ticket "
"Zoom* is the name of the screen, so it should be emphasized:"
msgstr ""
"**建议的** 句子有适当的大写字母。 此外，*Ticket Zoom* 是屏幕的名称，因此需要"
"强调："

#: ../../content/documentation/style-guide.rst:126
msgid "Buttons and Screen Names"
msgstr "按钮和屏幕名称"

#: ../../content/documentation/style-guide.rst:128
msgid ""
"In the content sentences all buttons and screens should be emphasized and "
"should be written with capital letters or in sentence case. Don't use "
"apostrophes or quotation marks for emphasizing."
msgstr ""
"在内容句子中，应强调所有按钮和屏幕，并应使用大写字母或句子大小写。 不要使用撇"
"号或引号来强调。"

#: ../../content/documentation/style-guide.rst:130
msgid ""
"This sentence is **wrong**, because apostrophes are used for emphasizing:"
msgstr "这句话是 **错误的** ，因为用撇号来强调："

#: ../../content/documentation/style-guide.rst:136
msgid "The **suggested** way is to use asterisks for emphasizing:"
msgstr "**建议的** 方法是用星号来强调："

#: ../../content/documentation/style-guide.rst:144
msgid "Wording"
msgstr "措词"

#: ../../content/documentation/style-guide.rst:146
msgid ""
"Don't use variable names in sentences. This sentence is **wrong**, because a "
"variable name is meaningless for some people:"
msgstr ""
"不要在句子中使用变量名。 这句话是 **错误的** ，因为变量名对某些人来说毫无意"
"义："

#: ../../content/documentation/style-guide.rst:152
msgid "The same sentence without variable name, this is **suggested**:"
msgstr "没有变量名的同一个句子，这是 **建议的** ："

#: ../../content/documentation/style-guide.rst:160
msgid "Variable Names"
msgstr "变量名"

#: ../../content/documentation/style-guide.rst:162
msgid ""
"Variable names should always marked as ``literal`` content. This is useful "
"for translators, as they can exactly know, that the string mustn't be "
"translated. If a string is not marked as literal content, it usually should "
"be translated. For example:"
msgstr ""
"变量名应始终标记为 ``literal（原封不动显示文字）`` 内容。 这对翻译人员非常有"
"用，因为他们可以确切地知道，字符串不得翻译。 如果字符串未标记为文字内容，则通"
"常应将其翻译。 例如："

#: ../../content/documentation/translate-documentation.rst:2
msgid "Translating the Documentation"
msgstr "翻译文档"

#: ../../content/documentation/translate-documentation.rst:8
msgid "Here are some examples."
msgstr "这里有些例子。"

#: ../../content/documentation/translate-documentation.rst:23
msgid "Emphases"
msgstr "重点"

#: ../../content/documentation/translate-documentation.rst:11
msgid ""
"Emphasized texts are between two asterisks. The text should be translated. "
"This is usually used for screen names, titles, buttons and labels. Please "
"check the user interface translations to find and use the same wording in "
"the documentation."
msgstr ""
"强调文本在两个星号之间。 文本应该翻译。 这通常用于屏幕名称、标题、按钮和标"
"签。 请检查用户界面翻译以查找和使用文档中的相同措辞。"

#: ../../content/documentation/translate-documentation.rst:13
#: ../../content/documentation/translate-documentation.rst:28
#: ../../content/documentation/translate-documentation.rst:43
#: ../../content/documentation/translate-documentation.rst:58
#: ../../content/documentation/translate-documentation.rst:73
msgid "Example original sentence:"
msgstr "示例原句："

#: ../../content/documentation/translate-documentation.rst:19
#: ../../content/documentation/translate-documentation.rst:34
#: ../../content/documentation/translate-documentation.rst:49
#: ../../content/documentation/translate-documentation.rst:64
#: ../../content/documentation/translate-documentation.rst:79
msgid "Example translation into Hungarian:"
msgstr "匈牙利语翻译示例："

#: ../../content/documentation/translate-documentation.rst:38
msgid "Strong"
msgstr "强调"

#: ../../content/documentation/translate-documentation.rst:26
msgid ""
"Strong texts are between two double asterisks. The text should be "
"translated. This is usually used for important information."
msgstr "强文本位于两个双星号之间。应翻译该文本。这通常用于重要信息。"

#: ../../content/documentation/translate-documentation.rst:53
msgid "Literal texts"
msgstr "常量文本"

#: ../../content/documentation/translate-documentation.rst:41
msgid ""
"Literal texts are between two double back-tick characters. This is usually "
"used for variable names, configuration names and file paths, and **must "
"not** be translated, otherwise it will break the structure."
msgstr ""
"常量文本介于两个双反引号之间。 这通常用于变量名、配置名和文件路径， **不能** "
"翻译，否则会破坏结构。"

#: ../../content/documentation/translate-documentation.rst:68
msgid "Internal links"
msgstr "内部链接"

#: ../../content/documentation/translate-documentation.rst:56
msgid ""
"Internal links point to other pages or headings of the pages. ``:doc:`page-"
"name``` is used for referring to a page and ``:ref:`Heading Title``` is used "
"for referring to a heading. There is a custom tag ``:sysconfig:`System "
"Configuration Name``` for referring to a system configuration. The texts "
"*page-name*, *Heading Title* and *System Configuration Name* **must not** be "
"translated, otherwise it will break the structure."
msgstr ""
"内部链接指向页面的其它页面或标题。 ``:doc:`page-name``` 用于引用页面， ``:"
"ref:`Heading Title``` 用于引用标题。 有一个自定义标签 ``:sysconfig:`System "
"Configuration Name``` 用于引用系统配置。 **不得** 翻译 *页面名称*、 *标题* "
"和 *系统配置名称* 文本，否则将破坏结构。"

#: ../../content/documentation/translate-documentation.rst:82
msgid "External links"
msgstr "外部链接"

#: ../../content/documentation/translate-documentation.rst:71
msgid ""
"External links consist of a visible text and an URL in form *\\`visible text "
"<https://example.com>\\`__*. The *visible text* should be translated."
msgstr ""
"外部链接由可见文本和表单中的URL按 *\\`visible text <https://example.com>"
"\\`__* 格式组成。 应翻译 *visible text*。"

#: ../../content/get-started.rst:2
msgid "Getting Started"
msgstr "入门"

#: ../../content/get-started.rst:4
msgid ""
"OTRS is a multi-platform web application framework which was originally "
"developed for a trouble ticket system. It supports different web servers and "
"databases."
msgstr ""
"OTRS是一个多平台的Web应用程序框架，最初是为故障单系统开发的。 它支持不同的Web"
"服务器和数据库。"

#: ../../content/get-started.rst:6
msgid ""
"This manual shows how to develop your own OTRS modules and applications "
"based on the OTRS styleguides."
msgstr "本手册介绍了如何基于OTRS样式指南开发自己的OTRS模块和应用程序。"

#: ../../content/get-started/architecture.rst:2
msgid "Architecture Overview"
msgstr "架构概述"

#: ../../content/get-started/architecture.rst:4
msgid ""
"The OTRS framework is modular. The following picture shows the basic layer "
"architecture of OTRS."
msgstr "OTRS框架是模块化的。 下图显示了OTRS的基本层架构。"

#: ../../content/get-started/architecture.rst:9
msgid "OTRS Architecture"
msgstr "OTRS架构"

#: ../../content/get-started/architecture.rst:11
msgid ""
"The OTRS Generic Interface continues OTRS modularity. The next picture shows "
"the basic layer architecture of the Generic Interface."
msgstr "OTRS通用接口继续OTRS模块化。 下图显示了通用接口的基本层架构。"

#: ../../content/get-started/architecture.rst:16
msgid "Generic Interface Architecture"
msgstr "通用接口架构"

#: ../../content/get-started/architecture.rst:20
msgid "Directories"
msgstr "目录"

#: ../../content/get-started/architecture.rst:23
msgid "Directory"
msgstr "目录"

#: ../../content/get-started/architecture.rst:23
msgid "Description"
msgstr "描述"

#: ../../content/get-started/architecture.rst:25
msgid "bin/"
msgstr "bin/"

#: ../../content/get-started/architecture.rst:25
msgid "command line tools"
msgstr "命令行工具"

#: ../../content/get-started/architecture.rst:27
msgid "bin/cgi-bin/"
msgstr "bin/cgi-bin/"

#: ../../content/get-started/architecture.rst:27
msgid "web handle"
msgstr "web handle"

#: ../../content/get-started/architecture.rst:29
msgid "bin/fcgi-bin/"
msgstr "bin/fcgi-bin/"

#: ../../content/get-started/architecture.rst:29
msgid "fast CGI web handle"
msgstr "快速的CGI Web句柄"

#: ../../content/get-started/architecture.rst:31
msgid "Kernel"
msgstr "Kernel"

#: ../../content/get-started/architecture.rst:31
msgid "application code base"
msgstr "应用程序代码库"

#: ../../content/get-started/architecture.rst:33
msgid "Kernel/Config/"
msgstr "Kernel/Config/"

#: ../../content/get-started/architecture.rst:33
#: ../../content/get-started/architecture.rst:35
msgid "configuration files"
msgstr "配置文件"

#: ../../content/get-started/architecture.rst:35
msgid "Kernel/Config/Files"
msgstr "Kernel/Config/Files"

#: ../../content/get-started/architecture.rst:37
msgid "Kernel/GenericInterface/"
msgstr "Kernel/GenericInterface/"

#: ../../content/get-started/architecture.rst:37
msgid "the Generic Interface API"
msgstr "通用接口API"

#: ../../content/get-started/architecture.rst:39
msgid "Kernel/GenericInterface/Invoker/"
msgstr "Kernel/GenericInterface/Invoker/"

#: ../../content/get-started/architecture.rst:39
msgid "invoker modules for Generic Interface"
msgstr "通用接口的调用程序模块"

#: ../../content/get-started/architecture.rst:42
msgid "Kernel/GenericInterface/Mapping/"
msgstr "Kernel/GenericInterface/Mapping/"

#: ../../content/get-started/architecture.rst:42
msgid "mapping modules for Generic Interface, e.g. Simple"
msgstr "用于通用接口的映射模块，例如Simple"

#: ../../content/get-started/architecture.rst:45
msgid "Kernel/GenericInterface/Operation /"
msgstr "Kernel/GenericInterface/Operation /"

#: ../../content/get-started/architecture.rst:45
msgid "operation modules for Generic Interface"
msgstr "通用接口的操作模块"

#: ../../content/get-started/architecture.rst:48
msgid "Kernel/GenericInterface/Transport /"
msgstr "Kernel/GenericInterface/Transport /"

#: ../../content/get-started/architecture.rst:48
msgid "transport modules for Generic Interface, e.g. \"HTTP SOAP\""
msgstr "通用接口的传输模块，例如 \"HTTP SOAP\""

#: ../../content/get-started/architecture.rst:51
msgid "Kernel/Language"
msgstr "Kernel/Language"

#: ../../content/get-started/architecture.rst:51
msgid "language translation files"
msgstr "语言翻译文件"

#: ../../content/get-started/architecture.rst:53
msgid "Kernel/Scheduler/"
msgstr "Kernel/Scheduler/"

#: ../../content/get-started/architecture.rst:53
msgid "Scheduler files"
msgstr "调度程序文件"

#: ../../content/get-started/architecture.rst:55
msgid "Kernel/Scheduler/TaskHandler"
msgstr "Kernel/Scheduler/TaskHandler"

#: ../../content/get-started/architecture.rst:55
msgid "handler modules for scheduler tasks, e.g. GenericInterface"
msgstr "调度程序任务的处理程序模块，例如GenericInterface"

#: ../../content/get-started/architecture.rst:58
msgid "Kernel/System/"
msgstr "Kernel/System/"

#: ../../content/get-started/architecture.rst:58
msgid "core modules, e.g. Log, Ticket"
msgstr "核心模块，例如日志、工单"

#: ../../content/get-started/architecture.rst:60
msgid "Kernel/Modules/"
msgstr "Kernel/Modules/"

#: ../../content/get-started/architecture.rst:60
msgid "front end modules, e.g. QueueView"
msgstr "前端模块，例如QueueView"

#: ../../content/get-started/architecture.rst:63
msgid "Kernel/Output/HTML/"
msgstr "Kernel/Output/HTML/"

#: ../../content/get-started/architecture.rst:63
msgid "html templates"
msgstr "HTML模板"

#: ../../content/get-started/architecture.rst:65
msgid "var/"
msgstr "var/"

#: ../../content/get-started/architecture.rst:65
msgid "variable data"
msgstr "可变的数据"

#: ../../content/get-started/architecture.rst:67
msgid "var/log"
msgstr "var/log"

#: ../../content/get-started/architecture.rst:67
msgid "logfiles"
msgstr "日志文件"

#: ../../content/get-started/architecture.rst:69
msgid "var/cron/"
msgstr "var/cron/"

#: ../../content/get-started/architecture.rst:69
msgid "cron files"
msgstr "cron 文件"

#: ../../content/get-started/architecture.rst:71
msgid "var/httpd/htdocs/"
msgstr "var/httpd/htdocs/"

#: ../../content/get-started/architecture.rst:71
msgid "htdocs directory with index.html"
msgstr "带有index.html的htdocs目录"

#: ../../content/get-started/architecture.rst:73
msgid "var/httpd/htdocs/skins/Agent/"
msgstr "var/httpd/htdocs/skins/Agent/"

#: ../../content/get-started/architecture.rst:73
msgid "available skins for the Agent interface"
msgstr "服务人员界面的可用皮肤"

#: ../../content/get-started/architecture.rst:76
msgid "var/httpd/htdocs/skins/Customer/"
msgstr "var/httpd/htdocs/skins/Customer/"

#: ../../content/get-started/architecture.rst:76
msgid "available skins for the Customer interface"
msgstr "客户界面的可用皮肤"

#: ../../content/get-started/architecture.rst:79
msgid "var/httpd/htdocs/js/"
msgstr "var/httpd/htdocs/js/"

#: ../../content/get-started/architecture.rst:79
msgid "JavaScript files"
msgstr "JavaScript 文件"

#: ../../content/get-started/architecture.rst:81
msgid "scripts/"
msgstr "scripts/"

#: ../../content/get-started/architecture.rst:81
msgid "misc files"
msgstr "杂项文件"

#: ../../content/get-started/architecture.rst:83
msgid "scripts/test/"
msgstr "scripts/test/"

#: ../../content/get-started/architecture.rst:83
msgid "unit test files"
msgstr "单元测试文件"

#: ../../content/get-started/architecture.rst:85
msgid "scripts/test/sample/"
msgstr "scripts/test/sample/"

#: ../../content/get-started/architecture.rst:85
msgid "unit test sample data files"
msgstr "单元测试样本数据文件"

#: ../../content/get-started/architecture.rst:90
msgid "Files"
msgstr "文件"

#: ../../content/get-started/architecture.rst:92
msgid ".pl = Perl"
msgstr ".pl = Perl"

#: ../../content/get-started/architecture.rst:93
msgid ".pm = Perl Module"
msgstr ".pm = Perl 模块"

#: ../../content/get-started/architecture.rst:94
msgid ".tt = Template::Toolkit template files"
msgstr ".tt = Template::Toolkit模板文件"

#: ../../content/get-started/architecture.rst:95
msgid ".dist = Default templates of files"
msgstr ".dist =文件的默认模板"

#: ../../content/get-started/architecture.rst:96
msgid ".yaml or .yml = YAML files, used for Web Service configuration"
msgstr ".yaml or .yml = YAML文件，用于Web服务配置"

#: ../../content/get-started/architecture.rst:100
msgid "Core Modules"
msgstr "核心模块"

#: ../../content/get-started/architecture.rst:102
msgid ""
"Core modules are located under ``$OTRS_HOME/Kernel/System/*``. This layer is "
"for the logical work. Core modules are used to handle system routines like "
"*lock ticket* and *create ticket*. A few main core modules are:"
msgstr ""
"核心模块位于 ``$OTRS_HOME/Kernel/System/*`` 下。 该层用于逻辑工作。 核心模块"
"用于处理系统例程，如 *锁定工单* 和 *创建工单*。 一些主要的核心模块是："

#: ../../content/get-started/architecture.rst:105
msgid "``Kernel::System::Config`` to access configuration options."
msgstr "``Kernel::System::Config`` 用于访问配置选项。"

#: ../../content/get-started/architecture.rst:106
msgid "``Kernel::System::Log`` to log into OTRS log back end."
msgstr "``Kernel::System::Log`` 用于记录到OTRS日志后端。"

#: ../../content/get-started/architecture.rst:107
msgid "``Kernel::System::DB`` to access the database back end."
msgstr "``Kernel::System::DB`` 用于访问数据库后端。"

#: ../../content/get-started/architecture.rst:108
msgid "``Kernel::System::Auth`` to check user authentication."
msgstr "``Kernel::System::Auth`` 用于检查用户认证。"

#: ../../content/get-started/architecture.rst:109
msgid "``Kernel::System::User`` to manage users."
msgstr "``Kernel::System::User`` 用于管理用户。"

#: ../../content/get-started/architecture.rst:110
msgid "``Kernel::System::Group`` to manage groups."
msgstr "``Kernel::System::Group`` 用于管理组。"

#: ../../content/get-started/architecture.rst:111
msgid "``Kernel::System::Email`` for sending emails."
msgstr "``Kernel::System::Email`` 用于发送电子邮件。"

#: ../../content/get-started/architecture.rst:113
#: ../../content/get-started/architecture.rst:141
#: ../../content/get-started/architecture.rst:163
#: ../../content/get-started/architecture.rst:173
#: ../../content/get-started/architecture.rst:181
#: ../../content/get-started/architecture.rst:191
#: ../../content/get-started/architecture.rst:201
#: ../../content/get-started/architecture.rst:209
#: ../../content/how-it-works/templates.rst:357
msgid ""
"For more information see the `Documentation Portal <https://doc.otrs.com/doc/"
">`__."
msgstr "有关更多信息，请访问 `文档门户网站 <https://doc.otrs.com/doc/>`__。"

#: ../../content/get-started/architecture.rst:117
msgid "Front End Handle"
msgstr "前端句柄"

#: ../../content/get-started/architecture.rst:119
msgid ""
"The interface between the browser, web server and the front end modules. A "
"front end module can be used via the HTTP link."
msgstr "浏览器、Web服务器和前端模块之间的接口。 可以通过HTTP链接使用前端模块。"

#: ../../content/get-started/architecture.rst:127
#: ../../content/how-to-extend-otrs/otrs-module-layers.rst:33
msgid "Front End Modules"
msgstr "前端模块"

#: ../../content/get-started/architecture.rst:129
msgid ""
"Front end modules are located under ``$OTRS_HOME/Kernel/Modules/*.pm``. "
"There are two public functions in there - ``new()`` and ``run()`` - which "
"are accessed from the front end handle (e.g. ``index.pl``)."
msgstr ""
"前端模块位于 ``$OTRS_HOME/Kernel/Modules/*.pm`` 下。 那里有两个公共函数 - "
"``new()`` 和 ``run()``- 可以从前端句柄访问（例如 ``index.pl``）。"

#: ../../content/get-started/architecture.rst:131
msgid ""
"``new()`` is used to create a front end module object. The front end handle "
"provides the used front end module with the basic framework objects. These "
"are, for example:"
msgstr ""
"``new()`` 用于创建前端模块对象。 前端句柄为使用过的前端模块提供基本框架对"
"象。 这些对象是以下示例："

#: ../../content/get-started/architecture.rst:133
msgid "``ParamObject`` to get web form params."
msgstr "``ParamObject`` 用于获取WEB表单参数。"

#: ../../content/get-started/architecture.rst:134
msgid "``DBObject`` to use existing database connections."
msgstr "``DBObject`` 用于使用现有的数据库连接。"

#: ../../content/get-started/architecture.rst:135
msgid "``LayoutObject`` to use templates and other HTML layout functions."
msgstr "``LayoutObject`` 用于使用模板和其它的HTML布局函数。"

#: ../../content/get-started/architecture.rst:136
msgid "``ConfigObject`` to access config settings."
msgstr "``ConfigObject`` 用于访问配置设置。"

#: ../../content/get-started/architecture.rst:137
msgid "``LogObject`` to use the framework log system."
msgstr "``LogObject`` 用于使用框架日志系统。"

#: ../../content/get-started/architecture.rst:138
msgid "``UserObject`` to get the user functions from the current user."
msgstr "``UserObject`` 用于获取当前用户的用户函数。"

#: ../../content/get-started/architecture.rst:139
msgid "``GroupObject`` to get the group functions."
msgstr "``GroupObject`` 用于获取组函数。"

#: ../../content/get-started/architecture.rst:145
msgid "CMD Front End"
msgstr "CMD前端"

#: ../../content/get-started/architecture.rst:147
msgid ""
"The CMD (command line) front end is like the web front end handle and the "
"web front end module in one (just without the ``LayoutObject``) and uses the "
"core modules for some actions in the system."
msgstr ""
"CMD（命令行）前端就像Web前端句柄和Web前端模块一样（只是没有 "
"``LayoutObject``），使用核心模块进行系统中的某些操作。"

#: ../../content/get-started/architecture.rst:151
#: ../../content/how-to-extend-otrs/otrs-module-layers.rst:41
msgid "Generic Interface Modules"
msgstr "通用接口模块"

#: ../../content/get-started/architecture.rst:153
msgid ""
"Generic interface modules are located under ``$OTRS_HOME/Kernel/"
"GenericInterface/*``. Generic interface modules are used to handle each part "
"of a web service execution on the system. The main modules for the generic "
"interface are:"
msgstr ""
"通用接口模块位于 ``$OTRS_HOME/Kernel/GenericInterface/*`` 下。 通用接口模块用"
"于处理系统上Web服务执行的每个部分。 通用接口的主要模块是："

#: ../../content/get-started/architecture.rst:155
msgid ""
"``Kernel::GenericInterface::Transport`` to interact with remote systems."
msgstr "``Kernel::GenericInterface::Transport`` 用于与远程系统交互。"

#: ../../content/get-started/architecture.rst:156
msgid ""
"``Kernel::GenericInterface::Mapping`` to transform data into a required "
"format."
msgstr "``Kernel::GenericInterface::Mapping`` 用于将数据转换为所需格式。"

#: ../../content/get-started/architecture.rst:157
msgid ""
"``Kernel::GenericInterface::Requester`` to use OTRS as a client for the web "
"service."
msgstr ""
"``Kernel::GenericInterface::Requester`` 用于将OTRS作为Web服务的客户端。"

#: ../../content/get-started/architecture.rst:158
msgid ""
"``Kernel::GenericInterface::Provider`` to use OTRS as a server for web "
"service."
msgstr ""
"``Kernel::GenericInterface::Provider`` 用于将OTRS作为Web服务的服务器端。"

#: ../../content/get-started/architecture.rst:159
msgid "``Kernel::GenericInterface::Operation`` to execute provider actions."
msgstr "``Kernel::GenericInterface::Operation`` 用于执行提供者操作。"

#: ../../content/get-started/architecture.rst:160
msgid "``Kernel::GenericInterface::Invoker`` to execute requester actions."
msgstr "``Kernel::GenericInterface::Invoker`` 用于执行请求者操作。"

#: ../../content/get-started/architecture.rst:161
msgid ""
"``Kernel::GenericInterface::Debugger`` to track web service communication, "
"using log entries."
msgstr "``Kernel::GenericInterface::Debugger`` 使用日志条目跟踪Web服务通信。"

#: ../../content/get-started/architecture.rst:167
msgid "Generic Interface Invoker Modules"
msgstr "通用接口调用程序模块"

#: ../../content/get-started/architecture.rst:169
msgid ""
"Generic interface invoker modules are located under ``$OTRS_HOME/Kernel/"
"GenericInterface/Invoker/*``. Each invoker is contained in a folder called "
"``Controller``. This approach helps to define a name space not only for "
"internal classes and methods but for filenames too. For example: ``"
"$OTRS_HOME/Kernel/GenericInterface/Invoker/Test/`` is the controller for all "
"test type invokers."
msgstr ""
"通用接口调用程序模块位于 ``$OTRS_HOME/Kernel/GenericInterface/Invoker/*`` "
"下。每个调用程序都包含在一个名为 ``Controller`` 的文件夹中。此方法不仅有助于"
"为内部类和方法定义名称空间，而且还有助于为文件名定义名称空间。例如：``"
"$OTRS_HOME/Kernel/GenericInterface/Invoker/Test/`` 是所有测试类型调用程序的控"
"制器。"

#: ../../content/get-started/architecture.rst:171
msgid ""
"Generic interface invoker modules are used as a back end to create requests "
"for remote systems to execute actions."
msgstr "通用接口调用程序模块用作后端，以创建远程系统执行操作的请求。"

#: ../../content/get-started/architecture.rst:177
msgid "Generic Interface Mapping Modules"
msgstr "通用接口映射模块"

#: ../../content/get-started/architecture.rst:179
msgid ""
"Generic interface mapping modules are located under ``$OTRS_HOME/Kernel/"
"GenericInterface/Mapping/*``. These modules are used to transform data (keys "
"and values) from one format to another."
msgstr ""
"通用接口映射模块位于 ``$OTRS_HOME/Kernel/GenericInterface/Mapping/*`` 下。 这"
"些模块用于将数据（键和值）从一种格式转换为另一种格式。"

#: ../../content/get-started/architecture.rst:185
msgid "Generic Interface Operation Modules"
msgstr "通用接口操作模块"

#: ../../content/get-started/architecture.rst:187
msgid ""
"Generic interface operation modules are located under ``$OTRS_HOME/Kernel/"
"GenericInterface/Operation/*``. Each operation is contained in a folder "
"called ``Controller``. This approach help to define a name space not only "
"for internal classes and methods but for filenames too. For example: ``"
"$OTRS_HOME/Kernel/GenericInterface/Operation/Ticket/`` is the controller for "
"all ticket type operations."
msgstr ""
"通用接口操作模块位于 ``$OTRS_HOME/Kernel/GenericInterface/Operation/*`` 下。 "
"每个操作都包含在一个名为 ``Controller`` 的文件夹中。 此方法不仅可以为内部类和"
"方法定义名称空间，还可以为文件名定义名称空间。 例如： ``$OTRS_HOME/Kernel/"
"GenericInterface/Operation/Ticket/`` 是所有工单类型操作的控制器。"

#: ../../content/get-started/architecture.rst:189
msgid ""
"Generic interface operation modules are used as a back end to perform "
"actions requested by a remote system."
msgstr "通用接口操作模块用作后端以执行远程系统请求的动作。"

#: ../../content/get-started/architecture.rst:195
msgid "Generic Interface Transport Modules"
msgstr "通用接口传输模块"

#: ../../content/get-started/architecture.rst:197
msgid ""
"Generic interface network transport modules are located under ``$OTRS_HOME/"
"Kernel/GenericInterface/Transport/*``. Each transport module should be "
"placed in a directory named as the network protocol used. For example: The "
"HTTP SOAP transport module, located in ``$OTRS_HOME/Kernel/GenericInterface/"
"Transport/HTTP/SOAP.pm``."
msgstr ""
"通用接口网络传输模块位于 ``$OTRS_HOME/Kernel/GenericInterface/Transport/*`` "
"下。 应将每个传输模块放在名为所用网络协议的目录中。 例如：HTTP SOAP传输模块，"
"位于 ``$OTRS_HOME/Kernel/GenericInterface/Transport/HTTP/SOAP.pm`` 中。"

#: ../../content/get-started/architecture.rst:199
msgid ""
"Generic interface transport modules are used send data to, and receive data "
"from a remote system."
msgstr "通用接口传输模块用于向远程系统发送数据和从远程系统接收数据。"

#: ../../content/get-started/architecture.rst:205
msgid "Scheduler Task Handler Modules"
msgstr "调度程序任务处理程序模块"

#: ../../content/get-started/architecture.rst:207
msgid ""
"Scheduler task handler modules are located under ``$OTRS_HOME/Kernel/"
"Scheduler/TaskHandler/*``. These modules are used to perform asynchronous "
"tasks. For example, the ``GenericInterface`` task handler perform generic "
"interface requests to remote systems outside the Apache process. This helps "
"the system to be more responsive, preventing possible performance issues."
msgstr ""
"调度程序任务处理程序模块位于 ``$OTRS_HOME/Kernel/Scheduler/TaskHandler/*`` "
"下。 这些模块用于执行异步任务。 例如，``GenericInterface`` 任务处理程序对"
"Apache进程外的远程系统执行通用接口请求。 这有助于系统提高响应速度，防止出现可"
"能的性能问题。"

#: ../../content/get-started/architecture.rst:213
msgid "Database"
msgstr "数据库"

#: ../../content/get-started/architecture.rst:215
msgid "The database interface supports different databases."
msgstr "数据库接口支持不同的数据库。"

#: ../../content/get-started/architecture.rst:217
msgid ""
"For the OTRS data model please refer to the files in your ``/doc`` "
"directory. Alternatively you can look at the data model on `GitHub <https://"
"github.com/OTRS/otrs/blob/rel-6_0/development/diagrams/Database/"
"OTRSDatabaseDiagram.png>`__."
msgstr ""
"对于OTRS数据模型，请参阅 ``/doc`` 目录中的文件。 或者，您可以在 `GitHub "
"<https://github.com/OTRS/otrs/blob/rel-6_0/development/diagrams/Database/"
"OTRSDatabaseDiagram.png>`__ 上查看数据模型。"

#: ../../content/get-started/development-environment.rst:2
msgid "Development Environment"
msgstr "开发环境"

#: ../../content/get-started/development-environment.rst:4
msgid ""
"To facilitate the writing of OTRS expansion modules, the creation of a "
"development environment is necessary. The source code of OTRS and additional "
"public modules can be found on `GitHub <http://otrs.github.io>`__."
msgstr ""
"为了便于编写OTRS扩展模块，必须创建开发环境。 可以在 `GitHub <http://otrs."
"github.io>`__ 上找到OTRS和其它公共模块的源代码。"

#: ../../content/get-started/development-environment.rst:8
msgid "Framework checkout"
msgstr "检出框架"

#: ../../content/get-started/development-environment.rst:10
msgid ""
"First of all a directory must be created in which the modules can be stored. "
"Then switch to the new directory using the command line and check them out "
"by using the following command:"
msgstr ""
"首先，必须创建一个可以存储模块的目录。 然后使用命令行切换到新目录，并使用以下"
"命令检出它们："

#: ../../content/get-started/development-environment.rst:20
msgid ""
"Check out the ``module-tools`` module (from GitHub) too, for your "
"development environment. It contains a number of useful tools:"
msgstr ""
"对于您的开发环境，也可以检出 ``module-tools`` 模块（来自GitHub）。 它包含许多"
"有用的工具："

#: ../../content/get-started/development-environment.rst:27
#, fuzzy
#| msgid ""
#| "Please configure the OTRS system according to the `installation "
#| "instructions <https://doc.otrs.com/doc/manual/installation/stable/en/"
#| "index.html>`__."
msgid ""
"Please configure the OTRS system according to the `installation "
"instructions`_."
msgstr ""
"请根据 `安装说明 <https://doc.otrs.com/doc/manual/installation/stable/en/"
"index.html>`__ 配置OTRS系统。"

#: ../../content/get-started/development-environment.rst:33
msgid "Useful Tools"
msgstr "有用的工具"

#: ../../content/get-started/development-environment.rst:35
msgid "There are two modules that are highly recommended for OTRS development:"
msgstr "强烈建议OTRS开发使用这两个模块："

#: ../../content/get-started/development-environment.rst:37
msgid "`OTRSCodePolicy <https://github.com/OTRS/otrscodepolicy>`__"
msgstr "`OTRS代码策略 <https://github.com/OTRS/otrscodepolicy>`__"

#: ../../content/get-started/development-environment.rst:38
msgid "`Fred <https://github.com/OTRS/Fred>`__"
msgstr "`Fred <https://github.com/OTRS/Fred>`__"

#: ../../content/get-started/development-environment.rst:40
msgid ""
"*OTRSCodePolicy* is a code quality checker that enforces the use of common "
"coding standards also for the OTRS development team. It is highly "
"recommended to use it if you plan to make contributions. You can use it as a "
"standalone test script or even register it as a git commit hook that runs "
"every time that you create a commit. Please see `the module documentation "
"<https://github.com/OTRS/otrscodepolicy/blob/master/doc/en/OTRSCodePolicy."
"xml>`__ for details."
msgstr ""
"*OTRSCodePolicy* 是一个代码质量检查器，可以为OTRS开发团队强制使用通用编码标"
"准。 如果您计划做贡献，强烈建议您使用它。 您可以将它用作独立的测试脚本，甚至"
"可以将其注册为每次创建提交时运行的git commit hook。 有关详细信息，请参阅 `模"
"块文档 <https://github.com/OTRS/otrscodepolicy/blob/master/doc/en/"
"OTRSCodePolicy.xml>`__。"

#: ../../content/get-started/development-environment.rst:42
msgid ""
"*Fred* is a little development helper module that you can actually install "
"or link (as described below) into your development system. It features "
"several helpful modules that you can activate, such as an SQL logger or an "
"STDERR console. You can find some more details in its `module documentation "
"<https://github.com/OTRS/Fred/blob/master/doc/en/Fred.xml>`__."
msgstr ""
"*Fred* 是一个小型开发助手模块，您可以将其实际安装或链接（如下所述）到您的开发"
"系统中。 它具有几个可以激活的有用模块，例如SQL记录器或STDERR控制台。 您可以在"
"其 `模块文档 <https://github.com/OTRS/Fred/blob/master/doc/en/Fred.xml>`__ 中"
"找到更多详细信息。"

#: ../../content/get-started/development-environment.rst:44
msgid ""
"By the way, these tools are also open source, and we will be happy about any "
"improvements that you can contribute."
msgstr "顺便说一句，这些工具也是开源的，我们将为您可以贡献的任何改进感到高兴。"

#: ../../content/get-started/development-environment.rst:48
msgid "Linking Expansion Modules"
msgstr "链接扩展模块"

#: ../../content/get-started/development-environment.rst:50
msgid ""
"A clear separation between OTRS and the modules is necessary for proper "
"developing. Particularly when using a git clone, a clear separation is "
"crucial. In order to facilitate the OTRS access the files, links must be "
"created. This is done by a script in the directory module tools repository."
msgstr ""
"OTRS和模块之间的明确分离对于正确开发是必要的。 特别是当使用git克隆时，明确的"
"分离是至关重要的。 为了便于OTRS访问文件，必须创建链接。 这是通过模块工具存储"
"库目录中的脚本完成的。"

#: ../../content/get-started/development-environment.rst:52
msgid "Example: linking the *Calendar* module:"
msgstr "示例：链接 *Calendar日历* 模块："

#: ../../content/get-started/development-environment.rst:59
msgid "Whenever new files are added, they must be linked as described above."
msgstr "每当添加新文件时，必须如上所述链接它们。"

#: ../../content/get-started/development-environment.rst:61
msgid ""
"As soon as the linking is completed, the system configuration must be "
"rebuilt to register the module in OTRS. Additional SQL or Perl code from the "
"module must also be executed."
msgstr ""
"链接完成后，必须重建系统配置以在OTRS中注册模块。 还必须执行模块中的其它SQL或"
"Perl代码。"

#: ../../content/get-started/development-environment.rst:72
msgid "To remove links from OTRS enter the following command:"
msgstr "要从OTRS中删除链接，请输入以下命令："

#: ../../content/how-it-works.rst:2
msgid "OTRS Internals - How it Works"
msgstr "OTRS内部 - 如何工作"

#: ../../content/how-it-works/config-mechanism.rst:2
msgid "Config Mechanism"
msgstr "配置机制"

#: ../../content/how-it-works/config-mechanism.rst:4
msgid ""
"OTRS comes with a dedicated mechanism to manage configuration options via a "
"graphical interface (system configuration). This section describes how it "
"works internally and how you can provide new configuration options or change "
"existing default values."
msgstr ""
"OTRS带有专用机制，可通过图形界面（系统配置）管理配置选项。 本节介绍内部如何工"
"作以及如何提供新配置选项或更改现有默认值。"

#: ../../content/how-it-works/config-mechanism.rst:9
msgid "``Defaults.pm``: OTRS Default Configuration"
msgstr "``Defaults.pm``: OTRS 默认配置"

#: ../../content/how-it-works/config-mechanism.rst:11
msgid ""
"The default configuration file of OTRS is ``Kernel/Config/Defaults.pm``. "
"This file is needed for operation of freshly installed systems without a "
"deployed XML configuration and should be left untouched as it is "
"automatically updated on framework updates."
msgstr ""
"OTRS的默认配置文件是 ``Kernel/Config/Defaults.pm``。 在没有部署的XML配置的情"
"况下运行新安装的系统需要此文件，并且应该保持不变，因为它在框架更新时自动更"
"新。"

#: ../../content/how-it-works/config-mechanism.rst:15
msgid "Automatically Generated Configuration Files"
msgstr "自动生成的配置文件"

#: ../../content/how-it-works/config-mechanism.rst:17
msgid ""
"In ``Kernel/Config/Files`` you can find some automatically generated "
"configuration files:"
msgstr "在 ``Kernel/Config/Files`` 中，您可以找到一些自动生成的配置文件："

#: ../../content/how-it-works/config-mechanism.rst:20
msgid "``ZZZAAuto.pm``"
msgstr "``ZZZAAuto.pm``"

#: ../../content/how-it-works/config-mechanism.rst:20
msgid ""
"Perl cache of the XML configuration's current values (default or modified by "
"user)."
msgstr "XML配置的当前值的Perl缓存（默认或由用户修改）。"

#: ../../content/how-it-works/config-mechanism.rst:23
msgid "``ZZZACL.pm``"
msgstr "``ZZZACL.pm``"

#: ../../content/how-it-works/config-mechanism.rst:23
msgid "Perl cache of ACL configuration from database."
msgstr "来自数据库的ACL配置的Perl缓存。"

#: ../../content/how-it-works/config-mechanism.rst:26
msgid "``ZZZProcessManagement.pm``"
msgstr "``ZZZProcessManagement.pm``"

#: ../../content/how-it-works/config-mechanism.rst:26
msgid "Perl cache of process management configuration from database."
msgstr "来自数据库的流程管理配置的Perl缓存。"

#: ../../content/how-it-works/config-mechanism.rst:28
msgid ""
"These files are a Perl representation of the current system configuration. "
"They should never be manually changed as they are overwritten by OTRS."
msgstr ""
"这些文件是当前系统配置的Perl表示法。 永远不要手动更改它们，因为它们由OTRS覆"
"盖。"

#: ../../content/how-it-works/config-mechanism.rst:32
msgid "XML Configuration Files"
msgstr "XML配置文件"

#: ../../content/how-it-works/config-mechanism.rst:34
msgid ""
"In OTRS, configuration options that the administrator can configure via "
"system configuration are provided via XML files with a special format. To "
"convert old XML's you can use the following command:"
msgstr ""
"在OTRS中，管理员可以通过系统配置配置的配置选项通过具有特殊格式的XML文件提"
"供。 要转换旧XML，您可以使用以下命令："

#: ../../content/how-it-works/config-mechanism.rst:40
msgid ""
"The file ``Kernel/Config/Files/ZZZAAuto.pm`` is a cached Perl version of the "
"XML that contains all settings with their current value. It can be "
"(re-)generated with:"
msgstr ""
"``Kernel/Config/Files/ZZZAAuto.pm`` 文件是XML的缓存Perl版本，包含所有具有当前"
"值的设置。 它可以这样（重新）生成："

#: ../../content/how-it-works/config-mechanism.rst:46
msgid "Each XML config file has the following layout:"
msgstr "每个XML配置文件都具有以下布局："

#: ../../content/how-it-works/config-mechanism.rst:64
msgid "``init``"
msgstr "``init``"

#: ../../content/how-it-works/config-mechanism.rst:59
msgid ""
"The global ``init`` attribute describes where the config options should be "
"loaded. There are different levels available and will be loaded/overloaded "
"in the following order:"
msgstr ""
"全局``init``属性描述了应该加载配置选项的位置。 有不同级别可用，将按以下顺序加"
"载/重载："

#: ../../content/how-it-works/config-mechanism.rst:61
msgid "``Framework`` (for framework settings e. g. session option)"
msgstr "``Framework`` (用于框架设置，例如会话选项)"

#: ../../content/how-it-works/config-mechanism.rst:62
msgid "``Application`` (for application settings e. g. ticket options)"
msgstr "``Application`` （用于应用程序设置，例如工单选项）"

#: ../../content/how-it-works/config-mechanism.rst:63
msgid "``Config`` (for extensions to existing applications e. g. ITSM options)"
msgstr "``Config`` （用于扩展现有应用程序，例如ITSM选项）"

#: ../../content/how-it-works/config-mechanism.rst:64
msgid ""
"``Changes`` (for custom development e. g. to overwrite framework or ticket "
"options)."
msgstr "``Changes`` （用于自定义开发，例如覆盖框架或工单选项）。"

#: ../../content/how-it-works/config-mechanism.rst:66
msgid ""
"The configuration items are written as ``Setting`` elements with a "
"``Description``, a ``Navigation`` group (for the tree-based navigation in "
"the GUI) and the ``Value`` that it represents. Here's an example:"
msgstr ""
"配置项被写为 ``Setting`` 元素，有一个 ``Description`` 、一个 ``Navigation`` "
"组（用于GUI中的基于树的导航）和它所代表的 ``Value`` 。 这是一个例子："

#: ../../content/how-it-works/config-mechanism.rst:80
msgid "``Required``"
msgstr "``Required``"

#: ../../content/how-it-works/config-mechanism.rst:80
msgid "If this is set to 1, the configuration setting cannot be disabled."
msgstr "如果设置为1，则无法禁用配置设置。"

#: ../../content/how-it-works/config-mechanism.rst:83
msgid "``Valid``"
msgstr "``Valid``"

#: ../../content/how-it-works/config-mechanism.rst:83
msgid ""
"Determines if the config setting is active (1) or inactive (0) by default."
msgstr "确定默认情况下配置设置是激活（1）还是非激活（0）。"

#: ../../content/how-it-works/config-mechanism.rst:87
msgid "``ConfigLevel``"
msgstr "``ConfigLevel``"

#: ../../content/how-it-works/config-mechanism.rst:86
msgid ""
"If the optional attribute ``ConfigLevel`` is set, the config variable might "
"not be edited by the administrator, depending on his own config level. The "
"config variable ``ConfigLevel`` sets the level of technical experience of "
"the administrator. It can be *100 (Expert)*, *200 (Advanced)* or *300 "
"(Beginner)*. As a guideline which config level should be given to an option, "
"it is recommended that all options having to do with the configuration of "
"external interaction, like Sendmail, LDAP, SOAP, and others should get a "
"config level of at least *200 (Advanced)*."
msgstr ""
"如果设置了可选属性 ``ConfigLevel``，则管理员可能无法编辑配置变量，具体取决于"
"他自己的配置级别。 配置变量 ``ConfigLevel`` 设置管理员的技术经验水平。 它可以"
"是 *100（专家）*， *200（高级）* 或 *300（初学者）*。 作为应该为选项提供配置"
"级别的指导原则，建议所有与外部交互配置相关的选项（如Sendmail、LDAP、SOAP等）"
"的配置级别至少应为 *200（高级）*。"

#: ../../content/how-it-works/config-mechanism.rst:90
msgid "``Invisible``"
msgstr "``Invisible``"

#: ../../content/how-it-works/config-mechanism.rst:90
msgid "If set to 1, the config setting is not shown in the GUI."
msgstr "如果设置为1，则GUI中不显示配置设置。"

#: ../../content/how-it-works/config-mechanism.rst:93
msgid "``Readonly``"
msgstr "``Readonly``"

#: ../../content/how-it-works/config-mechanism.rst:93
msgid "If set to 1, the config setting cannot be changed in the GUI."
msgstr "如果设置为1，则无法在GUI中更改配置设置。"

#: ../../content/how-it-works/config-mechanism.rst:96
msgid "``UserModificationPossible``"
msgstr "``UserModificationPossible``"

#: ../../content/how-it-works/config-mechanism.rst:96
msgid ""
"If ``UserModificationPossible`` is set to ``1``, administrators can enable "
"user modifications of this setting (in user preferences)."
msgstr ""
"如果 ``UserModificationPossible`` 设置为 ``1`` ，管理员可以启用用户修改此设置"
"（在用户首选项中）。"

#: ../../content/how-it-works/config-mechanism.rst:99
msgid "``UserModificationActive``"
msgstr "``UserModificationActive``"

#: ../../content/how-it-works/config-mechanism.rst:99
msgid ""
"If ``UserModificationActive`` is set to ``1``, user modifications of this "
"setting is enabled (in user preferences). You should use this attribute "
"together with ``UserModificationPossible``."
msgstr ""
"如果 ``UserModificationActive`` 设置为 ``1``，则启用用户对此设置的修改（在用"
"户首选项中）。 您应该将此属性与 ``UserModificationPossible`` 一起使用。"

#: ../../content/how-it-works/config-mechanism.rst:102
msgid "``UserPreferencesGroup``"
msgstr "``UserPreferencesGroup``"

#: ../../content/how-it-works/config-mechanism.rst:102
msgid ""
"Use ``UserPreferencesGroup`` attribute to define under which group config "
"variable belongs (in the ``UserPreferences`` screen). You should use this "
"attribute together with ``UserModificationPossible``."
msgstr ""
"使用 ``UserPreferencesGroup`` 属性来定义哪个组配置变量属于哪个（在 "
"``UserPreferences用户首选项`` 屏幕中）。 您应该将此属性与 "
"``UserModificationPossible`` 一起使用。"

#: ../../content/how-it-works/config-mechanism.rst:104
msgid "Guidelines for placing settings in the right navigation nodes:"
msgstr "在右侧导航节点中放置设置的准则："

#: ../../content/how-it-works/config-mechanism.rst:106
msgid ""
"Only create new nodes if neccessary. Avoid nodes with only very few settings "
"if possible."
msgstr "只在必要时才创建新节点。 如果可能，请避免仅使用极少数设置的节点。"

#: ../../content/how-it-works/config-mechanism.rst:107
msgid "On the first tree level, no new nodes should be added."
msgstr "在第一个树级别，不应添加新节点。"

#: ../../content/how-it-works/config-mechanism.rst:108
msgid ""
"Don't place new settings in ``Core`` directly. This is reserved for a few "
"important global settings."
msgstr "不要直接在 ``Core`` 中放置新设置。 它保留用于一些重要的全局设置。"

#: ../../content/how-it-works/config-mechanism.rst:109
msgid ""
"``Core::*`` can take new groups that contain settings that cover the same "
"topic (like ``Core::Email``) or relate to the same entity (like ``Core::"
"Queue``)."
msgstr ""
"``Core::*`` 可以采用包含相同主题设置的新组（如 ``Core::Email``）或与同一实体"
"相关（如 ``Core::Queue``）。"

#: ../../content/how-it-works/config-mechanism.rst:110
msgid "All event handler registrations go to ``Core::Event``."
msgstr "所有事件处理程序注册都转到 ``Core::Event``。"

#: ../../content/how-it-works/config-mechanism.rst:111
msgid ""
"Don't add new direct child nodes within ``Frontend``. Global front end "
"settings go to ``Frontend::Base``, settings only affecting a part of the "
"system go to the respective ``Admin``, ``Agent``, ``Customer`` or ``Public`` "
"sub nodes."
msgstr ""
"不要在 ``Frontend`` 中添加新的直接子节点。 全局前端设置转到 ``Frontend::"
"Base``，只影响系统一部分的设置转到相应的 ``Admin``、 ``Agent``、 "
"``Customer`` 或 ``Public`` 子节点。"

#: ../../content/how-it-works/config-mechanism.rst:112
msgid ""
"Front end settings that only affect one screen should go to the relevant "
"screen (``View``) node (create one if needed), for example "
"``AgentTicketZoom`` related settings go to ``Frontend::Agent::View::"
"TicketZoom``. If there are module layers within one screen with groups of "
"related settings, they would also go to a sub group here (e. g. ``Frontend::"
"Agent::View::TicketZoom::MenuModule`` for all ticket zoom menu module "
"registrations)."
msgstr ""
"只影响一个屏幕的前端设置应该转到相关的屏幕（``View``）节点（如果需要，创建一"
"个），例如 ``AgentTicketZoom`` 相关的设置转到 ``Frontend::Agent::View::"
"TicketZoom``。 如果一个屏幕中有模块层与相关设置组，他们也会到这里的子组（例"
"如 ``Frontend::Agent::View::TicketZoom::MenuModule`` 用于所有工单详情菜单模块"
"注册）。"

#: ../../content/how-it-works/config-mechanism.rst:113
msgid ""
"All global loader settings go to ``Frontend::Base::Loader``, screen specific "
"loader settings to ``Frontend::*::ModuleRegistration::Loader``."
msgstr ""
"所有全局加载器设置都转到 ``Frontend::Base::Loader``，屏幕特定的加载器设置为 "
"``Frontend::*::ModuleRegistration::Loader``。"

#: ../../content/how-it-works/config-mechanism.rst:117
msgid "Structure of ``Value`` elements"
msgstr "``Value`` 元素的结构"

#: ../../content/how-it-works/config-mechanism.rst:119
msgid ""
"``Value`` elements hold the actual configuration data payload. They can "
"contain single values, hashes or arrays."
msgstr ""
"``Value`` 元素保存实际的配置数据有效负载。 它们可以包含单个值、哈希或数组。"

#: ../../content/how-it-works/config-mechanism.rst:124
msgid "``Item``"
msgstr "``Item``"

#: ../../content/how-it-works/config-mechanism.rst:126
msgid ""
"An ``Item`` element holds one piece of data. The optional ``ValueType`` "
"attribute determines which kind of data and how it needs to be presented to "
"the user in the GUI. If no ``ValueType`` is specified, it defaults to "
"``String``."
msgstr ""
"一个 ``Item`` 元素包含一个数据。 可选的 ``ValueType`` 属性确定哪种数据以及如"
"何在GUI中向用户呈现它。 如果没有指定 ``ValueType``，则默认为 ``String``。"

#: ../../content/how-it-works/config-mechanism.rst:128
msgid ""
"Please see :ref:`Value Types` for a definition of the different value types."
msgstr "请参阅 :ref:`Value Types` ，了解不同值类型的定义。"

#: ../../content/how-it-works/config-mechanism.rst:142
msgid "``Array``"
msgstr "``Array``"

#: ../../content/how-it-works/config-mechanism.rst:144
msgid "With this config element arrays can be displayed."
msgstr "使用此配置元素可以显示数组。"

#: ../../content/how-it-works/config-mechanism.rst:161
msgid "``Hash``"
msgstr "``Hash``"

#: ../../content/how-it-works/config-mechanism.rst:163
msgid "With this config element hashes can be displayed."
msgstr "使用此配置元素可以显示哈希值。"

#: ../../content/how-it-works/config-mechanism.rst:179
msgid ""
"It's possible to have nested array/hash elements (like hash of arrays, array "
"of hashes, array of hashes of arrays, etc.). Below is an example array of "
"hashes."
msgstr ""
"可以使用嵌套的数组/哈希元素（如数组哈希、哈希数组、数组哈希数组等）。 下面是"
"哈希数组的示例。"

#: ../../content/how-it-works/config-mechanism.rst:210
msgid "Value Types"
msgstr "值类型"

#: ../../content/how-it-works/config-mechanism.rst:212
msgid ""
"The XML config settings support various types of configuration variables."
msgstr "XML配置设置支持各种类型的配置变量。"

#: ../../content/how-it-works/config-mechanism.rst:216
msgid "``String``"
msgstr "``String``"

#: ../../content/how-it-works/config-mechanism.rst:228
msgid ""
"A config element for numbers and single-line strings. Checking the validity "
"with a regular expression is possible (optional). This is the default "
"``ValueType``."
msgstr ""
"用于数字和单行字符串的配置元素。 可以使用正则表达式检查有效性（可选）。 这是"
"默认的 ``ValueType``。"

#: ../../content/how-it-works/config-mechanism.rst:240
msgid ""
"The optional ``Translatable`` attribute marks this setting as translatable, "
"which will cause it to be included in the OTRS translation files. This "
"attribute can be placed on any tag (see also below)."
msgstr ""
"可选的 ``Translatable`` 属性将此设置标记为可翻译，这将使其包含在OTRS翻译文件"
"中。 此属性可以放在任何标记上（另请参见下文）。"

#: ../../content/how-it-works/config-mechanism.rst:244
msgid "``Password``"
msgstr "``Password``"

#: ../../content/how-it-works/config-mechanism.rst:246
msgid ""
"A config element for passwords. It's still stored as plain text in the XML, "
"but it's masked in the GUI."
msgstr ""
"用于密码的配置元素。 它仍然以纯文本形式存储在XML中，但它在GUI中被屏蔽。"

#: ../../content/how-it-works/config-mechanism.rst:259
msgid "``PerlModule``"
msgstr "``PerlModule``"

#: ../../content/how-it-works/config-mechanism.rst:261
msgid ""
"A config element for Perl module. It has a ``ValueFilter`` attribute, which "
"filters possible values for selection. In the example below, user can select "
"Perl module ``Kernel::System::Log::SysLog`` or ``Kernel::System::Log::File``."
msgstr ""
"用于Perl模块的配置元素。 它有一个 ``ValueFilter`` 属性，用于过滤可能的选择"
"值。 在下面的示例中，用户可以选择Perl模块 ``Kernel::System::Log::SysLog`` 或 "
"``Kernel::System::Log::File``。"

#: ../../content/how-it-works/config-mechanism.rst:274
msgid "``Textarea``"
msgstr "``Textarea``"

#: ../../content/how-it-works/config-mechanism.rst:276
msgid "A config element for multiline text."
msgstr "用于多行文本的配置元素。"

#: ../../content/how-it-works/config-mechanism.rst:289
msgid "``Select``"
msgstr "``Select``"

#: ../../content/how-it-works/config-mechanism.rst:291
msgid ""
"This config element offers preset values as a pull-down menu. The "
"``SelectedID`` or ``SelectedValue`` attributes can pre-select a default "
"value."
msgstr ""
"此配置元素提供预设值作为下拉菜单。 ``SelectedID`` 或 ``SelectedValue`` 属性可"
"以预先选择一个默认值。"

#: ../../content/how-it-works/config-mechanism.rst:307
msgid "``Checkbox``"
msgstr "``Checkbox``"

#: ../../content/how-it-works/config-mechanism.rst:309
msgid "This config element checkbox has two states: 0 or 1."
msgstr "此配置元素复选框有两种状态：0或1。"

#: ../../content/how-it-works/config-mechanism.rst:322
msgid "``Date``"
msgstr "``Date``"

#: ../../content/how-it-works/config-mechanism.rst:324
msgid "This config element contains a date value."
msgstr "此配置元素包含日期值。"

#: ../../content/how-it-works/config-mechanism.rst:337
msgid "``DateTime``"
msgstr "``DateTime``"

#: ../../content/how-it-works/config-mechanism.rst:339
msgid "This config element contains a date and time value."
msgstr "此配置元素包含日期时间值。"

#: ../../content/how-it-works/config-mechanism.rst:352
msgid "``Directory``"
msgstr "``Directory``"

#: ../../content/how-it-works/config-mechanism.rst:354
msgid "This config element contains a directory."
msgstr "此配置元素包含一个目录。"

#: ../../content/how-it-works/config-mechanism.rst:367
msgid "``File``"
msgstr "``File``"

#: ../../content/how-it-works/config-mechanism.rst:369
msgid "This config element contains a file path."
msgstr "此配置元素包含一个文件路径。"

#: ../../content/how-it-works/config-mechanism.rst:382
msgid "``Entity``"
msgstr "``Entity``"

#: ../../content/how-it-works/config-mechanism.rst:384
msgid ""
"This config element contains a value of a particular entity. "
"``ValueEntityType`` attribute defines the entity type. Supported entities: "
"``DynamicField``, ``Queue``, ``Priority``, ``State`` and ``Type``. "
"Consistency checks will ensure that only valid entities can be configured "
"and that entities used in the configuration cannot be set to invalid. Also, "
"when an entity is renamed, all referencing config settings will be updated."
msgstr ""
"此配置元素包含特定实体的值。 ``ValueEntityType`` 属性定义实体类型。 支持的实"
"体： ``DynamicField``、 ``Queue``、 ``Priority``、 ``State`` 和 ``Type``。 一"
"致性检查将确保只能配置有效实体，并且配置中使用的实体不能设置为无效。 此外，重"
"命名实体时，将更新所有引用配置设置。"

#: ../../content/how-it-works/config-mechanism.rst:397
msgid "``TimeZone``"
msgstr "``TimeZone``"

#: ../../content/how-it-works/config-mechanism.rst:399
msgid "This config element contains a time zone value."
msgstr "此配置元素包含时区值。"

#: ../../content/how-it-works/config-mechanism.rst:412
msgid "``VacationDays``"
msgstr "``VacationDays``"

#: ../../content/how-it-works/config-mechanism.rst:414
msgid ""
"This config element contains definitions for vacation days which are "
"repeating each year. Following attributes are mandatory: ``ValueMonth``, "
"``ValueDay``."
msgstr ""
"此配置元素包含每年重复的休假日的定义。 以下属性是必填的：``ValueMonth``、"
"``ValueDay``。"

#: ../../content/how-it-works/config-mechanism.rst:432
msgid "``VacationDaysOneTime``"
msgstr "``VacationDaysOneTime``"

#: ../../content/how-it-works/config-mechanism.rst:434
msgid ""
"This config element contains definitions for vacation days which occur only "
"once. Following attributes are mandatory: ``ValueMonth``, ``ValueDay`` and "
"``ValueYear``."
msgstr ""
"此配置元素包含仅发生一次的休假日的定义。 以下属性是必填的：``ValueMonth``、"
"``ValueDay`` 和 ``ValueYear``。"

#: ../../content/how-it-works/config-mechanism.rst:449
msgid "``WorkingHours``"
msgstr "``WorkingHours``"

#: ../../content/how-it-works/config-mechanism.rst:451
msgid "This config element contains definitions for working hours."
msgstr "此配置元素包含工作时间的定义。"

#: ../../content/how-it-works/config-mechanism.rst:473
msgid "Front End Registration"
msgstr "前端注册"

#: ../../content/how-it-works/config-mechanism.rst:475
msgid "Module registration for agent interface:"
msgstr "服务人员界面的模块注册："

#: ../../content/how-it-works/config-mechanism.rst:502
msgid "Default Item in Array and Hash"
msgstr "数组和哈希中的默认项"

#: ../../content/how-it-works/config-mechanism.rst:504
msgid ""
"The new XML structure allows us to create complex structures. Therefore we "
"need ``DefaultItem`` entries to describe the structure of the array/hash. If "
"it's not provided, system considers that you want simple array/hash with "
"scalar values. ``DefaultItem`` is used as a template when adding new "
"elements, so it can contain additional attributes, like ``ValueType``, and "
"it can define default values."
msgstr ""
"新的XML结构允许我们创建复杂的结构。 因此，我们需要 ``DefaultItem`` 条目来描述"
"数组/哈希的结构。 如果未提供，系统会认为您需要具有标量值的简单数组/散列。 "
"``DefaultItem`` 在添加新元素时用作模板，因此它可以包含其它属性如 "
"``ValueType``，并且可以定义默认值。"

#: ../../content/how-it-works/config-mechanism.rst:506
msgid "Here are few examples:"
msgstr "这里有些例子："

#: ../../content/how-it-works/config-mechanism.rst:510
msgid "Array of Array with ``Select`` Items"
msgstr "带有 ``Select`` 项的嵌套数组"

#: ../../content/how-it-works/config-mechanism.rst:528
msgid "Hash of Hash with ``Date`` Items"
msgstr "包含``Date`` 项的嵌套哈希"

#: ../../content/how-it-works/config-mechanism.rst:543
msgid "Accessing Config Options at Runtime"
msgstr "在运行时访问配置选项"

#: ../../content/how-it-works/config-mechanism.rst:545
msgid ""
"You can read and write (for one request) the config options via the core "
"module ``Kernel::Config``."
msgstr "您可以通过核心模块 ``Kernel::Config`` 读取和写入（一次请求）配置选项。"

#: ../../content/how-it-works/config-mechanism.rst:547
msgid "If you want to read a config option:"
msgstr "如果要读取配置选项："

#: ../../content/how-it-works/config-mechanism.rst:554
msgid ""
"If you want to change a config option at runtime and just for this one "
"request/process:"
msgstr "如果要在运行时更改配置选项，只需一个请求/进程："

#: ../../content/how-it-works/database-mechanism.rst:2
msgid "Database Mechanism"
msgstr "数据库机制"

#: ../../content/how-it-works/database-mechanism.rst:4
msgid "OTRS comes with a database layer that supports different databases."
msgstr "OTRS附带了一个支持不同数据库的数据库层。"

#: ../../content/how-it-works/database-mechanism.rst:6
msgid ""
"The database layer ``Kernel::System::DB`` has two input options: *SQL* and "
"*XML*."
msgstr "数据库层 ``Kernel::System::DB`` 有两个输入选项：*SQL* 和 *XML*。"

#: ../../content/how-it-works/database-mechanism.rst:10
msgid "SQL"
msgstr "SQL"

#: ../../content/how-it-works/database-mechanism.rst:12
msgid ""
"The SQL interface should be used for normal database actions (``SELECT``, "
"``INSERT``, ``UPDATE``, etc.). It can be used like a normal Perl DBI "
"interface."
msgstr ""
"SQL接口应该用于正常的数据库操作（``SELECT``、``INSERT``、``UPDATE`` 等）。 它"
"可以像普通的Perl DBI接口一样使用。"

#: ../../content/how-it-works/database-mechanism.rst:16
msgid "INSERT/UPDATE/DELETE statements"
msgstr "INSERT/UPDATE/DELETE 语句"

#: ../../content/how-it-works/database-mechanism.rst:34
msgid "SELECT statement"
msgstr "SELECT 语句"

#: ../../content/how-it-works/database-mechanism.rst:49
msgid ""
"Take care to use ``Limit`` as param and not in the SQL string because not "
"all databases support ``LIMIT`` in SQL strings."
msgstr ""
"注意使用 ``Limit`` 作为参数而不是SQL字符串，因为并非所有数据库都支持SQL字符串"
"中的 ``LIMIT``。"

#: ../../content/how-it-works/database-mechanism.rst:68
msgid ""
"Use the ``Bind`` attribute where ever you can, especially for long "
"statements. If you use ``Bind`` you do not need the function ``Quote()``."
msgstr ""
"尽可能使用 ``Bind`` 属性，特别是对于长语句。 如果使用 ``Bind``，则不需要 "
"``Quote()`` 函数。"

#: ../../content/how-it-works/database-mechanism.rst:72
msgid "QUOTE"
msgstr "QUOTE"

#: ../../content/how-it-works/database-mechanism.rst:74
msgid "String:"
msgstr "String（字符串）："

#: ../../content/how-it-works/database-mechanism.rst:81
msgid "Integer:"
msgstr "Integer（整数）："

#: ../../content/how-it-works/database-mechanism.rst:88
msgid "Number:"
msgstr "Number（数字）："

#: ../../content/how-it-works/database-mechanism.rst:96
msgid ""
"Please use the ``Bind`` attribute instead of ``Quote()`` where ever you can."
msgstr "请尽可能使用 ``Bind`` 属性而不是 ``Quote()`` 。"

#: ../../content/how-it-works/database-mechanism.rst:100
msgid "XML"
msgstr "XML"

#: ../../content/how-it-works/database-mechanism.rst:102
msgid ""
"The XML interface should be used for ``INSERT``, ``CREATE TABLE``, ``DROP "
"TABLE`` and ``ALTER TABLE``. As this syntax is different from database to "
"database, using it makes sure that you write applications that can be used "
"in all of them."
msgstr ""
"XML接口应该用于 ``INSERT``、``CREATE TABLE``、``DROP TABLE`` 和 ``ALTER "
"TABLE``。 由于此语法在数据库与数据库之间不同，因此使用它可确保编写可在所有这"
"些数据库中使用的应用程序。"

#: ../../content/how-it-works/database-mechanism.rst:106
msgid "INSERT"
msgstr "INSERT"

#: ../../content/how-it-works/database-mechanism.rst:117
msgid "CREATE TABLE"
msgstr "CREATE TABLE"

#: ../../content/how-it-works/database-mechanism.rst:119
msgid ""
"Possible data types are: ``BIGINT``, ``SMALLINT``, ``INTEGER``, ``VARCHAR`` "
"(Size=1-1000000), ``DATE`` (format: yyyy-mm-dd hh:mm:ss) and ``LONGBLOB``."
msgstr ""
"可能的数据类型有：``BIGINT``、``SMALLINT``、``INTEGER``、``VARCHAR`` （长度"
"为 1-1000000），``DATE`` （格式：yyyy-mm-dd hh:mm:ss）和 ``LONGBLOB``。"

#: ../../content/how-it-works/database-mechanism.rst:142
msgid ""
"``LONGBLOB`` columns need special treatment. Their content needs to be "
"base64 transcoded if the database driver does not support the feature "
"``DirectBlob``. Please see the following example:"
msgstr ""
"``LONGBLOB`` 列需要特殊处理。 如果数据库驱动程序不支持 ``DirectBlob`` 功能，"
"则它们的内容需要进行base64转码。 请参阅以下示例："

#: ../../content/how-it-works/database-mechanism.rst:151
msgid ""
"Similarly, when reading from such a column, the content must not "
"automatically be decoded as UTF-8 by passing the ``Encode => 0`` flag to "
"``Prepare()``:"
msgstr ""
"类似地，当从这样的列读取时，通过将 ``Encode => 0`` 标志传递给 ``Prepare()``，"
"内容不能自动解码为UTF-8："

#: ../../content/how-it-works/database-mechanism.rst:183
msgid "DROP TABLE"
msgstr "DROP TABLE"

#: ../../content/how-it-works/database-mechanism.rst:191
msgid "ALTER TABLE"
msgstr "ALTER TABLE"

#: ../../content/how-it-works/database-mechanism.rst:193
msgid "The following shows an example of add, change and drop columns."
msgstr "以下显示了添加、更改和删除列的示例。"

#: ../../content/how-it-works/database-mechanism.rst:219
msgid "The next shows an example how to rename a table."
msgstr "下一个示例显示了如何重命名一个表。"

#: ../../content/how-it-works/database-mechanism.rst:227
msgid "Code to Process XML"
msgstr "处理XML的代码"

#: ../../content/how-it-works/database-mechanism.rst:244
msgid "Database Drivers"
msgstr "数据库驱动程序"

#: ../../content/how-it-works/database-mechanism.rst:246
msgid ""
"The database drivers are located under ``$OTRS_HOME/Kernel/System/DB/*.pm``."
msgstr "数据库驱动程序位于 ``$OTRS_HOME/Kernel/System/DB/*.pm`` 下。"

#: ../../content/how-it-works/database-mechanism.rst:250
msgid "Supported Databases"
msgstr "支持的数据库"

#: ../../content/how-it-works/database-mechanism.rst:252
msgid "MySQL"
msgstr "MySQL"

#: ../../content/how-it-works/database-mechanism.rst:253
msgid "PostgreSQL"
msgstr "PostgreSQL"

#: ../../content/how-it-works/database-mechanism.rst:254
msgid "Oracle"
msgstr "Oracle"

#: ../../content/how-it-works/database-mechanism.rst:255
msgid ""
"Microsoft SQL Server (only for external database connections, not as OTRS "
"database)"
msgstr "Microsoft SQL Server (仅用于外部数据库连接，而不是OTRS数据库)"

#: ../../content/how-it-works/date-time.rst:2
msgid "Date and Time"
msgstr "日期和时间"

#: ../../content/how-it-works/date-time.rst:4
msgid ""
"OTRS comes with its own package to handle date and time which ensures "
"correct calculation and storage of date and time."
msgstr "OTRS自带软件包来处理日期和时间，确保正确计算和存储日期和时间。"

#: ../../content/how-it-works/date-time.rst:8
msgid "Introduction"
msgstr "介绍"

#: ../../content/how-it-works/date-time.rst:10
msgid ""
"Date and time are represented by an object of ``Kernel::System::DateTime``. "
"Every ``DateTime`` object holds its own date, time and time zone "
"information. In contrast to the now deprecated ``Kernel::System::Time`` "
"package, this means that you can and should create a ``DateTime`` object for "
"every date/time you want to use."
msgstr ""
"日期和时间由一个 ``Kernel::System::DateTime`` 的对象表示。 每个 ``DateTime`` "
"对象都有自己的日期、时间和时区信息。 与现在已弃用的 ``Kernel::System::Time`` "
"包相比，这意味着你可以而且应该为你想要使用的每个日期/时间创建一个 "
"``DateTime`` 对象。"

#: ../../content/how-it-works/date-time.rst:14
msgid "Creation of a ``DateTime`` Object"
msgstr "创建一个 ``DateTime`` 对象"

#: ../../content/how-it-works/date-time.rst:16
msgid ""
"The object manager of OTRS has been extended by a ``Create`` method to "
"support packages for which more than one instance can be created:"
msgstr ""
"OTRS的对象管理器已经通过 ``Create`` 方法进行了扩展，以支持可以为其创建多个实"
"例的软件包："

#: ../../content/how-it-works/date-time.rst:27
msgid ""
"The example above will create a ``DateTime`` object for the current date and "
"time in time zone *Europe/Berlin*. There are more options to create a "
"``DateTime`` object (time components, string, timestamp, cloning), see POD "
"of ``Kernel::System::DateTime``."
msgstr ""
"上面的例子将为 *Europe/Berlin* 时区的当前日期和时间创建一个 ``DateTime`` 对"
"象。 有更多选项来创建 ``DateTime`` 对象（时间组件、字符串、时间戳、克隆），请"
"参阅 ``Kernel::System::DateTime`` 的POD（Perl在线文档）。"

#: ../../content/how-it-works/date-time.rst:31
msgid ""
"You will get an error if you try to retrieve a ``DateTime`` object via ``"
"$Kernel::OM->Get('Kernel::System::DateTime')``."
msgstr ""
"如果您尝试通过 ``$Kernel::OM->Get('Kernel::System::DateTime')`` 取回一个 "
"``DateTime`` 对象，将会出错。"

#: ../../content/how-it-works/date-time.rst:35
msgid "Time Zones"
msgstr "时区"

#: ../../content/how-it-works/date-time.rst:37
msgid ""
"Time offsets in hours (+2, -10, etc.) have been replaced by time zones "
"(Europe/Berlin, America/New_York, etc.). The conversion between time zones "
"is completely encapsulated within a ``DateTime`` object. If you want to "
"convert to another time zone, simply use the following code:"
msgstr ""
"以小时（+ 2，-10等）为单位的时间偏移已被时区（Europe/Berlin、 America/"
"New_York等）取代。 时区之间的转换完全封装在 ``DateTime`` 对象中。 如果要转换"
"为其它时区，只需使用以下代码："

#: ../../content/how-it-works/date-time.rst:43
msgid ""
"There is a system configuration option ``OTRSTimeZone``. This setting "
"defines the time zone that OTRS uses internally to store date and time "
"within the database."
msgstr ""
"有一个系统配置选项 ``OTRSTimeZone``。 此设置定义OTRS内部用于在数据库中存储日"
"期和时间的时区。"

#: ../../content/how-it-works/date-time.rst:47
msgid ""
"You have to ensure to convert a ``DateTime`` object to the OTRS time zone "
"before it gets stored in the database (there's a convenient method for this: "
"``ToOTRSTimeZone()``). An exception could be that you explicitly want a "
"database column to hold a date/time in a specific time zone. But be aware "
"that the database itself won't provide time zone information by itself when "
"retrieving it."
msgstr ""
"你必须确保将 ``DateTime`` 对象转换为OTRS时区，然后才能将它存储到数据库中（有"
"一种方便的方法： ``ToOTRSTimeZone()``）。 例外情况可能是您明确希望数据库列在"
"特定时区中保存日期/时间。 但请注意，数据库本身在检索时不会自行提供时区信息。"

#: ../../content/how-it-works/date-time.rst:51
msgid ""
"``TimeZoneList()`` of ``Kernel::System::DateTime`` provides a list of "
"available time zones."
msgstr ""
"``Kernel::System::DateTime`` 的 ``TimeZoneList()`` 提供了一个可用的时区列表。"

#: ../../content/how-it-works/date-time.rst:55
msgid "Method Summary"
msgstr "方法摘要"

#: ../../content/how-it-works/date-time.rst:57
msgid ""
"The ``Kernel::System::DateTime`` package provides the following methods "
"(this is only a selection, see source code for details)."
msgstr ""
"``Kernel::System::DateTime`` 包提供了以下方法（这只是一个选择，详见源代码）。"

#: ../../content/how-it-works/date-time.rst:61
msgid "Object Creation Methods"
msgstr "对象创建方法"

#: ../../content/how-it-works/date-time.rst:63
msgid ""
"A ``DateTime`` object can be created either via the object manager's "
"``Create()`` method or by cloning another ``DateTime`` object with its "
"``Clone()`` method."
msgstr ""
"可以通过对象管理器的 ``Create()`` 方法创建 ``DateTime`` 对象，或者用 "
"``Clone()`` 方法克隆另一个 ``DateTime`` 对象。"

#: ../../content/how-it-works/date-time.rst:67
msgid "Get Method"
msgstr "Get方法"

#: ../../content/how-it-works/date-time.rst:69
msgid ""
"With ``Get()`` all data of a ``DateTime`` object will be returned as a hash "
"(date and time components including day name, etc. as well as time zone)."
msgstr ""
"使用 ``Get()``，``DateTime`` 对象的所有数据都将作为哈希返回（日期和时间组件包"
"括日期名称等，以及时区）。"

#: ../../content/how-it-works/date-time.rst:73
msgid "Set Method"
msgstr "Set方法"

#: ../../content/how-it-works/date-time.rst:75
msgid ""
"With ``Set()`` you can either change certain components of the ``DateTime`` "
"object (year, month, day, hour, minute, second) or you can set a date and "
"time based on a given string (*2016-05-24 23:04:12*). Note that you cannot "
"change the time zone with this method."
msgstr ""
"使用 ``Set()``，您可以更改 ``DateTime`` 对象的某些组件（年、月、日、小时、分"
"钟、秒），也可以根据给定的字符串设置日期和时间（*2016-05-24 23:04:12*）。 请"
"注意，您无法使用此方法更改时区。"

#: ../../content/how-it-works/date-time.rst:79
msgid "Time Zone Methods"
msgstr "时区方法"

#: ../../content/how-it-works/date-time.rst:81
msgid ""
"To change the time zone of a ``DateTime`` object use method ``ToTimeZone()`` "
"or as a shortcut for converting to OTRS time zone ``ToOTRSTimeZone()``."
msgstr ""
"要更改 ``DateTime`` 对象的时区，请使用 ``ToOTRSTimeZone()`` 方法或作为转换为"
"OTRS时区 ``ToOTRSTimeZone()`` 的快捷方式。"

#: ../../content/how-it-works/date-time.rst:83
msgid ""
"To retrieve the configured OTRS time zone or user default time zone, always "
"use method ``OTRSTimeZoneGet()`` or ``UserDefaultTimeZoneGet()``. Never "
"retrieve these manually via ``Kernel::Config``."
msgstr ""
"要检索配置的OTRS时区或用户默认时区，请始终使用方法 ``OTRSTimeZoneGet()`` 或 "
"``UserDefaultTimeZoneGet()`` 。 永远不要通过 ``Kernel::Config`` 手动检索它"
"们。"

#: ../../content/how-it-works/date-time.rst:87
msgid "Comparison Operators And Methods"
msgstr "比较操作符和方法"

#: ../../content/how-it-works/date-time.rst:89
msgid ""
"``Kernel::System::DateTime`` uses operator overloading for comparisons. So "
"you can simply compare two ``DateTime`` objects with <, <=, ==, !=, >= and "
">. ``Compare()`` is usable in Perl's sort context as it returns -1, 0 or 1."
msgstr ""
"``Kernel::System::DateTime`` 使用运算符重载进行比较。 所以你可以简单地将两个 "
"``DateTime`` 对象与<、<=、==、！=、> =和>进行比较。 ``Compare()`` 在Perl的排"
"序上下文中可用，因为它返回-1、0或1。"

#: ../../content/how-it-works/date-time.rst:93
msgid "Deprecated Package ``Kernel::System::Time``"
msgstr "弃用的包 ``Kernel::System::Time``"

#: ../../content/how-it-works/date-time.rst:95
msgid ""
"The now deprecated package ``Kernel::System::Time`` has been extended to "
"fully support time zones instead of time offsets. This has been done to "
"ensure that existing code works without (bigger) changes."
msgstr ""
"现已弃用的包 ``Kernel::System::Time`` 已经扩展到完全支持时区而不是时间偏移。 "
"这样做是为了确保现有代码在没有（更大）更改的情况下工作。"

#: ../../content/how-it-works/date-time.rst:97
msgid ""
"However, there is a case in which you have to change existing code. If you "
"have code that uses the old time offsets to calculate a new date/time or a "
"difference, you have to migrate this code to use the new ``DateTime`` object."
msgstr ""
"但是，有一种情况需要更改现有代码。 如果您有使用旧时偏移量来计算新日期/时间或"
"差异的代码，则必须迁移此代码以使用新的 ``DateTime`` 对象。"

#: ../../content/how-it-works/date-time.rst:99
msgid "Example (old code):"
msgstr "示例（旧代码）："

#: ../../content/how-it-works/date-time.rst:109
msgid "Example (new code):"
msgstr "示例（新代码）："

#: ../../content/how-it-works/loader.rst:2
msgid "The CSS and JavaScript Loader"
msgstr "CSS和JavaScript加载器"

#: ../../content/how-it-works/loader.rst:4
msgid ""
"The CSS and JavaScript code in OTRS grew to a large amount. To be able to "
"satisfy both development concerns (good maintainability by a large number of "
"separate files) and performance issues (making few HTTP requests and serving "
"minified content without unnecessary whitespace and documentation) had to be "
"addressed. To achieve these goals, the loader was invented."
msgstr ""
"OTRS中的CSS和JavaScript代码增长很多。 必须解决能够满足开发问题（大量单独文件"
"的良好可维护性）和性能问题（少量HTTP请求和提供缩小内容而没有不必要的空白和文"
"档）的问题。 为了实现这些目标，发明了装载机。"

#: ../../content/how-it-works/loader.rst:8
msgid "How it works"
msgstr "它如何运作"

#: ../../content/how-it-works/loader.rst:10
msgid "To put it simple, the loader:"
msgstr "简单来说，加载器："

#: ../../content/how-it-works/loader.rst:12
msgid ""
"determines for each request precisely which CSS and JavaScript files are "
"needed at the client side by the current application module"
msgstr "为每个请求确定当前应用程序模块在客户端需要哪些CSS和JavaScript文件"

#: ../../content/how-it-works/loader.rst:13
msgid "collects all the relevant data"
msgstr "收集所有相关数据"

#: ../../content/how-it-works/loader.rst:14
msgid "minifies the data, removing unnecessary whitespace and documentation"
msgstr "删除不必要的空格和文档来缩小数据"

#: ../../content/how-it-works/loader.rst:15
msgid ""
"serves it to the client in only a few HTTP requests instead of many "
"individual ones, allowing the client to cache these snippets in the browser "
"cache"
msgstr ""
"仅在少数HTTP请求中为客户端提供服务而不是许多单独的HTTP请求，允许客户端将这些"
"片段缓存在浏览器缓存中"

#: ../../content/how-it-works/loader.rst:16
msgid ""
"performs these tasks in a highly performing way, utilizing the caching "
"mechanisms of OTRS"
msgstr "利用OTRS的缓存机制，以高性能的方式执行这些任务"

#: ../../content/how-it-works/loader.rst:18
msgid ""
"Of course, there is a little bit more detailed involved, but this should "
"suffice as a first overview."
msgstr "当然，还有一些更详细的内容，但这应该足以作为首次概览。"

#: ../../content/how-it-works/loader.rst:22
msgid "Basic Operation"
msgstr "基本操作"

#: ../../content/how-it-works/loader.rst:24
msgid ""
"With the configuration settings ``Loader::Enabled::CSS`` and ``Loader::"
"Enabled::JavaScript``, the loader can be turned on and off for CSS and "
"JavaScript, respectively (it is on by default)."
msgstr ""
"使用配置设置 ``Loader::Enabled::CSS`` 和 ``Loader::Enabled::JavaScript``，可"
"以分别为CSS和JavaScript打开和关闭加载器（默认情况下它处于启用状态）。"

#: ../../content/how-it-works/loader.rst:28
msgid ""
"Because of rendering problems in Internet Explorer, the loader cannot be "
"turned off for CSS files for this client browser (config setting will be "
"overridden). Up to version 8, Internet Explorer cannot handle   more than 32 "
"CSS files on a page."
msgstr ""
"由于Internet Explorer中的渲染问题，无法为此客户端浏览器的CSS文件关闭加载器"
"（将覆盖配置设置）。 Internet Explorer 8之前均无法处理超过32个CSS文件的页面。"

#: ../../content/how-it-works/loader.rst:30
msgid ""
"To learn about how the loader works, please turn it off in your OTRS "
"installation with the aforementioned configuration settings. Now look at the "
"source code of the application module that you are currently using in this "
"OTRS system (after a reload, of course). You will see that there are many "
"CSS files loaded in the ``<head>`` section of the page, and many JavaScript "
"files at the bottom of the page, just before the closing ``</body>`` element."
msgstr ""
"要了解加载器的工作原理，请使用上述配置设置在OTRS安装中将其关闭。 现在查看您当"
"前在此OTRS系统中使用的应用程序模块的源代码（当然，在重新加载之后）。 您将看到"
"页面的 ``<head>`` 部分中加载了许多CSS文件，页面底部有许多JavaScript文件，就在"
"闭合 ``</body>`` 元素之前。"

#: ../../content/how-it-works/loader.rst:32
msgid ""
"Having the content like this in many individual files with a readable "
"formatting makes the development much easier, and even possible at all. "
"However, this has the disadvantage of a large number of HTTP requests "
"(network latency has a big effect) and unnecessary content (whitespace and "
"documentation) which needs to be transferred to the client."
msgstr ""
"在具有可读格式的许多单个文件中具有这样的内容使得开发更容易，甚至可能。 但是，"
"这具有大量HTTP请求（网络延迟具有很大影响）和需要传输到客户端的不必要内容（空"
"白和说明文档）的缺点。"

#: ../../content/how-it-works/loader.rst:34
msgid ""
"The loader solves this problem by performing the steps outlined in the short "
"description above. Please turn on the Loader again and reload your page now. "
"Now you can see that there are only very few CSS and JavaScript tags in the "
"HTML code, like this:"
msgstr ""
"加载器通过执行上面简短描述中概述的步骤来解决此问题。 请再次打开Loader并立即重"
"新加载您的页面。 现在您可以看到HTML代码中只有非常少的CSS和JavaScript标记，如"
"下所示："

#: ../../content/how-it-works/loader.rst:42
msgid ""
"What just happened? During the original request generating the HTML code for "
"this page, the Loader generated these two files (or took them from the "
"cache) and put the shown ``<script>`` tags on the page which link to these "
"files, instead of linking to all relevant JavaScript files separately (as "
"you saw it without the loader being active)."
msgstr ""
"刚刚发生了什么？ 在为该页面生成HTML代码的原始请求期间，加载器生成了这两个文件"
"（或从缓存中获取它们）并在页面上显示链接到这些文件的 ``<script>`` 标签，而不"
"是到所有相关的JavaScript文件的链接（正如您关闭加载器状态时看到的那样）。"

#: ../../content/how-it-works/loader.rst:44
msgid "The CSS section looks a little more complicated:"
msgstr "CSS部分看起来有点复杂："

#: ../../content/how-it-works/loader.rst:58
msgid ""
"The reason is that Internet Explorer 7 and 8 need special treatment in "
"addition to the default CSS because of their lacking support of web standard "
"technologies. So we have some normal CSS that is loaded in all browsers, and "
"some special CSS that is inside of so-called *conditional comments* which "
"cause it to be loaded **only** by Internet Explorer 7/8. All other browsers "
"will ignore it."
msgstr ""
"原因是Internet Explorer 7和8除了缺省CSS之外还需要特殊处理，因为它们缺乏对Web"
"标准技术的支持。 所以我们在所有浏览器中加载了一些普通的CSS，以及一些特殊的"
"CSS，这些CSS在所谓的 *条件注释* 中，这使得它 **只能** 由Internet Explorer 7/8"
"加载。 所有其它浏览器都会忽略它。"

#: ../../content/how-it-works/loader.rst:60
msgid ""
"Now we have outlined how the loader works. Let's look at how you can utilize "
"that in your own OTRS extensions by adding configuration data to the loader, "
"telling it to load additional or alternative CSS or JavaScript content."
msgstr ""
"现在我们已经概述了加载器的工作原理。 让我们看一下如何通过向加载器添加配置数"
"据，告诉它加载额外的或替代的CSS或JavaScript内容，在自己的OTRS扩展中利用它。"

#: ../../content/how-it-works/loader.rst:64
msgid "Configuring the Loader: JavaScript"
msgstr "配置加载器：JavaScript"

#: ../../content/how-it-works/loader.rst:66
msgid ""
"To be able to operate correctly, the loader needs to know which content it "
"has to load for a particular OTRS application module. First, it will look "
"for JavaScript files which *always* have to be loaded, and then it looks for "
"special files which are only relevant for the current application module."
msgstr ""
"为了能够正确操作，加载器需要知道必须为特定OTRS应用程序模块加载哪些内容。 首"
"先，它将查找 *始终* 必须加载的JavaScript文件，然后查找仅与当前应用程序模块相"
"关的特殊文件。"

#: ../../content/how-it-works/loader.rst:70
msgid "Common JavaScript"
msgstr "共用Javascript"

#: ../../content/how-it-works/loader.rst:72
msgid ""
"The list of JavaScript files to be loaded is configured in the configuration "
"settings ``Loader::Agent::CommonJS`` (for the agent interface) and ``Loader::"
"Customer::CommonJS`` (for the customer interface)."
msgstr ""
"要加载的JavaScript文件列表在配置设置 ``Loader::Agent::CommonJS`` (用于服务人"
"员界面）和 ``Loader::Customer::CommonJS`` （用于客户界面）中配置。"

#: ../../content/how-it-works/loader.rst:74
msgid ""
"These settings are designed as hashes, so that OTRS extensions can add their "
"own hash keys for additional content to be loaded. Let's look at an example:"
msgstr ""
"这些设置被设计为哈希值，因此OTRS扩展可以为要加载的其它内容添加自己的哈希键。 "
"我们来看一个例子："

#: ../../content/how-it-works/loader.rst:95
msgid ""
"This is the list of JavaScript files which always need to be loaded for the "
"agent interface of OTRS."
msgstr "这是始终需要为OTRS的服务人员界面加载的JavaScript文件列表。"

#: ../../content/how-it-works/loader.rst:97
msgid ""
"To add new content which is supposed to be loaded always in the agent "
"interface, just add an XML configuration file with another hash entry:"
msgstr ""
"要添加应该始终在服务人员界面中加载的新内容，只需添加带有另一个哈希条目的XML配"
"置文件："

#: ../../content/how-it-works/loader.rst:111
msgid "Simple, isn't it?"
msgstr "很简单，不是吗？"

#: ../../content/how-it-works/loader.rst:115
msgid "Module Specific JavaScript"
msgstr "特定于模块的JavaScript"

#: ../../content/how-it-works/loader.rst:117
msgid ""
"Not all JavaScript is usable for all application modules of OTRS. Therefore "
"it is possible to specify module specific JavaScript files. Whenever a "
"certain module is used (such as ``AgentDashboard``), the module specific "
"JavaScript for this module will also be loaded. The configuration is done in "
"the front end module registration in the XML configurations. Again, an "
"example:"
msgstr ""
"并非所有JavaScript都可用于OTRS的所有应用程序模块。 因此，可以指定特定于模块的"
"JavaScript文件。 每当使用某个模块（例如 ``AgentDashboard``）时，也会加载该模"
"块的模块特定JavaScript。 配置在XML配置中的前端模块注册中完成。 再举一个例子："

#: ../../content/how-it-works/loader.rst:150
msgid ""
"It is possible to put a ``<Item Key=\"JavaScript\">`` tag in the front end "
"module registrations which may contain ``<Array>`` and one tag ``<Item>`` "
"for each JavaScript file that is supposed to be loaded for this application "
"module."
msgstr ""
"可以在前端模块注册中放置一个 ``<Item Key=\"JavaScript\">`` 标签，包含 "
"``<Array>`` 和为此应用程序模块加载的每个JavaScript文件一个 ``<Item>`` 标签 。"

#: ../../content/how-it-works/loader.rst:153
msgid ""
"Now you have all information you need to configure the way the loader "
"handles JavaScript code."
msgstr "现在，您拥有配置加载器处理JavaScript代码的方式所需的所有信息。"

#: ../../content/how-it-works/loader.rst:157
msgid "Configuring the Loader: CSS"
msgstr "配置加载器：CSS"

#: ../../content/how-it-works/loader.rst:159
msgid ""
"The loader handles CSS files very similar to JavaScript files, as described "
"in the previous section, and extending the settings works in the same way "
"too."
msgstr ""
"加载器处理与JavaScript文件非常相似的CSS文件，如上一节所述，扩展设置也以相同的"
"方式工作。"

#: ../../content/how-it-works/loader.rst:164
msgid "Common CSS"
msgstr "共用CSS"

#: ../../content/how-it-works/loader.rst:166
msgid ""
"The way common CSS is handled is very similar to the way :ref:`Common "
"JavaScript` is loaded."
msgstr "处理共用CSS的加载方式非常类似于 :ref:`Common JavaScript`。"

#: ../../content/how-it-works/log-mechanism.rst:2
msgid "Log Mechanism"
msgstr "日志机制"

#: ../../content/how-it-works/log-mechanism.rst:5
msgid "System Log"
msgstr "系统日志"

#: ../../content/how-it-works/log-mechanism.rst:7
msgid ""
"OTRS comes with a system log back end that can be used for application "
"logging and debugging."
msgstr "OTRS带有一个系统日志后端，可用于应用程序日志记录和调试。"

#: ../../content/how-it-works/log-mechanism.rst:9
msgid ""
"The ``Log`` object can be accessed and used via the object manager like this:"
msgstr "可以通过对象管理器访问和使用 ``Log`` 对象，如下所示："

#: ../../content/how-it-works/log-mechanism.rst:18
msgid ""
"Depending on the configured log level via ``MinimumLogLevel`` option in "
"system configuration, logged message will either be saved or not, based on "
"their ``Priority`` flag."
msgstr ""
"根据系统配置中 ``MinimumLogLevel`` 选项配置的日志级别，记录的消息将根据其 "
"``Priority（优先级）`` 标志保存或不保存。"

#: ../../content/how-it-works/log-mechanism.rst:20
msgid ""
"If ``error`` is set, just errors are logged. With ``debug``, you get all "
"logging messages. The order of log levels is:"
msgstr ""
"如果设置了 ``error``，则只记录错误。 使用 ``debug``，您可以获得所有日志消"
"息。 日志级别的顺序是："

#: ../../content/how-it-works/log-mechanism.rst:22
msgid "``debug``"
msgstr "``debug``"

#: ../../content/how-it-works/log-mechanism.rst:23
msgid "``info``"
msgstr "``info``"

#: ../../content/how-it-works/log-mechanism.rst:24
msgid "``notice``"
msgstr "``notice``"

#: ../../content/how-it-works/log-mechanism.rst:25
msgid "``error``"
msgstr "``error``"

#: ../../content/how-it-works/log-mechanism.rst:27
msgid ""
"The output of the system log can be directed to either a syslog daemon or "
"log file, depending on the configured ``LogModule`` option in system "
"configuration."
msgstr ""
"系统日志的输出可以定向到syslog守护进程或日志文件，具体取决于系统配置中配置的 "
"``LogModule`` 选项。"

#: ../../content/how-it-works/log-mechanism.rst:31
msgid "Communication Log"
msgstr "通信日志"

#: ../../content/how-it-works/log-mechanism.rst:33
msgid ""
"In addition to system log, OTRS provides specialized logging back end for "
"any communication related logging. The system comes with dedicated tables "
"and front ends to track and display communication logs for easier debugging "
"and operational overview."
msgstr ""
"除系统日志外，OTRS还为任何与通信相关的日志记录提供专门的日志记录后端。 该系统"
"配有专用的表和前端，用于跟踪和显示通信日志，以便于调试和状态概览。"

#: ../../content/how-it-works/log-mechanism.rst:35
msgid ""
"To take advantage of the new system, first create a non-singleton instance "
"of communication log object:"
msgstr "要利用新系统，首先要创建一个非单例的通信日志对象实例："

#: ../../content/how-it-works/log-mechanism.rst:49
msgid ""
"When you have a communication log object instance, you can start an object "
"log for logging individual messages. There are two object logs currently "
"implemented: ``Connection`` and ``Message``."
msgstr ""
"拥有通信日志对象实例时，可以启动对象日志以记录单个消息。 目前有两个对象日志："
"``Connection`` 和 ``Message``。"

#: ../../content/how-it-works/log-mechanism.rst:51
msgid ""
"``Connection`` object log should be used for logging any connection related "
"messages (for example: authenticating on server or retrieving incoming "
"messages)."
msgstr ""
"``Connection`` 对象日志应该用于记录任何与连接相关的消息（例如：在服务器上进行"
"身份验证或检索传入消息）。"

#: ../../content/how-it-works/log-mechanism.rst:53
msgid ""
"Simply, start the object log by declaring its type, and you can use it "
"immediately:"
msgstr "简单地说，通过声明其类型来启动对象日志，您可以立即使用它："

#: ../../content/how-it-works/log-mechanism.rst:68
msgid ""
"The communication log object instance handles the current started object "
"logs, so you don't need to remember and bring them around everywhere, but it "
"also means that you can only start one object per type."
msgstr ""
"通信日志对象实例处理当前启动的对象日志，因此您无需记住并随处携带它们，但这也"
"意味着您只能为每种类型启动一个对象。"

#: ../../content/how-it-works/log-mechanism.rst:70
msgid ""
"If you encounter an unrecoverable error, you can choose to close the object "
"log and mark it as failed:"
msgstr "如果遇到不可恢复的错误，可以选择关闭对象日志并将其标记为失败："

#: ../../content/how-it-works/log-mechanism.rst:86
msgid "In turn, you can mark the communication log as failure as well:"
msgstr "接下来，同样将通信日志标记为失败："

#: ../../content/how-it-works/log-mechanism.rst:94
msgid ""
"Otherwise, stop the object log and in turn communication log as success:"
msgstr "否则，请停止对象日志，然后将通信日志视为成功："

#: ../../content/how-it-works/log-mechanism.rst:114
msgid ""
"``Message`` object log should be used for any log entries regarding specific "
"messages and their processing. It is used in a similar way, just make sure "
"to start it before using it:"
msgstr ""
"``Message`` 对象日志应该用于任何有关特定消息及其处理的日志条目。 它以类似的方"
"式使用，只需确保在使用它之前启动它："

#: ../../content/how-it-works/log-mechanism.rst:138
msgid ""
"You also have the possibility to link the log object and later lookup the "
"communications for a certain object type and ID:"
msgstr "您还可以链接日志对象，然后查找特定对象类型和ID的通信："

#: ../../content/how-it-works/log-mechanism.rst:153
msgid ""
"You should make sure to always stop communication and flag it as failed, if "
"any log object failed as well. This will allow administrators to see failed "
"communications in the overview, and take any action if needed."
msgstr ""
"如果任何日志对象都失败，您应该确保始终停止通信并将其标记为失败。 这将允许管理"
"员在概览中查看失败的通信，并在需要时执行任何操作。"

#: ../../content/how-it-works/log-mechanism.rst:155
msgid ""
"It's important to preserve the communication log for duration of a single "
"process. If your work is spanning over multiple modules and any of them can "
"benefit from logging, make sure to pass the existing communication log "
"instance around so all methods can use the same one. With this approach, you "
"will make sure any log entries spawned for the same process are contained in "
"a single communication."
msgstr ""
"在单个进程的持续时间内保留通信日志非常重要。 如果您的工作跨越多个模块，并且其"
"中任何一个都可以从日志记录中受益，请确保传递现有的通信日志实例，以便所有方法"
"都可以使用相同的模块。 使用此方法，您将确保为同一进程生成的任何日志条目都包含"
"在单个通信中。"

#: ../../content/how-it-works/log-mechanism.rst:157
msgid ""
"If passing the communication log instance is not an option (async tasks!), "
"you can also choose to recreate the communication log object in the same "
"state as in previous step. Just get the communication ID and pass it to the "
"new code, and then create the instance with this parameter supplied:"
msgstr ""
"如果无法传递通信日志实例（异步任务！），您还可以选择以与上一步相同的状态重新"
"创建通信日志对象。 只需获取通信ID并将其传递给新代码，然后使用提供的此参数创建"
"实例："

#: ../../content/how-it-works/log-mechanism.rst:175
msgid ""
"You can then continue to use this instance as previously stated, start any "
"object logs if needed, adding entries and setting status in the end."
msgstr ""
"然后，您可以继续使用此实例，如前所述，根据需要启动任何对象日志，最后添加条目"
"和设置状态。"

#: ../../content/how-it-works/log-mechanism.rst:177
msgid ""
"If you need to retrieve the communication log data or do something else with "
"it, please also take a look at ``Kernel::System::CommunicationLog::DB.pm``."
msgstr ""
"如果您需要检索通信日志数据或使用它做其它事情，请同时查看 ``Kernel::System::"
"CommunicationLog::DB.pm``。"

#: ../../content/how-it-works/skins.rst:2
msgid "Skins"
msgstr "皮肤"

#: ../../content/how-it-works/skins.rst:4
msgid "The visual appearance of OTRS is controlled by *skins*."
msgstr "OTRS的视觉外观由 *皮肤* 控制。"

#: ../../content/how-it-works/skins.rst:6
msgid ""
"A skin is a set of CSS and image files, which together control how the GUI "
"is presented to the user. Skins do not change the HTML content that is "
"generated by OTRS (this is what *themes* do), but they control how it is "
"displayed. With the help of modern CSS standards it is possible to change "
"the display thoroughly (e.g. repositioning parts of dialogs, hiding "
"elements, etc.)."
msgstr ""
"一个皮肤是一组CSS和图像文件，它们共同控制GUI呈现给用户的方式。 皮肤不会更改由"
"OTRS生成的HTML内容（这是 *主题* 所做的），但它们控制着它的显示方式。 在现代"
"CSS标准的帮助下，可以彻底改变显示（例如，重新定位对话框的各部分、隐藏元素"
"等）。"

#: ../../content/how-it-works/skins.rst:10
msgid "Skin Basics"
msgstr "皮肤基础"

#: ../../content/how-it-works/skins.rst:12
msgid ""
"All skins are in ``$OTRS_HOME/var/httpd/htdocs/skins/Agent/$SKIN_NAME``."
msgstr ""
"所有皮肤都在 ``$OTRS_HOME/var/httpd/htdocs/skins/Agent/$SKIN_NAME`` 中。"

#: ../../content/how-it-works/skins.rst:14
msgid ""
"Each of the agents can select individually, which of the installed agent "
"skins they want to *wear*."
msgstr "每个服务人员可以单独选择 *穿着* 哪一款已安装的服务人员皮肤。"

#: ../../content/how-it-works/skins.rst:18
msgid ""
"Skin support for customer interface was dropped with the new external "
"interface. To create customized layout for external interface, use the "
"*Layout* module of the admin interface."
msgstr ""
"使用新的外部人员界面删除了客户界面的皮肤支持。 要为外部人员界面创建自定义布"
"局，请使用管理员界面的 *排版布局* 模块。"

#: ../../content/how-it-works/skins.rst:22
msgid "How Skins Are Loaded"
msgstr "如何加载皮肤"

#: ../../content/how-it-works/skins.rst:24
msgid ""
"It is important to note that the ``default`` skin will **always** be loaded "
"**first**. If the agent selected another skin than the default one, the "
"other one will be loaded only **after** the default skin. By loading here we "
"mean that OTRS will put tags into the HTML content which cause the CSS files "
"to be loaded by the browser. Let's see an example of this:"
msgstr ""
"重要的是要注意，``default`` 皮肤将 **始终** **首先加载**。 如果服务人员选择了"
"默认皮肤之外的另一个皮肤，则它将仅在默认皮肤 **之后** 加载。 在这里的加载，我"
"们的意思是OTRS会将标记放入HTML内容中，这会导致浏览器加载CSS文件。 让我们看一"
"个这样的例子："

#: ../../content/how-it-works/skins.rst:31
msgid ""
"Here it can clearly be seen that the ``default`` skin is loaded first, and "
"then the custom skin specified by the agent. In this example, we see the "
"result of the activated loader (``Loader::Enabled`` set to 1), which gathers "
"all CSS files, concatenates and minifies them and serves them as one chunk "
"to the browser. This saves bandwidth and also reduces the number of HTTP "
"requests. Let's see the same example with the loader turned off:"
msgstr ""
"在这里可以清楚地看到，首先加载 ``default`` 皮肤，然后加载服务人员指定的自定义"
"皮肤。 在这个例子中，我们看到激活的加载器的结果（``Loader::Enabled`` 设置为"
"1），它收集所有CSS文件，连接并缩小它们并将它们作为浏览器的一个块提供。 这样可"
"以节省带宽并减少HTTP请求的数量。 让我们看一下关闭加载器的相同示例："

#: ../../content/how-it-works/skins.rst:58
msgid "Here we can better see the individual files that come from the skins."
msgstr "在这里，我们可以更好地查看来自皮肤的各个文件。"

#: ../../content/how-it-works/skins.rst:60
msgid ""
"There are different types of CSS files: common files which must always be "
"loaded, and module-specific files which are only loaded for special modules "
"within the OTRS framework."
msgstr ""
"有不同类型的CSS文件：必须始终加载的公用文件，以及仅为OTRS框架内的特殊模块加载"
"的特定于模块的文件。"

#: ../../content/how-it-works/skins.rst:62
msgid ""
"In addition, it is possible to specify CSS files which only must be loaded "
"on IE7 or IE8 (in the case of the customer interface, also IE6). This is "
"unfortunate, but it was not possible to develop a modern GUI on these "
"browsers without having special CSS for them."
msgstr ""
"此外，可以指定只能在IE7或IE8上加载的CSS文件（在客户界面的情况下，还有IE6）。 "
"这是不幸的，但是在这些浏览器上开发现代GUI没有特殊的CSS是不可能的。"

#: ../../content/how-it-works/skins.rst:64
msgid ""
"For details regarding the CSS file types, please see the :doc:`loader` "
"section."
msgstr "有关CSS文件类型的详细信息，请参阅 :doc:`loader` 部分。"

#: ../../content/how-it-works/skins.rst:66
msgid ""
"For each HTML page generation, the loader will first take all configured CSS "
"files from the ``default`` skin, and then for each file look if it is also "
"available in a custom skin (if a custom skin is selected) and load them "
"after the default files."
msgstr ""
"对于每个HTML页面生成，加载器将首先从 ``default`` 皮肤中获取所有已配置的CSS文"
"件，然后为每个文件查看它是否也在自定义皮肤中可用（如果选择了自定义皮肤）并在"
"默认文件之后加载它们。"

#: ../../content/how-it-works/skins.rst:68
msgid ""
"That means a) that CSS files in custom skins need to have the same names as "
"in the default skins, and b) that a custom skin does not need to have all "
"files of the default skin. That is the big advantage of loading the default "
"skin first: a custom skin has all default CSS rules present and only needs "
"to change those which should result in a different display. That can often "
"be done in a single file, like in the example above."
msgstr ""
"这意味着a）自定义皮肤中的CSS文件需要与默认皮肤中的名称相同，并且b）自定义皮肤"
"不需要具有默认皮肤的所有文件。 这是首先加载默认皮肤的一大优势：自定义皮肤具有"
"所有默认的CSS规则，只需要更改应该导致不同显示的那些。 这通常可以在单个文件中"
"完成，如上例所示。"

#: ../../content/how-it-works/skins.rst:70
msgid ""
"Another effect of this is that you need to be careful to overwrite all "
"default CSS rules in your custom skins that you want to change. Let's see an "
"example:"
msgstr ""
"这样做的另一个影响是，您需要小心覆盖要更改的自定义外观中的所有默认CSS规则。 "
"我们来看一个例子："

#: ../../content/how-it-works/skins.rst:79
msgid ""
"This defines special headings inside of the ``.Header`` element as bold, "
"black text. Now if you want to change that in your skin to another color and "
"normal text, it is not enough to write this:"
msgstr ""
"这将 ``.Header`` 元素内部的特殊标题定义为粗体黑色文本。 现在，如果你想将皮肤"
"中的颜色改为另一种颜色和普通文本，那么写这个是不够的："

#: ../../content/how-it-works/skins.rst:87
msgid ""
"Because the original rule for ``font-weight`` still applies. You need to "
"override it explicitly:"
msgstr "因为 ``font-weight`` 的原始规则仍然适用。 您需要显式覆盖它："

#: ../../content/how-it-works/skins.rst:97
msgid "Creating a New Skin"
msgstr "创建一个新皮肤"

#: ../../content/how-it-works/skins.rst:99
msgid ""
"In this section, we will be creating a new agent skin which replaces the "
"default OTRS background color (white) with a custom company color (light "
"grey) and the default logo by a custom one. Also we will configure that skin "
"to be the one which all agents will see by default."
msgstr ""
"在本节中，我们将创建一个新的服务人员皮肤，它使用自定义公司颜色（浅灰色）替换"
"默认OTRS背景颜色（白色），并使用自定义Logo替换默认Logo（徽标）。 此外，我们将"
"配置该皮肤为默认情况下所有服务人员将看到的皮肤。"

#: ../../content/how-it-works/skins.rst:101
msgid "There are only three simple steps we need to take to achieve this goal:"
msgstr "为实现这一目标，我们只需要采取三个简单的步骤："

#: ../../content/how-it-works/skins.rst:103
msgid "create the skin files"
msgstr "创建皮肤文件"

#: ../../content/how-it-works/skins.rst:104
msgid "configure the new logo and"
msgstr "配置新的Logo"

#: ../../content/how-it-works/skins.rst:105
msgid "make the skin known to the OTRS system"
msgstr "让OTRS系统知道该皮肤"

#: ../../content/how-it-works/skins.rst:107
msgid ""
"Let's start by creating the files needed for our new skin. First of all, we "
"need to create a new folder for this skin (we'll call it ``custom``). This "
"folder will be ``$OTRS_HOME/var/httpd/htdocs/skins/Agent/custom``."
msgstr ""
"让我们从创建新皮肤所需的文件开始。 首先，我们需要为这个皮肤创建一个新文件夹"
"（我们称之为 ``custom``）。 该文件夹将是 ``$OTRS_HOME/var/httpd/htdocs/skins/"
"Agent/custom``。"

#: ../../content/how-it-works/skins.rst:109
msgid ""
"In there, we need to place the new CSS file in a new directory ``css`` which "
"defines the new skin's appearance. We'll call it ``Core.Default.css``. "
"Remember that it must have the same name as one of the files in the default "
"skin. This is the code needed for the CSS file:"
msgstr ""
"在那里，我们需要将新的CSS文件放在一个新目录 ``css`` 中，它定义了新皮肤的外"
"观。 我们称之为 ``Core.Default.css``。 请记住，它必须与默认外观中的一个文件具"
"有相同的名称。 这是CSS文件所需的代码："

#: ../../content/how-it-works/skins.rst:117
msgid ""
"Now follows the second step, adding a new logo and making the new skin known "
"to the OTRS system. For this, we first need to place our custom logo (e.g. "
"``logo.png``) in a new directory (e.g. ``img``) in our skin directory. Then "
"we need to create a new configuration file ``$OTRS_HOME/Kernel/Config/Files/"
"XML/CustomSkin.xml``, which will contain the needed settings as follows:"
msgstr ""
"接下来是第二步，添加一个新Logo并使OTRS系统知道该新皮肤。 为此，我们首先需要将"
"我们的自定义logo（例如 ``logo.png``）放在我们的皮肤目录中的新目录（例如 "
"``img``）中。 然后我们需要创建一个新的配置文件 ``$OTRS_HOME/Kernel/Config/"
"Files/XML/CustomSkin.xml``，它将包含所需的设置，如下所示："

#: ../../content/how-it-works/skins.rst:153
msgid ""
"To make this configuration active, we need to navigate to the system "
"configuration module in the admin area of OTRS. Alternatively, you can run "
"the script:"
msgstr ""
"要使此配置处于活动状态，我们需要导航到OTRS系统管理区域中的系统配置模块。 或"
"者，您可以运行脚本："

#: ../../content/how-it-works/skins.rst:159
msgid ""
"This will regenerate the Perl cache of the XML configuration files, so that "
"our new skin is now known and can be selected in the system. To make it the "
"default skin that new agents see before they made their own skin selection, "
"edit the system configuration setting ``Loader::Agent::DefaultSelectedSkin`` "
"and set it to *custom*."
msgstr ""
"这将重新生成XML配置文件的Perl缓存，以便我们的新皮肤为系统所知并可在系统中选"
"择。 要使它成为服务人员在进行自己的皮肤选择之前看到的默认皮肤，请编辑系统配置"
"设置 ``Loader::Agent::DefaultSelectedSkin`` 并将其设置为 *custom*。"

#: ../../content/how-it-works/skins.rst:161
msgid ""
"In conclusion: to create a new skin in OTRS, we had to place the new logo "
"file, and create one CSS and one XML file, resulting in three new files:"
msgstr ""
"总之：要在OTRS中创建一个新的皮肤，我们必须放置新的徽标文件，并创建一个CSS和一"
"个XML文件，从而产生三个新文件："

#: ../../content/how-it-works/templates.rst:2
msgid "Templating Mechanism"
msgstr "模板机制"

#: ../../content/how-it-works/templates.rst:4
msgid ""
"Internally, OTRS uses a templating mechanism to dynamically generate its "
"HTML pages (and other content), while keeping the program logic (Perl) and "
"the presentation (HTML) separate. Typically, a front end module will use an "
"own template file, pass some data to it and return the rendered result to "
"the user."
msgstr ""
"OTRS在内部使用模板机制动态生成其HTML页面（和其它内容），同时保持程序逻辑"
"（Perl）和呈现（HTML）分离。 通常，前端模块将使用自己的模板文件，将一些数据传"
"递给它并将渲染的结果返回给用户。"

#: ../../content/how-it-works/templates.rst:6
msgid ""
"The template files are located at ``$OTRS_HOME/Kernel/Output/HTML/Standard/*."
"tt``."
msgstr "模板文件位于 ``$OTRS_HOME/Kernel/Output/HTML/Standard/*.tt``。"

#: ../../content/how-it-works/templates.rst:8
msgid ""
"OTRS relies on `the Template::Toolkit rendering engine <http://www.template-"
"toolkit.org/>`__. The full Template::Toolkit syntax can be used in OTRS "
"templates. This section describes some example use cases and OTRS extensions "
"to the Template::Toolkit syntax."
msgstr ""
"OTRS依赖于 `Template::Toolkit渲染引擎 <http://www.template-toolkit.org/"
">`__。 可以在OTRS模板中使用完整的Template::Toolkit语法。 本节介绍一些示例用例"
"和Template::Toolkit语法的OTRS扩展。"

#: ../../content/how-it-works/templates.rst:12
msgid "Template Commands"
msgstr "模板命令"

#: ../../content/how-it-works/templates.rst:15
msgid "Inserting Dynamic Data"
msgstr "插入动态数据"

#: ../../content/how-it-works/templates.rst:17
msgid ""
"In templates, dynamic data must be inserted, quoted etc. This section lists "
"the relevant commands to do that."
msgstr "在模板中，必须插入动态数据、引用等。本节列出了执行此操作的相关命令。"

#: ../../content/how-it-works/templates.rst:21
msgid "``[% Data.Name %]``"
msgstr "``[% Data.Name %]``"

#: ../../content/how-it-works/templates.rst:23
msgid ""
"If data parameters are given to the templates by the application module, "
"these data can be output to the template. ``[% Data.Name %]`` is the most "
"simple, but also most dangerous one. It will insert the data parameter whose "
"name is ``Name`` into the template as it is, without further processing."
msgstr ""
"如果应用程序模块将数据参数提供给模板，则这些数据可以输出到模板。``[%data.name"
"%]`` 是最简单但也是最危险的。它将把名为 ``Name`` 的数据参数按原样插入到模板"
"中，而无需进一步处理。"

#: ../../content/how-it-works/templates.rst:27
#: ../../content/how-it-works/templates.rst:107
msgid ""
"Because of the missing HTML quoting, this can result in security problems. "
"Never output data that was input by a user without quoting in HTML context. "
"The user could - for example - just insert a ``<script>`` tag, and it would "
"be output on the HTML page generated by OTRS."
msgstr ""
"由于缺少HTML引用，这可能导致安全问题。 永远不要输出用户输入的数据而不在HTML上"
"下文中引用。 例如，用户可以只插入一个 ``<script>`` 标签，它将在OTRS生成的HTML"
"页面上输出。"

#: ../../content/how-it-works/templates.rst:29
msgid ""
"Whenever possible, use ``[% Data.Name | html %]`` (in HTML) or ``[% Data."
"Name | uri %]`` (in links) instead."
msgstr ""
"尽可能使用 ``[％Data.Name | html％]`` （在HTML中）或 ``[％Data.Name | uri"
"％]`` （在链接中）。"

#: ../../content/how-it-works/templates.rst:31
msgid ""
"Example: Whenever we generate HTML in the application, we need to output it "
"to the template without HTML quoting, like ``<select>`` elements, which are "
"generated by the function ``Layout::BuildSelection()`` in OTRS."
msgstr ""
"示例：每当我们在应用程序中生成HTML时，我们需要将其输出到模板而不使用HTML引"
"用，例如 ``<select>`` 元素，这些元素由OTRS中的 ``Layout::BuildSelection()`` "
"函数生成。"

#: ../../content/how-it-works/templates.rst:38
msgid ""
"If you have data entries with complex names containing special characters, "
"you cannot use the dot (``.``) notation to access this data. Use ``item()`` "
"instead: ``[% Data.item('Complex-name') %]``."
msgstr ""
"如果您的数据条目包含包含特殊字符的复杂名称，则不能使用点（``.``）表示法来访问"
"此数据。 使用 ``item()`` 代替： ``[% Data.item('Complex-name') %]``。"

#: ../../content/how-it-works/templates.rst:42
msgid "``[% Data.Name | html %]``"
msgstr "``[% Data.Name | html %]``"

#: ../../content/how-it-works/templates.rst:44
msgid ""
"This command has the same function as the previous one, but it performs HTML "
"quoting on the data as it is inserted to the template."
msgstr "此命令与前一个命令具有相同的功能，但它在插入模板时对数据执行HTML引用。"

#: ../../content/how-it-works/templates.rst:50
msgid ""
"It's also possible specify a maximum length for the value. If, for example, "
"you just want to show 8 characters of a variable (result will be "
"*SomeName[...]*), use the following:"
msgstr ""
"也可以指定值的最大长度。 例如，如果您只想显示变量的8个字符（结果将是 "
"*SomeName[...]*），请使用以下命令："

#: ../../content/how-it-works/templates.rst:58
msgid "``[% Data.Name | uri %]``"
msgstr "``[% Data.Name | uri %]``"

#: ../../content/how-it-works/templates.rst:60
msgid ""
"This command performs `URL encoding <http://en.wikipedia.org/wiki/Percent-"
"encoding>`__ on the data as it is inserted to the template. This should be "
"used to output single parameter names or values of URLs, to prevent security "
"problems. It cannot be used for complete URLs because it will also mask "
"``=``, for example."
msgstr ""
"此命令在插入模板时对数据执行 `URL编码 <http://en.wikipedia.org/wiki/Percent-"
"encoding>`__。 这应该用于输出单个参数名称或URL值，以防止出现安全问题。 它不能"
"用于完整的URL，因为它也会掩盖 ``=``。"

#: ../../content/how-it-works/templates.rst:69
msgid "``[% Data.Name | JSON %]``"
msgstr "``[% Data.Name | JSON %]``"

#: ../../content/how-it-works/templates.rst:71
msgid ""
"This command outputs a string or another data structure as a JavaScript JSON "
"string."
msgstr "此命令将字符串或其它数据结构输出为JavaScript JSON字符串。"

#: ../../content/how-it-works/templates.rst:77
msgid ""
"Please note that the filter notation will only work for simple strings. To "
"output complex data as JSON, please use it as a function:"
msgstr ""
"请注意，过滤符号仅适用于简单字符串。 要将复杂数据输出为JSON，请将其用作函数："

#: ../../content/how-it-works/templates.rst:85
msgid "``[% Env() %]``"
msgstr "``[% Env() %]``"

#: ../../content/how-it-works/templates.rst:87
msgid ""
"Inserts environment variables provided by the ``LayoutObject``. Some "
"examples:"
msgstr "插入由 ``LayoutObject`` 提供的环境变量。 一些例子："

#: ../../content/how-it-works/templates.rst:93
msgid "Some other common predefined variables are:"
msgstr "其它一些常见的预定义变量是："

#: ../../content/how-it-works/templates.rst:95
msgid "``[% Env(\"Action\") %]``: the current action"
msgstr "``[% Env(\"Action\") %]``: 当前操作"

#: ../../content/how-it-works/templates.rst:96
msgid ""
"``[% Env(\"Baselink\") %]``: the baselink, e. g. ``index.pl?SessionID=...``"
msgstr "``[% Env(\"Baselink\") %]``: 基链接，如 ``index.pl?SessionID=...``"

#: ../../content/how-it-works/templates.rst:97
msgid "``[% Env(\"CGIHandle\") %]``: the current CGI handle e. g. ``index.pl``"
msgstr "``[% Env(\"CGIHandle\") %]``: 当前CGI句柄，如 ``index.pl``"

#: ../../content/how-it-works/templates.rst:98
msgid "``[% Env(\"SessionID\") %]``: the current session id"
msgstr "``[% Env(\"SessionID\") %]``: 当前会话ID"

#: ../../content/how-it-works/templates.rst:99
msgid ""
"``[% Env(\"Time\") %]``: the current time e. g. *Thu Dec 27 16:00:55 2001*"
msgstr "``[% Env(\"Time\") %]``: 当前时间，如 *Thu Dec 27 16:00:55 2001*"

#: ../../content/how-it-works/templates.rst:100
msgid "``[% Env(\"UserFullname\") %]``: e. g. Dirk Seiffert"
msgstr "``[% Env(\"UserFullname\") %]``: 用户全名，如 Dirk Seiffert"

#: ../../content/how-it-works/templates.rst:101
msgid "``[% Env(\"UserIsGroup[admin]\") %]``: Yes"
msgstr "``[% Env(\"UserIsGroup[admin]\") %]``: 用户是admin组成员"

#: ../../content/how-it-works/templates.rst:102
msgid ""
"``[% Env(\"UserIsGroup[users]\") %]``: Yes, user groups (useful for own "
"links)"
msgstr ""
"``[% Env(\"UserIsGroup[users]\") %]``: 用户是users组成员（对自己的链接有用）"

#: ../../content/how-it-works/templates.rst:103
msgid "``[% Env(\"UserLogin\") %]``: e. g. mgg@x11.org"
msgstr "``[% Env(\"UserLogin\") %]``: 用户登录名，如 mgg@x11.org"

#: ../../content/how-it-works/templates.rst:109
#: ../../content/how-it-works/templates.rst:139
msgid "Don't forget to add the ``| html`` filter where appropriate."
msgstr "别忘了添加适当的 ``| html`` 过滤器。"

#: ../../content/how-it-works/templates.rst:113
msgid "``[% Config() %]``"
msgstr "``[% Config() %]``"

#: ../../content/how-it-works/templates.rst:115
msgid ""
"Inserts configuration variables into the template. Let's see an example "
"``Kernel/Config.pm``:"
msgstr "将配置变量插入模板。 让我们看一个示例 ``Kernel/Config.pm``："

#: ../../content/how-it-works/templates.rst:128
msgid "To output values from it in the template, use:"
msgstr "要在模板中输出它的值，请使用："

#: ../../content/how-it-works/templates.rst:137
msgid ""
"Because of the missing HTML quoting, this can result in security problems."
msgstr "由于缺少HTML引用，这可能导致安全问题。"

#: ../../content/how-it-works/templates.rst:143
msgid "Localization Commands"
msgstr "本地化命令"

#: ../../content/how-it-works/templates.rst:147
msgid "``[% Translate() %]``"
msgstr "``[% Translate() %]``"

#: ../../content/how-it-works/templates.rst:149
msgid ""
"Translates a string into the current user's selected language. If no "
"translation is found, the original string will be used."
msgstr "将字符串转换为当前用户的选定语言。 如果未找到翻译，将使用原始字符串。"

#: ../../content/how-it-works/templates.rst:155
msgid "You can also translate dynamic data by using ``Translate`` as a filter:"
msgstr "您还可以使用 ``Translate`` 作为过滤器来翻译动态数据："

#: ../../content/how-it-works/templates.rst:161
msgid ""
"You can also specify one or more parameters (``%s``) inside of the string "
"which should be replaced with dynamic data:"
msgstr ""
"您还可以在字符串内指定一个或多个参数（``％s``），这些参数应替换为动态数据："

#: ../../content/how-it-works/templates.rst:167
msgid ""
"Strings in JavaScript can be translated and processed with the JSON filter."
msgstr "JavaScript中的字符串可以使用JSON过滤器进行翻译和处理。"

#: ../../content/how-it-works/templates.rst:175
msgid "``[% Localize() %]``"
msgstr "``[% Localize() %]``"

#: ../../content/how-it-works/templates.rst:177
msgid "Outputs data according to the current language/locale."
msgstr "根据当前语言/区域设置输出数据。"

#: ../../content/how-it-works/templates.rst:179
msgid ""
"In different cultural areas, different convention for date and time "
"formatting are used. For example, what is the 01.02.2010 in Germany, would "
"be 02/01/2010 in the USA. ``[% Localize() %]`` abstracts this away from the "
"templates. Let's see an example:"
msgstr ""
"在不同的文化区域中，使用不同的日期和时间格式约定。 例如，在德国是01.02.2010，"
"而在美国是02/01/2010。 ``[% Localize() %]`` 从模板中抽象出来。 我们来看一个例"
"子："

#: ../../content/how-it-works/templates.rst:187
msgid ""
"First, the data is inserted from the application module with ``Data``. Here "
"always an ISO UTC timestamp (2010-06-09 15:45:41) must be passed as data to "
"``[% Localize() %]``. Then it will be output it according to the date/time "
"definition of the current locale."
msgstr ""
"首先，使用 ``Data`` 从应用程序模块插入数据。 这里始终必须将ISO UTC时间戳"
"（2010-06-09 15:45:41）作为数据传递给 ``[% Localize() %]``。 然后根据当前语言"
"环境的日期/时间定义输出它。"

#: ../../content/how-it-works/templates.rst:189
msgid ""
"The data passed to ``[% Localize() %]`` must be UTC. If a time zone offset "
"is specified for the current agent, it will be applied to the UTC timestamp "
"before the output is generated."
msgstr ""
"传递给 ``[% Localize() %]`` 的数据必须是UTC。 如果为当前服务人员指定了时区偏"
"移量，则会在生成输出之前将其应用于UTC时间戳。"

#: ../../content/how-it-works/templates.rst:191
msgid ""
"There are different possible date/time output formats: ``TimeLong`` (full "
"date/time), ``TimeShort`` (no seconds) and ``Date`` (no time)."
msgstr ""
"有不同的日期/时间输出格式：``TimeLong`` （完整日期/时间）、``TimeShort`` （没"
"有秒）和``Date``（没有时间）。"

#: ../../content/how-it-works/templates.rst:207
msgid ""
"Also the output of human readable file sizes is available as an option "
"``Localize('Filesize')`` (just pass the raw file size in bytes)."
msgstr ""
"此外，人类可读文件大小的输出可用``Localize('Filesize')`` （只传递原始文件大"
"小，以字节为单位）选项设置。"

#: ../../content/how-it-works/templates.rst:217
msgid "``[% ReplacePlaceholders() %]``"
msgstr "``[% ReplacePlaceholders() %]``"

#: ../../content/how-it-works/templates.rst:219
msgid "Replaces placeholders (``%s``) in strings with passed parameters."
msgstr "用传递的参数替换字符串中的占位符（``％s``）。"

#: ../../content/how-it-works/templates.rst:221
msgid ""
"In certain cases, you might want to insert HTML code in translations, "
"instead of placeholders. On the other hand, you also need to take care of "
"sanitization, since translated strings should not be trusted as-is. For "
"this, you can first translate the string, pass it through the HTML filter "
"and finally replace placeholders with static (safe) HTML code."
msgstr ""
"在某些情况下，您可能希望在翻译中插入HTML代码，而不是占位符。 另一方面，您还需"
"要处理清理，因为翻译的字符串不应该被原样信任。 为此，您可以先转换字符串，将其"
"传递给HTML过滤器，最后用静态（安全）HTML代码替换占位符。"

#: ../../content/how-it-works/templates.rst:227
msgid ""
"Number of parameters to ``ReplacePlaceholders()`` filter should match number "
"of placeholders in the original string."
msgstr ""
"``ReplacePlaceholders()`` 过滤器的参数数量应与原始字符串中的占位符数相匹配。"

#: ../../content/how-it-works/templates.rst:229
msgid ""
"You can also use ``[% ReplacePlaceholders() %]`` in function format, in case "
"you are not translating anything. In this case, first parameter is the "
"target string, and any found placeholders in it are substituted with "
"subsequent parameters."
msgstr ""
"您也可以在函数格式中使用 ``[％ReplacePlaceholders()％]``，以防您没有翻译任何"
"内容。 在这种情况下，第一个参数是目标字符串，其中任何找到的占位符都替换为后续"
"参数。"

#: ../../content/how-it-works/templates.rst:237
msgid "Template Processing Commands"
msgstr "模板处理命令"

#: ../../content/how-it-works/templates.rst:241
msgid "Comment"
msgstr "注释"

#: ../../content/how-it-works/templates.rst:243
msgid ""
"Lines starting with a # at the beginning of will not be shown in the html "
"output. This can be used both for commenting the Template code or for "
"disabling parts of it."
msgstr ""
"以＃开头的行不会显示在html输出中。 这既可用于注释模板代码，也可用于禁用部分模"
"板代码。"

#: ../../content/how-it-works/templates.rst:254
msgid "``[% InsertTemplate(\"Copyright.tt\") %]``"
msgstr "``[% InsertTemplate(\"Copyright.tt\") %]``"

#: ../../content/how-it-works/templates.rst:258
msgid ""
"Please note that the ``InsertTemplate`` command was added to provide better "
"backwards compatibility to the old DTL system. It might be deprecated in a "
"future version of OTRS and removed later. If you don't use block commands in "
"your included template, you don't need ``InsertTemplate`` and can use "
"standard Template::Toolkit syntax like ``INCLUDE/PROCESS`` instead."
msgstr ""
"请注意，添加了 ``InsertTemplate`` 命令以提供与旧DTL系统更好的向后兼容性。 它"
"可能会在未来的OTRS版本中弃用，并在以后删除。 如果你不在包含的模板中使用块命"
"令，则不需要 ``InsertTemplate`` 并且可以使用标准的Template::Toolkit语法，例"
"如 ``INCLUDE/PROCESS``。"

#: ../../content/how-it-works/templates.rst:260
msgid ""
"Includes another template file into the current one. The included file may "
"also contain template commands."
msgstr "将另一个模板文件包含到当前模板中。 包含的文件也可能包含模板命令。"

#: ../../content/how-it-works/templates.rst:267
msgid ""
"Please note this is not the same as Template::Toolkit's ``[% INCLUDE %]`` "
"command, which just processes the referenced template. ``[% InsertTemplate() "
"%]`` actually adds the content of the referenced template into the current "
"template, so that it can be processed together. That makes it possible for "
"the embedded template to access the same environment/data as the main "
"template."
msgstr ""
"请注意，这与Template::Toolkit的 ``[% INCLUDE %]`` 命令不同，后者只处理引用的"
"模板。 ``[% InsertTemplate() %]`` 实际上将引用模板的内容添加到当前模板中，以"
"便可以一起处理它。 这使得嵌入式模板可以访问与主模板相同的环境/数据。"

#: ../../content/how-it-works/templates.rst:271
msgid "``[% RenderBlockStart %]`` / ``[% RenderBlockEnd %]``"
msgstr "``[% RenderBlockStart %]`` / ``[% RenderBlockEnd %]``"

#: ../../content/how-it-works/templates.rst:275
msgid ""
"Please note that the blocks commands were added to provide better backwards "
"compatibility to the old DTL system. They might be deprecated in a future "
"version of OTRS and removed later. We advise you to develop any new code "
"without using the blocks commands. You can use standard Template::Toolkit "
"syntax like ``IF/ELSE``, ``LOOP`` and other helpful things for conditional "
"template output."
msgstr ""
"请注意，添加了块命令以提供与旧DTL系统更好的向后兼容性。 它们可能在将来的OTRS"
"版本中被弃用，稍后会被删除。 我们建议您在不使用blocks命令的情况下开发任何新代"
"码。 您可以使用标准的Template::Toolkit语法，如 ``IF/ELSE``、``LOOP`` 以及条件"
"模板输出的其它有用的东西。"

#: ../../content/how-it-works/templates.rst:277
msgid ""
"With this command, one can specify parts of a template file as a block. This "
"block needs to be explicitly filled with a function call from the "
"application, to be present in the generated output. The application can call "
"the block 0 (it will not be present in the output), 1 or more times (each "
"with possibly a different set of data parameters passed to the template)."
msgstr ""
"使用此命令，可以将模板文件的某些部分指定为块。 需要使用来自应用程序的函数调用"
"显式填充此块，以使其出现在生成的输出中。 应用程序可以调用块0次（它不会出现在"
"输出中）、1次或多次（每次都可能有一组不同的数据参数传递给模板）。"

#: ../../content/how-it-works/templates.rst:279
msgid "One common use case is the filling of a table with dynamic data:"
msgstr "一个常见的用例是使用动态数据填充表："

#: ../../content/how-it-works/templates.rst:316
msgid ""
"The surrounding table with the header is always generated. If no data was "
"found, the block ``NoDataFoundMsg`` is called once, resulting in a table "
"with one data row with the message *No data found*."
msgstr ""
"始终生成带有标题的完整表。 如果没有找到数据，则会调用块 ``NoDataFoundMsg`` 一"
"次，从而产生一个包含一个数据行的表，显示消息 *没有找到数据*。"

#: ../../content/how-it-works/templates.rst:318
msgid ""
"If data was found, for each row there is one function call made for the "
"block ``OverViewResultRow`` (each time passing in the data for this "
"particular row), resulting in a table with as many data rows as results were "
"found."
msgstr ""
"如果找到数据，则对于每一行，都会对 ``OverViewResultRow`` 块进行一次函数调用"
"（每次传入此特定行的数据），从而得到一个表，包含与找到结果一样多的数据行。"

#: ../../content/how-it-works/templates.rst:320
msgid "Let's look at how the blocks are called from the application module:"
msgstr "让我们看看如何从应用程序模块调用块："

#: ../../content/how-it-works/templates.rst:355
msgid ""
"Note how the blocks have both their name and an optional set of data passed "
"in as separate parameters to the block function call. Data inserting "
"commands inside a block always need the data provided to the block function "
"call of this block, not the general template rendering call."
msgstr ""
"注意块如何将它们的名称和一组可选数据作为单独的参数传递给块函数调用。 块内的数"
"据插入命令总是需要提供给该块的块函数调用的数据，而不是一般的模板渲染调用。"

#: ../../content/how-it-works/templates.rst:361
msgid "``[% WRAPPER JSOnDocumentComplete %]...[% END %]``"
msgstr "``[% WRAPPER JSOnDocumentComplete %]...[% END %]``"

#: ../../content/how-it-works/templates.rst:363
msgid ""
"Marks JavaScript code which should be executed after all CSS, JavaScript and "
"other external content has been loaded and the basic JavaScript "
"initialization was finished. Again, let's look at an example:"
msgstr ""
"标记在加载所有CSS、JavaScript和其它外部内容并完成基本JavaScript初始化之后应执"
"行的JavaScript代码。 让我们再看一个例子："

#: ../../content/how-it-works/templates.rst:392
msgid ""
"This snippet creates a small form and puts an ``onchange`` handler on the "
"``<select>`` element which triggers an AJAX based form update."
msgstr ""
"这个片段创建一个小型表单，并在 ``<select>`` 元素上放置一个 ``onchange`` 处理"
"程序，触发基于AJAX的表单更新。"

#: ../../content/how-it-works/templates.rst:394
msgid ""
"Why is it necessary to enclose the JavaScript code in ``[% WRAPPER "
"JSOnDocumentComplete %]...[% END %]``? JavaScript loading was moved to the "
"footer part of the page for performance reasons. This means that within the "
"``<body>`` of the page, no JavaScript libraries are loaded yet. With ``[% "
"WRAPPER JSOnDocumentComplete %]...[% END %]`` you can make sure that this "
"JavaScript is moved to a part of the final HTML document, where it will be "
"executed only after the entire external JavaScript and CSS content has been "
"successfully loaded and initialized."
msgstr ""
"为什么有必要将JavaScript代码包含在 ``[% WRAPPER JSOnDocumentComplete %]...[% "
"END %]`` 中？ 出于性能原因，JavaScript加载已移至页面的页脚部分。 这意味着在页"
"面的 ``<body>`` 中，还没有加载任何JavaScript库。 使用 ``[% WRAPPER "
"JSOnDocumentComplete %]...[% END %]``，您可以确保将此JavaScript移动到最终HTML"
"文档的一部分，只有在整个外部JavaScript和CSS内容已成功加载和初始化之后才能执行"
"它。"

#: ../../content/how-it-works/templates.rst:396
msgid ""
"Inside the ``[% WRAPPER JSOnDocumentComplete %]...[% END %]`` block, you can "
"use ``<script>`` tags to enclose your JavaScript code, but you do not have "
"to do so. It may be beneficial because it will enable correct syntax "
"highlighting in IDEs which support it."
msgstr ""
"在 ``[% WRAPPER JSOnDocumentComplete %]...[% END %]`` 块中，您可以使用 "
"``<script>`` 标签来封装您的JavaScript代码，但您不必这样做。 这可能是有益的，"
"因为它将在支持它的IDE中启用正确的语法突出显示。"

#: ../../content/how-it-works/templates.rst:400
msgid "Using a Template File"
msgstr "使用一个模板文件"

#: ../../content/how-it-works/templates.rst:402
msgid ""
"Ok, but how to actually process a template file and generate the result? "
"This is really simple:"
msgstr "好了，那如何实际处理模板文件并生成结果呢？这很简单："

#: ../../content/how-it-works/templates.rst:412
msgid ""
"In the front end modules, the ``Output()`` function of ``Kernel::Output::"
"HTML::Layout`` is called (after all the needed blocks have been called in "
"this template) to generate the final output. An optional set of data "
"parameters is passed to the template, for all data inserting commands which "
"are not inside of a block."
msgstr ""
"在前端模块中，调用 ``Kernel::Output::HTML::Layout`` 的 ``Output()`` 函数（在"
"该模板中调用了所有需要的块之后），以生成最终输出。对于不在块内的所有数据插入"
"命令，将向模板传递一组可选的数据参数。"

#: ../../content/how-it-works/themes.rst:2
msgid "Creating Your Own Themes"
msgstr "创建你自己的主题"

#: ../../content/how-it-works/themes.rst:4
msgid ""
"You can create your own themes so as to use the layout you like in the OTRS "
"web front end. To create custom themes, you should customize the output "
"templates to your needs. More information on the syntax and structure of "
"output templates can be found in the :doc:`templates`."
msgstr ""
"您可以创建自己的主题，以便使用您喜欢的OTRS Web前端布局。要创建自定义主题，应"
"根据需要自定义输出模板。有关输出模板语法和结构的详细信息，请参见 :doc:"
"`templates`。"

#: ../../content/how-it-works/themes.rst:6
msgid ""
"As an example, perform the following steps to create a new theme called "
"*Company*:"
msgstr "例如，执行以下步骤创建名为 *Company* 的新主题："

#: ../../content/how-it-works/themes.rst:8
msgid ""
"Create a directory called ``Kernel/Output/HTML/Templates/Company`` and copy "
"all files that you like to change from ``Kernel/Output/HTML/Templates/"
"Standard`` into the new folder."
msgstr ""
"创建一个名为 ``Kernel/Output/HTML/Templates/Company`` 的目录，并将您想要更改"
"的所有文件从 ``Kernel/Output/HTML/Templates/Standard`` 复制到新文件夹中。"

#: ../../content/how-it-works/themes.rst:12
msgid ""
"Only copy over the files you're planning to change. OTRS will automatically "
"get the missing files from the Standard theme. This will make upgrading at a "
"later stage much easier."
msgstr ""
"仅复制您计划更改的文件。 OTRS将自动从标准主题中获取缺失的文件。 这将使后期升"
"级变得更加容易。"

#: ../../content/how-it-works/themes.rst:14
msgid ""
"Customize the files in the directory ``Kernel/Output/HTML/Templates/"
"Company`` and change the layout to your needs."
msgstr ""
"定制 ``Kernel/Output/HTML/Templates/Company`` 目录中的文件，并根据需要更改布"
"局。"

#: ../../content/how-it-works/themes.rst:15
msgid ""
"To activate the new theme, add them in system configuration under "
"``Frontend::Themes``."
msgstr "要激活新主题，请在系统配置 ``Frontend::Themes`` 中添加它们。"

#: ../../content/how-it-works/themes.rst:17
msgid ""
"Now the new theme should be usable. You can select it via your personal "
"preferences."
msgstr "现在应该可用新主题了。 您可以通过个人首选项选择它。"

#: ../../content/how-it-works/themes.rst:21
msgid ""
"Do not change the theme files shipped with OTRS, since these changes will be "
"lost after an update. Create your own themes only by performing the steps "
"described above."
msgstr ""
"不要直接修改OTRS自带的主题文件，因为这些更改在OTRS升级后会丢失。只需按上述步"
"骤创建你自己的主题就行了。"

#: ../../content/how-it-works/translations.rst:2
msgid "Localization / Translation Mechanism"
msgstr "本地化/翻译机制"

#: ../../content/how-it-works/translations.rst:4
msgid ""
"There are four steps needed to translate / localize software: marking "
"localizable strings in the source files, generating the translation database/"
"file, the translation process itself, and the usage of translated data "
"within the code."
msgstr ""
"翻译/本地化软件需要四个步骤：在源文件中标记可本地化的字符串、生成翻译数据库/"
"文件、翻译过程本身以及在代码中使用翻译的数据。"

#: ../../content/how-it-works/translations.rst:7
msgid "Marking Translatable Strings in the Source Files"
msgstr "在源文件中标记可翻译字符串"

#: ../../content/how-it-works/translations.rst:9
msgid ""
"In Perl code, all literal strings to be translated are automatically marked "
"for translation:"
msgstr "在Perl代码中，所有要翻译的文字字符串都会自动标记为翻译："

#: ../../content/how-it-works/translations.rst:15
msgid ""
"This will mark *My string %s* for translation. If you need to mark strings, "
"but NOT translate them in the code yet, you can use the NOOP method "
"``Kernel::Langauge::Translatable()``."
msgstr ""
"这将标记为 *My string %s* 进行翻译。 如果你需要标记字符串，但尚未在代码中翻译"
"它们，你可以使用NOOP方法 ``Kernel::Langauge::Translatable()``。"

#: ../../content/how-it-works/translations.rst:30
msgid ""
"In template files, all literal strings enclosed in the ``Translate()`` tag "
"are automatically marked for extraction: ``[% Translate('My string %s', Data."
"Data )%]``."
msgstr ""
"在模板文件中，所有包含在 ``Translate()`` 标签中的文字字符串都会自动标记以便提"
"取：``[% Translate('My string %s', Data.Data )%]``。"

#: ../../content/how-it-works/translations.rst:33
msgid ""
"In system configuration and database XML files you can mark strings for "
"extraction with the ``Translatable=\"1\"`` attribute."
msgstr ""
"在系统配置和数据库XML文件中，您可以使用 ``Translatable=\"1\"`` 属性标记要提取"
"的字符串。"

#: ../../content/how-it-works/translations.rst:55
msgid "Collecting Translatable Strings Into The Translation Database"
msgstr "将可翻译字符串收集到翻译数据库中"

#: ../../content/how-it-works/translations.rst:57
msgid ""
"The console command ``otrs.Console.pl Dev::Tools::TranslationsUpdate`` is "
"used to extract all translatable strings from the source files. These will "
"be collected and written into the translation files."
msgstr ""
"控制台命令 ``otrs.Console.pl Dev::Tools::TranslationsUpdate`` 用于从源文件中"
"提取所有可翻译的字符串。 这些将被收集并写入翻译文件。"

#: ../../content/how-it-works/translations.rst:59
msgid ""
"For the OTRS framework and all extension modules, ``.pot`` and ``.po`` files "
"are written. These files are used by translators to localize the software."
msgstr ""
"对于OTRS框架和所有扩展模块，都会编写 ``.pot`` 和 ``.po`` 文件。 这些文件由翻"
"译人员用于本地化软件。"

#: ../../content/how-it-works/translations.rst:61
msgid ""
"But OTRS requires the translations to be in Perl files for speed reasons. "
"These files will also be generated by ``otrs.Console.pl Dev::Tools::"
"TranslationsUpdate``. There are two different translation cache file types "
"which are used in the following order. If a word/sentence is redefined in a "
"translation file, the last definition will be used."
msgstr ""
"但出于速度原因，OTRS要求翻译出现在Perl文件中。 这些文件也将由 ``otrs.Console."
"pl Dev::Tools::TranslationsUpdate`` 生成。 有两种不同的转换缓存文件类型，按以"
"下顺序使用。 如果在翻译文件中重新定义了单词/句子，则将使用最后一个定义的。"

#: ../../content/how-it-works/translations.rst:63
msgid "Default framework translation file: ``Kernel/Language/$Language.pm``"
msgstr "默认的框架翻译文件：``Kernel/Language/$Language.pm``"

#: ../../content/how-it-works/translations.rst:64
msgid "Custom translation file: ``Kernel/Language/$Language_Custom.pm``"
msgstr "自定义的翻译文件：``Kernel/Language/$Language_Custom.pm``"

#: ../../content/how-it-works/translations.rst:68
msgid "Default Framework Translation File"
msgstr "默认的框架翻译文件"

#: ../../content/how-it-works/translations.rst:70
msgid ""
"The default framework translation file includes the basic translations. The "
"following is an example of a default framework translation file."
msgstr ""
"默认的框架翻译文件包括基本的翻译。 下面是一个默认的框架翻译文件的一个例子。"

#: ../../content/how-it-works/translations.rst:112
msgid "Custom Translation File"
msgstr "自定义的翻译文件"

#: ../../content/how-it-works/translations.rst:114
msgid ""
"The custom translation file is read out last and so its translation which "
"will be used. If you want to add your own wording to your installation, "
"create this file for your language."
msgstr ""
"自定义翻译文件最后读出并使用其翻译。 如果要在安装中添加自己的措辞，请为您的语"
"言创建此文件。"

#: ../../content/how-it-works/translations.rst:142
msgid ""
"The language files for the new interface are now part of the built "
"application (static JSON). When you add a custom language file to the file "
"system, you need to rebuild the application for the change to be considered. "
"To trigger the rebuild, restart the server with the ``--deploy-assets`` "
"option:"
msgstr ""
"新接口的语言文件现在是构建应用程序（静态JSON）的一部分。将自定义语言文件添加"
"到文件系统时，需要重新生成应用程序以使更改生效。要触发重建，请使用 ``--"
"deploy-assets`` 选项重新启动服务器："

#: ../../content/how-it-works/translations.rst:148
msgid ""
"During the build process, the language files will be refreshed and will take "
"any ``*_Custom.pm`` into account."
msgstr "在构建过程中，语言文件将被刷新，任何 ``*_Custom.pm`` 都会被处理。"

#: ../../content/how-it-works/translations.rst:152
msgid "The Translation Process Itself"
msgstr "翻译过程本身"

#: ../../content/how-it-works/translations.rst:154
msgid ""
"OTRS uses `Weblate <https://translate.otrs.com/>`__ to manage the "
"translation process. Please see :doc:`../contributing/translate` section for "
"details."
msgstr ""
"OTRS使用 `Weblate <https://translate.otrs.com/>`__ 来管理翻译过程。 有关详细"
"信息，请参阅 :doc:`../contributing/translate` 部分。"

#: ../../content/how-it-works/translations.rst:158
msgid "Using The Translated Data From The Code"
msgstr "使用代码中的翻译数据"

#: ../../content/how-it-works/translations.rst:160
msgid ""
"You can use the method ``$LanguageObject->Translate()`` to translate strings "
"at runtime from Perl code, and the ``Translate()`` tag in :doc:`templates`."
msgstr ""
"您可以使用 ``$LanguageObject->Translate()`` 方法在运行时从Perl代码翻译字符"
"串，在 :doc:`templates` 中使用 ``Translate()`` 标记。"

#: ../../content/how-to-extend-otrs.rst:2
msgid "How to Extend OTRS"
msgstr "如何扩展OTRS"

#: ../../content/how-to-extend-otrs/otrs-module-layers.rst:2
msgid "Using the power of the OTRS module layers"
msgstr "使用OTRS模块层的功能"

#: ../../content/how-to-extend-otrs/otrs-module-layers.rst:4
msgid ""
"OTRS has a large number of so-called *module layers* which make it very easy "
"to extend the system without patching existing code. One example is the "
"number generation mechanism for tickets. It is a *module layer* with "
"pluggable modules, and you can add your own custom number generator modules "
"if you wish to do so. Let's look at the different layers in detail!"
msgstr ""
"OTRS具有大量所谓的 *模块层*，这使得在不修补现有代码的情况下扩展系统变得非常容"
"易。 一个例子是工单的数字生成机制。 它是一个带有可插拔模块的 *模块层*，如果您"
"愿意，可以添加自己的自定义数字生成器模块。 让我们详细看看不同的层！"

#: ../../content/how-to-extend-otrs/otrs-module-layers.rst:6
msgid "Authentication and User Management"
msgstr "身份验证和用户管理"

#: ../../content/how-to-extend-otrs/otrs-module-layers.rst:14
msgid "Preferences"
msgstr "首选项"

#: ../../content/how-to-extend-otrs/otrs-module-layers.rst:23
msgid "Other Core Functions"
msgstr "其它核心功能"

#: ../../content/how-to-extend-otrs/otrs-module-layers.rst:50
msgid "Daemon And Scheduler"
msgstr "守护进程和调度程序"

#: ../../content/how-to-extend-otrs/otrs-module-layers.rst:57
msgid "Dynamic Fields"
msgstr "动态字段"

#: ../../content/how-to-extend-otrs/otrs-module-layers.rst:68
msgid "Email Handling"
msgstr "邮件处理"

#: ../../content/how-to-extend-otrs/otrs-module-layers.rst:74
#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:2
msgid "Process Management"
msgstr "流程管理"

#: ../../content/how-to-extend-otrs/otrs-module-layers/agent-auth.rst:2
msgid "Agent Authentication Module"
msgstr "服务人员身份验证模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/agent-auth.rst:4
msgid ""
"There are several agent authentication modules (DB, LDAP and HTTPBasicAuth) "
"which come with the OTRS framework. It is also possible to develop your own "
"authentication modules. The agent authentication modules are located under "
"``Kernel/System/Auth/*.pm``. For more information about their configuration "
"see the admin manual. Following, there is an example of a simple agent auth "
"module. Save it under ``Kernel/System/Auth/Simple.pm``. You just need 3 "
"functions: ``new()``, ``GetOption()`` and ``Auth()``. Return the uid, then "
"the authentication is ok."
msgstr ""
"OTRS框架附带了几个服务人员身份验证模块（DB、LDAP和HTTPBasicAuth）。 您也可以"
"开发自己的身份验证模块。服务人员验证模块位于 ``Kernel/System/Auth/*.pm``。 有"
"关其配置的更多信息，请参阅管理员手册。 下面是一个简单服务人员验证模块的示"
"例。 将它保存为 ``Kernel/System/Auth/Simple.pm``。 你只需要3个函数："
"``new()``、 ``GetOption()`` 和 ``Auth()``。 返回uid，然后验证就可以了。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/agent-auth.rst:8
msgid "Agent Authentication Module Code Example"
msgstr "服务人员身份验证模块代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/agent-auth.rst:10
msgid ""
"The interface class is called ``Kernel::System::Auth``. The example agent "
"authentication may be called ``Kernel::System::Auth::CustomAuth``. You can "
"find an example below."
msgstr ""
"接口类称为 ``Kernel::System::Auth``。 示例服务人员身份验证可以叫做 ``Kernel::"
"System::Auth::CustomAuth``。 你可以在下面找到一个例子。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/agent-auth.rst:157
msgid "Agent Authentication Module Configuration Example"
msgstr "服务人员身份验证模块配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/agent-auth.rst:159
msgid ""
"There is the need to activate your custom agent authenticate module. This "
"can be done using the Perl configuration below. It is not recommended to use "
"the XML configuration because you can lock you out via the system "
"configuration."
msgstr ""
"需要激活自定义服务人员身份验证模块。 这可以使用下面的Perl配置来完成。 建议不"
"要使用XML配置，因为您可能通过系统配置将您关在外面。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/agent-auth.rst:167
msgid "Agent Authentication Module Use Case Example"
msgstr "服务人员身份验证模块用例示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/agent-auth.rst:169
msgid ""
"A useful example of an authentication implementation could be a SOAP back "
"end."
msgstr "身份验证实现的有用示例可以是一个SOAP后端。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/auth-sync.rst:2
msgid "Authentication Synchronization Module"
msgstr "身份验证同步模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/auth-sync.rst:4
msgid ""
"There is an LDAP authentication synchronization module which come with the "
"OTRS framework. It is also possible to develop your own authentication "
"modules. The authentication synchronization modules are located under "
"``Kernel/System/Auth/Sync/*.pm``. For more information about their "
"configuration see the admin manual. Following, there is an example of an "
"authentication synchronization module. Save it under ``Kernel/System/Auth/"
"Sync/CustomAuthSync.pm``. You just need 2 functions: ``new()`` and "
"``Sync()``. Return 1, then the synchronization is ok."
msgstr ""
"OTRS框架自带有一个LDAP认证同步模块。 您也可以开发自己的身份验证模块。 认证同"
"步模块位于 ``Kernel/System/Auth/Sync/*.pm`` 下。 有关其配置的更多信息，请参阅"
"管理员手册。 下面是一个身份验证同步模块的示例。 将其保存在 ``Kernel/System/"
"Auth/Sync/CustomAuthSync.pm`` 下。 你只需要2个函数：``new()`` 和 "
"``Sync()``。 返回1，然后同步就可以了。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/auth-sync.rst:8
msgid "Authentication Synchronization Module Code Example"
msgstr "身份验证同步模块代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/auth-sync.rst:10
msgid ""
"The interface class is called ``Kernel::System::Auth``. The example agent "
"authentication may be called ``Kernel::System::Auth::Sync::CustomAuthSync``. "
"You can find an example below."
msgstr ""
"接口类称为 ``Kernel::System::Auth``。 示例服务人员身份验证可以叫做 ``Kernel::"
"System::Auth::Sync::CustomAuthSync``。 你可以在下面找到一个例子。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/auth-sync.rst:65
msgid "Authentication Synchronization Module Configuration Example"
msgstr "身份验证同步模块配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/auth-sync.rst:67
msgid ""
"You should activate your custom synchronization module. This can be done "
"using the Perl configuration below. It is not recommended to use the XML "
"configuration because this would allow you to lock yourself out via system "
"configuration."
msgstr ""
"您应该激活自定义同步模块。 这可以使用下面的Perl配置来完成。 建议不要使用XML配"
"置，因为您可能通过系统配置将您关在外面。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/auth-sync.rst:75
msgid "Authentication Synchronization Module Use Case Example"
msgstr "身份验证同步模块用例示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/auth-sync.rst:77
msgid ""
"Useful synchronization implementation could be a SOAP or RADIUS back end."
msgstr "同步实现的有用示例可以是一个SOAP或RADIUS后端。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-auth.rst:2
msgid "Customer Authentication Module"
msgstr "客户身份验证模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-auth.rst:4
msgid ""
"There are several customer authentication modules (DB, LDAP and "
"HTTPBasicAuth) which come with the OTRS framework. It is also possible to "
"develop your own authentication modules. The customer authentication modules "
"are located under ``Kernel/System/CustomerAuth/*.pm``. For more information "
"about their configuration see the admin manual. Following, there is an "
"example of a simple customer auth module. Save it under ``Kernel/System/"
"CustomerAuth/Simple.pm``. You just need 3 functions: ``new()``, "
"``GetOption()`` and ``Auth()``. Return the uid, then the authentication is "
"ok."
msgstr ""
"OTRS框架附带了几个客户身份验证模块（DB、LDAP和HTTPBasicAuth）。 您也可以开发"
"自己的身份验证模块。 客户认证模块位于 ``Kernel/System/CustomerAuth/*.pm`` "
"下。 有关其配置的更多信息，请参阅管理员手册。 下面是一个简单的客户验证模块的"
"示例。 将它保存为 ``Kernel/System/CustomerAuth/Simple.pm``。 你只需要3个函"
"数：``new()``、``GetOption()`` 和 ``Auth()``。 返回uid，然后验证就可以了。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-auth.rst:8
msgid "Customer Authentication Module Code Example"
msgstr "客户身份验证模块代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-auth.rst:10
msgid ""
"The interface class is called ``Kernel::System::CustomerAuth``. The example "
"customer authentication may be called ``Kernel::System::CustomerAuth::"
"CustomAuth``. You can find an example below."
msgstr ""
"接口类称为 ``Kernel::System::CustomerAuth``。 示例客户认证可以叫做 ``Kernel::"
"System::CustomerAuth::CustomAuth``。 你可以在下面找到一个例子。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-auth.rst:159
msgid "Customer Authentication Module Configuration Example"
msgstr "客户身份验证模块配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-auth.rst:161
msgid ""
"There is the need to activate your custom customer authenticate module. This "
"can be done using the XML configuration below."
msgstr "需要激活自定义客户身份验证模块。 这可以使用下面的XML配置来完成。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-auth.rst:176
msgid "Customer Authentication Module Use Case Example"
msgstr "客户身份验证模块用例示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-auth.rst:178
msgid "Useful authentication implementation could be a SOAP back end."
msgstr "有用的身份验证实现可以是一个SOAP后端。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-user-preferences.rst:2
msgid "Customer User Preferences Module"
msgstr "客户用户首选项模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-user-preferences.rst:4
msgid ""
"There is a DB customer-user preferences module which come with the OTRS "
"framework. It is also possible to develop your own customer-user preferences "
"modules. The customer-user preferences modules are located under ``Kernel/"
"System/CustomerUser/Preferences/*.pm``. For more information about their "
"configuration see the admin manual. Following, there is an example of a "
"customer-user preferences module. Save it under ``Kernel/System/CustomerUser/"
"Preferences/Custom.pm``. You just need 4 functions: ``new()``, "
"``SearchPreferences()``, ``SetPreferences()`` and ``GetPreferences()``."
msgstr ""
"OTRS框架自带有一个DB客户用户首选项模块。 您也可以开发自己的客户用户首选项模"
"块。 客户用户首选项模块位于 ``Kernel/System/CustomerUser/Preferences/*.pm`` "
"下。 有关其配置的更多信息，请参阅管理员手册。 下面是一个客户用户首选项模块的"
"示例。 将其保存为 ``Kernel/System/CustomerUser/Preferences/Custom.pm``。 你只"
"需要4个函数：``new()``、 ``SearchPreferences()``、 ``SetPreferences()`` 和 "
"``GetPreferences()``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-user-preferences.rst:8
msgid "Customer User Preferences Module Code Example"
msgstr "客户用户首选项模块代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-user-preferences.rst:10
msgid ""
"The interface class is called ``Kernel::System::CustomerUser``. The example "
"customer-user preferences may be called ``Kernel::System::CustomerUser::"
"Preferences::Custom``. You can find an example below."
msgstr ""
"接口类称为 ``Kernel::System::CustomerUser``。 示例客户用户首选项可以叫做 "
"``Kernel::System::CustomerUser::Preferences::Custom``。 你可以在下面找到一个"
"例子。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-user-preferences.rst:135
msgid "Customer User Preferences Module Configuration Example"
msgstr "客户用户首选项模块配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-user-preferences.rst:137
msgid ""
"There is the need to activate your custom customer-user preferences module. "
"This can be done using the XML configuration below."
msgstr "需要激活自定义客户用户首选项模块。 这可以使用下面的XML配置来完成。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-user-preferences.rst:162
msgid "Customer User Preferences Module Use Case Example"
msgstr "客户用户首选项模块用例示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/customer-user-preferences.rst:164
msgid "Useful preferences implementation could be a SOAP or LDAP back end."
msgstr "有用的首选项实现可以是一个SOAP或LDAP 后端。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:2
msgid "OTRS Daemon"
msgstr "OTRS守护进程"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:4
msgid ""
"The OTRS daemon is a separated process that helps OTRS to execute certain "
"actions asynchronously and detached of the web server process, but sharing "
"the same database."
msgstr ""
"OTRS守护进程是一个独立的进程，可帮助OTRS异步执行某些操作并独立于Web服务器进"
"程，但共享同一个数据库。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:8
msgid "OTRS Daemon Modules"
msgstr "OTRS守护进程模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:10
msgid ""
"The OTRS daemon ``bin/otrs.Daemon.pl`` main purpose is to call (daemonize) "
"all the registered daemon modules in the system configuration."
msgstr ""
"OTRS守护进程 ``bin/otrs.Daemon.pl`` 的主要目的是在系统配置中调用（守护进程）"
"所有已注册的守护进程模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:12
msgid ""
"Each daemon module must implement a common API in order to be correctly "
"called by the OTRS daemon and be a semi persistent process in the system. "
"Persistent process could grow in size and memory usage over the time and "
"normally they do not respond to changes in the configuration. That is why "
"the daemon modules should implement a discard mechanism to be stopped and re-"
"spawned again from time to time, freeing system resources and re-reading the "
"configuration."
msgstr ""
"每个守护程序模块必须实现一个通用API才能被OTRS守护程序正确调用，并且是系统中的"
"半持久进程。 持久化进程的大小和内存使用量会随着时间的推移而增长，通常它们不会"
"响应配置中的更改。 这就是为什么守护程序模块应该实现丢弃机制以便不时地中止并重"
"新生成，从而释放系统资源并重新读取配置。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:14
msgid ""
"A daemon module could be an all-in-one solution to perform a certain job, "
"but there could be the case that a solution requires different daemon "
"modules due to its complexity. That is exactly the case of the OTRS "
"scheduler daemon that is split into several daemon modules including some "
"daemon modules for task management and task execution."
msgstr ""
"守护进程模块可以是执行特定作业的一体化解决方案，但由于其复杂性，可能存在解决"
"方案需要不同守护进程模块的情况。 这正是OTRS调度程序守护进程的情况，它被分成几"
"个守护程序模块，包括用于任务管理和任务执行的一些守护进程模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:16
msgid ""
"It is not always necessary to create a new daemon module to perform certain "
"task, usually the OTRS scheduler daemon can deal with the majority of them, "
"either if it is an OTRS function that needs to be executed on a regular "
"basis (CRON like) or if it's triggered by an OTRS event, the OTRS scheduler "
"should be capable to deal with it out of the box or by adding a new "
"scheduler task worker module."
msgstr ""
"并不总是需要创建一个新的守护进程模块来执行某些任务，通常OTRS调度程序守护进程"
"可以处理它们中的大多数，如果它是需要定期执行的OTRS函数（类似CRON）或者 如果它"
"是由OTRS事件触发的，那么OTRS调度程序应该能够开箱即用或者通过添加新的调度程序"
"任务工作模块来处理它。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:20
msgid "Creating A New Daemon Module"
msgstr "创建一个新的守护进程模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:22
msgid ""
"All daemon modules requires to be registered in the system configuration in "
"order to be called by the main OTRS daemon."
msgstr "所有守护进程模块都需要在系统配置中注册，以便由主OTRS守护进程调用。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:26
msgid "Daemon Module Registration Code Example"
msgstr "守护进程模块注册代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:42
msgid "Daemon Module Code Example"
msgstr "守护进程模块代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:44
msgid ""
"The following code implements a daemon module that displays the system time "
"every 2 seconds."
msgstr "以下代码实现了一个守护进程模块，该模块每2秒显示一次系统时间。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:72
#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:61
#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:137
#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:260
#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:135
#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:72
#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:42
#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:67
#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:321
msgid ""
"This is common header that can be found in common OTRS modules. The class/"
"package name is declared via the ``package`` keyword."
msgstr ""
"这是可在常见OTRS模块中找到的通用标头。 类/包名称通过 ``package`` 关键字声明。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:74
msgid ""
"In this case we are inheriting from ``BaseDaemon`` class, and the object "
"manager dependencies are set."
msgstr "在这个例子中，我们继承自 ``BaseDaemon`` 类，并设置了对象管理器依赖项。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:107
msgid ""
"The constructor ``new`` creates a new instance of the class. Some used "
"objects are also created here. It is highly recommended to disable in-memory "
"cache in daemon modules especially if OTRS runs in a cluster environment."
msgstr ""
"构造函数 ``new`` 创建了一个新的类实例。 这里也创建了一些使用过的对象。 强烈建"
"议在守护进程模块中禁用内存高速缓存，尤其是在OTRS在集群环境中运行时。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:109
msgid ""
"In order to make this daemon module to be executed every two seconds it is "
"necessary to define a sleep time accordingly, otherwise it will be executed "
"as soon as possible."
msgstr ""
"为了使该守护进程模块每两秒执行一次，必须相应地定义休眠时间，否则将会尽快执"
"行。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:111
msgid ""
"Refreshing the daemon module from time to time is necessary in order to "
"define when it should be discarded."
msgstr "必须不时刷新守护进程模块，以便定义何时应该丢弃它。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:113
msgid ""
"For the following functions (``PreRun``, ``Run`` and ``PostRun``) if they "
"return false, the main OTRS daemon will discard the object and create a new "
"one as soon as possible."
msgstr ""
"对于以下函数（``PreRun``、``Run`` 和 ``PostRun``）如果它们返回false，主OTRS守"
"护进程将丢弃该对象并尽快创建一个新对象。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:128
msgid ""
"The ``PreRun`` method is executed before the main daemon module method, and "
"the its purpose is to perform some test before the real operation. In this "
"case a check to the database is done (always recommended), otherwise it "
"sleeps for 10 seconds. This is needed in order to wait for DB connection to "
"be reestablished."
msgstr ""
"``PreRun`` 方法在主守护进程模块方法之前执行，其目的是在实际操作之前执行一些测"
"试。 在这个例子中，对数据库进行检查（始终建议），否则它将休眠10秒。 这是为了"
"等待重新建立DB连接所必需的。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:140
msgid ""
"The ``Run`` method is where the main daemon module code resides, in this "
"case it only prints the current time."
msgstr ""
"``Run`` 方法是主守护进程模块代码所在的位置，在这个例子中它只打印当前时间。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:158
msgid ""
"The ``PostRun`` method is used to perform the sleeps (preventing the daemon "
"module to be executed too often) and also to manage the safe discarding of "
"the object. Other operations like verification or cleanup can be done here."
msgstr ""
"``PostRun`` 方法用于执行休眠（防止守护进程模块执行得太频繁），并且还用于管理"
"对象的安全丢弃。 其它操作如验证或清理可以在这里完成。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:197
msgid ""
"The ``Summary`` method is called by the console command ``Maint::Daemon::"
"Summary`` and it's required to return ``Header``, ``Column``, ``Data`` and "
"``NoDataMessages`` keys. ``Column`` and ``Data`` needs to be an array of "
"hashes. It is used to display useful information of what the daemon module "
"is currently doing, or what has been done so far. This method is optional."
msgstr ""
"``Summary`` 方法由控制台命令 ``Maint::Daemon::Summary`` 调用，它需要返回 "
"``Header``、``Column``、``Data`` 和 ``NoDataMessages`` 键。 ``Column`` 和 "
"``Data`` 需要是一个哈希数组。 它用于显示守护进程模块当前正在执行的操作的有用"
"信息，或者到目前为止已完成的操作。 此方法是可选的。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/daemon-modules.rst:203
#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:137
msgid "End of file."
msgstr "文件结束。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:2
msgid "OTRS Scheduler"
msgstr "OTRS调度程序"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:4
msgid ""
"The OTRS scheduler is a conjunction of daemon modules and task workers that "
"runs together in order to perform all needed OTRS tasks asynchronously from "
"the web server process."
msgstr ""
"OTRS调度程序是守护进程模块和任务工作程序的组合，它们一起运行，以便从Web服务器"
"进程异步执行所有需要的OTRS任务。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:8
msgid "OTRS Scheduler Task Managers"
msgstr "OTRS调度程序任务管理器"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:11
msgid "``SchedulerCronTaskManager``"
msgstr "``SchedulerCronTaskManager``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:11
msgid ""
"This reads registered cron tasks from the OTRS system configuration and "
"determines the correct time to create a task to be executed."
msgstr ""
"这将从OTRS系统配置中读取已注册的cron任务，并确定创建要执行的任务的正确时间。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:14
msgid "``SchedulerFutureTaskManager``"
msgstr "``SchedulerFutureTaskManager``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:14
msgid ""
"This checks the tasks that are set to be executed just one time in the "
"future and sets this task to be executed in time. For example, when a "
"generic interface invoker can not reach the remote server, it can self "
"schedule to be run again 5 minutes later."
msgstr ""
"这将检查设置为将来仅执行一次的任务，并将此任务设置为及时执行。 例如，当通用接"
"口调用程序无法访问远程服务器时，它可以自行调度在5分钟后再次运行。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:17
msgid "``SchedulerGenericAgentTaskManager``"
msgstr "``SchedulerGenericAgentTaskManager``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:17
msgid ""
"This continuously reads the generic agent tasks that are set to be run on "
"regular time basis and sets their execution accordingly."
msgstr "这将持续读取设置为定期运行的自动任务的任务，并相应地设置其执行时间。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:19
msgid ""
"Whenever these tasks managers are not enough, a new daemon module can be "
"created. At a certain point of its ``Run()`` method it needs to call "
"``TaskAdd()`` from the ``chedulerDB`` object to register a task, and as soon "
"as it is registered, it will be executed in the next free slot by the "
"``SchedulerTaskWorker``."
msgstr ""
"只要这些任务管理器不够，就可以创建一个新的守护进程模块。 在它的 ``Run()`` 方"
"法的某一点，它需要从 ``chedulerDB`` 对象调用 ``TaskAdd()`` 来注册一个任务，一"
"旦它被注册，它就会在 ``SchedulerTaskWorker`` 的下一个空闲槽中被执行。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:23
msgid "OTRS Scheduler Task Workers"
msgstr "OTRS调度程序任务工作程序"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:26
msgid "``SchedulerTaskWorker``"
msgstr "``SchedulerTaskWorker``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:26
msgid ""
"This executes all tasks planned by the previous tasks managers plus the ones "
"that come directly from the code by using the asynchronous executor."
msgstr ""
"这将执行先前任务管理器计划的所有任务以及通过异步执行程序直接来自代码的任务。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:28
msgid ""
"In order to execute each task, the ``SchedulerTaskWorker`` calls a back end "
"module (task worker) to perform the specific task. The worker module is "
"determined by the task type. If a new task type is added, it will require a "
"new task worker."
msgstr ""
"为了执行每个任务，``SchedulerTaskWorker`` 调用一个后端模块（任务工作者）来执"
"行特定任务。 工作程序模块由任务类型确定。 如果添加了新任务类型，则需要新的任"
"务工作程序。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:32
msgid "Creating A New Scheduler Task Worker"
msgstr "创建一个新的调度程序任务工作程序"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:34
msgid ""
"All files placed under ``Kernel/System/Daemon/DaemonModules/"
"SchedulerTaskWorker`` could potentially be task workers and they do not "
"require any registration in the system configuration."
msgstr ""
"放在 ``Kernel/System/Daemon/DaemonModules/SchedulerTaskWorker`` 下的所有文件"
"都可能是任务工作程序，并且它们不需要在系统配置中进行任何注册。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:38
msgid "Scheduler Task Worker Code Example"
msgstr "调度程序任务工作程序代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:63
msgid ""
"In this case we are inheriting from ``BaseTaskWorker`` class, and the object "
"manager dependencies are set."
msgstr ""
"在这个例子中，我们继承自 ``BaseTaskWorker`` 类，并设置了对象管理器依赖项。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:79
#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:335
msgid "The constructor ``new`` creates a new instance of the class."
msgstr "构造函数 ``new`` 创建了一个新的类实例。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/daemon/scheduler-task-worker-modules.rst:131
msgid ""
"The ``Run`` is the main method. A call to ``_CheckTaskParams()`` from the "
"base class will save some lines of code. Executing the task while capturing "
"the STDERR is a very good practice, since the OTRS scheduler runs normally "
"unattended, and saving all errors to a variable will make it available for "
"further processing. ``_HandleError()`` provides a common interface to send "
"the error messages as email to the recipient specified in the system "
"configuration."
msgstr ""
"``Run`` 是主要方法。 从基类调用 ``_CheckTaskParams()`` 将节约一些代码行。 在"
"捕获STDERR时执行任务是一种非常好的做法，因为OTRS调度程序通常无人值守运行，并"
"且将所有错误保存到变量将使其可用于进一步处理。 ``_HandleError()`` 提供了一个"
"通用接口，可以将错误消息作为电子邮件发送给系统配置中指定的收件人。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dashboard.rst:2
msgid "Dashboard Module"
msgstr "仪表板模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dashboard.rst:4
msgid "Dashboard module to display statistics in the form of a line graph."
msgstr "仪表板模块以折线图的形式显示统计信息。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dashboard.rst:9
msgid "Dashboard Widget"
msgstr "仪表板小部件"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dashboard.rst:160
msgid ""
"To use this module add the following to the ``Kernel/Config.pm`` and restart "
"your web server (if you use ``mod_perl``)."
msgstr ""
"要使用此模块，请将以下内容添加到 ``Kernel/Config.pm`` 并重新启动Web服务器（如"
"果使用 ``mod_perl``）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dashboard.rst:185
msgid ""
"An excessive number of days or individual lines may lead to performance "
"degradation."
msgstr "天数或个别的折线过多可能会导致性能下降。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:2
msgid "Creating a Dynamic Field Functionality Extension"
msgstr "创建一个动态字段功能扩展"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:4
msgid ""
"To illustrate this process a new dynamic field functionality extension for "
"the function ``Foo`` will be added to the back end object as well as in the "
"text field driver."
msgstr ""
"为了说明这个过程，``Foo`` 函数的一个新的动态字段功能扩展将添加到后端对象和文"
"本字段驱动程序中。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:6
msgid "To create this extension we will create 3 files:"
msgstr "要创建此扩展，我们将创建3个文件："

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:8
#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:13
msgid "A configuration file (XML) to register the modules."
msgstr "一个用于注册模块的配置文件（XML）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:9
msgid "A back end extension (Perl) to define the new function."
msgstr "一个用于定义新函数的后端扩展（Perl）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:10
msgid ""
"A text field driver extension (Perl) that implements the new function for "
"text fields."
msgstr "一个文本字段驱动程序扩展（Perl），用于实现文本字段的新功能。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:12
#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:18
msgid "File structure:"
msgstr "文件结构："

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:33
msgid "Dynamic Field Foo Extension files"
msgstr "动态字段Foo扩展文件"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:36
msgid "Dynamic Field Extension Configuration File Example"
msgstr "动态字段扩展文件示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:38
msgid ""
"The configuration files are used to register the extensions for the back end "
"and drivers as well as new behaviors for each drivers."
msgstr "该配置文件用于注册后端和驱动程序的扩展以及每个驱动程序的新行为。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:42
msgid ""
"If a driver is extended with a new function, the back end will need also an "
"extension for that function."
msgstr "如果使用新功能扩展一个驱动程序，则后端也需要一个该功能的扩展。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:44
msgid ""
"In this section a configuration file for ``Foo`` extension is shown and "
"explained."
msgstr "在本节中，将显示和解释 ``Foo`` 扩展的配置文件。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:51
#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:61
msgid "This is the normal header for a configuration file."
msgstr "这是配置文件的正常头文件。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:66
msgid ""
"This setting registers the extension in the back end object. The module will "
"be loaded from ``Backend`` as a base class."
msgstr "此设置在后端对象中注册扩展名。该模块将从 ``Backend`` 作为基类加载。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:86
msgid ""
"This is the registration for an extension in the text dynamic field driver. "
"The module will be loaded as a base class in the driver. Notice also that "
"new behaviors can be specified. These extended behaviors will be added to "
"the behaviors that the driver has out of the box, therefore a call to "
"``HasBehavior()`` to check for these new behaviors will be totally "
"transparent."
msgstr ""
"这是在文本动态字段驱动程序中注册扩展。 该模块将作为基类加载到驱动程序中。 另"
"请注意，可以指定新行为。 这些扩展的行为将被添加到驱动程序开箱即用的行为中，因"
"此调用 ``HasBehavior()`` 来检查这些新行为将是完全透明的。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:92
#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:105
msgid "Standard closure of a configuration file."
msgstr "一个配置文件的标准关闭。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:96
msgid "Dynamic Field Back End Extension Example"
msgstr "动态字段后端扩展示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:98
msgid ""
"Back end extensions will be loaded transparently into the back end itself as "
"a base class. All defined object and properties from the back end will be "
"accessible in the extension."
msgstr ""
"后端扩展将作为基类透明地加载到后端本身。 可以在扩展中访问后端的所有已定义对象"
"和属性。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:102
msgid ""
"All new functions defined in the back end extension should be implemented in "
"a driver extension."
msgstr "后端扩展中定义的所有新功能都应在驱动程序扩展中实现。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:104
msgid ""
"In this section the ``Foo`` extension for back end is shown and explained. "
"The extension only defines the function ``Foo()``."
msgstr ""
"在本节中，将显示和解释后端的 ``Foo`` 扩展。 该扩展只定义函数 ``Foo()``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:210
msgid ""
"The function ``Foo()`` is only used for test purposes. First it checks the "
"dynamic field configuration, then it checks if the dynamic field driver "
"(type) exists and was already loaded. To prevent the function call on a "
"driver where is not defined it first check if the driver can execute the "
"function, then executes the function in the driver passing all parameters."
msgstr ""
"``Foo()`` 函数仅用于测试目的。 首先，它检查动态字段配置，然后检查动态字段驱动"
"程序（类型）是否存在且是否已加载。 为了防止对未定义的驱动程序的函数调用，首先"
"检查驱动程序是否可以执行该函数，然后在驱动程序中执行传递所有参数的函数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:214
msgid ""
"It is also possible to skip the step that tests if the driver can execute "
"the function. To do that it is necessary to implement a mechanism in the "
"front end module to require a special behavior on the dynamic field, and "
"only after call the function in the back end object."
msgstr ""
"也可以跳过测试驱动程序是否可以执行该功能的步骤。为此，有必要在前端模块中实现"
"一种机制，以要求在动态字段上有一个特殊的行为，并且仅在调用后端对象中的函数之"
"后。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:218
msgid "Dynamic Field Driver Extension Example"
msgstr "动态字段驱动程序扩展示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:220
msgid ""
"Driver extensions will be loaded transparently into the driver itself as a "
"base class. All defined object and properties from the driver will be "
"accessible in the extension."
msgstr ""
"驱动程序扩展将作为基类透明地加载到驱动程序本身中。驱动程序中定义的所有对象和"
"属性都可以在扩展中访问。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:224
msgid ""
"All new functions implemented in the driver extension should be defined in a "
"back end extension, as every function is called from the back end object."
msgstr ""
"驱动程序扩展中实现的所有新函数都应该在后端扩展中定义，因为每个函数都是从后端"
"对象调用的。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:226
msgid ""
"In this section the ``Foo`` extension for text field driver is shown and "
"explained. The extension only implements the function ``Foo()``."
msgstr ""
"在本节中，将显示并解释文本字段驱动程序的 ``Foo`` 扩展。扩展仅实现 ``foo()`` "
"函数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend.rst:269
msgid ""
"The function ``Foo()`` has no special logic. It is only for testing and it "
"always returns 1."
msgstr "``foo()`` 函数没有特殊的逻辑。它只用于测试，并且总是返回1。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:2
msgid "How To Extend The Dynamic Fields"
msgstr "如何扩展动态字段"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:4
msgid ""
"There are many ways to extend the dynamic fields. The following sections "
"will try to cover the most common scenarios."
msgstr "有很多方法可以扩展动态字段。以下部分将尝试介绍最常见的场景。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:7
msgid "Create a New Dynamic Field Type (for ticket or article objects)"
msgstr "创建新的动态字段类型（用于工单或信件对象）"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:9
msgid "To create a new dynamic field type is necessary to:"
msgstr "要创建新的动态字段类型，必须："

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:11
#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:22
msgid ""
"Create a dynamic field driver. This is the main module of the new field."
msgstr "创建一个动态字段驱动程序。这是新字段的主要模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:12
#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:27
msgid ""
"Create or use an existing admin dialog to have a management interface and "
"set its configuration options."
msgstr "创建或使用现有的管理对话框以具有管理界面并设置其配置选项。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:13
#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:29
msgid ""
"Create a configuration file to register the new field in the back end (or "
"new admin dialogs in the framework if needed) and be able to create "
"instances or it."
msgstr ""
"创建一个配置文件来注册后端中的新字段（如果需要，也可以在框架中创建新的管理对"
"话框），并能创建其实例。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:18
msgid "Create a New Dynamic Field Type (for other objects)"
msgstr "创建新的动态字段类型（用于其它对象）"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:20
msgid "To create a new dynamic field type for other objects is necessary to:"
msgstr "要为其它对象创建新的动态字段类型，必须："

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:23
msgid ""
"Create an object type delegate. This is necessary, even if the other object "
"does not require any specific data handling in its functions (e.g. after a "
"value is set). All object type delegates must implement the functions that "
"the back end requires."
msgstr ""
"创建对象类型委托。这是必要的，即使另一个对象在其函数中不需要任何特定的数据处"
"理（例如，在设置了一个值之后）。所有对象类型委托都必须实现后端所需的功能。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:25
msgid ""
"Take a look in the current object type delegates to implement the same "
"functions, even if they just return a successful value for the other object."
msgstr ""
"查看当前对象类型委托以实现相同的函数，即使它们只是为其它对象返回一个成功的"
"值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:28
#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:40
msgid ""
"Implement dynamic fields in the front end modules to be able to use the "
"dynamic fields."
msgstr "在前端模块中实现动态字段，以便能够使用动态字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:32
msgid ""
"And make the needed settings to show, hide or show the dynamic fields as "
"mandatory in the new screens."
msgstr "并进行必要的设置以在新屏幕中强制显示、隐藏或显示动态字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:36
msgid "Create a New package to Use Dynamic Fields"
msgstr "创建新包以使用动态字段"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:38
msgid "To create a package to use existing dynamic fields is necessary to:"
msgstr "要创建使用现有动态字段的包，必须："

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:41
msgid ""
"Create a configuration file to give the end user the possibility to show, "
"hide or show the dynamic fields as mandatory in the new screens."
msgstr ""
"创建一个配置文件，使最终用户能够在新屏幕中显示、隐藏或强制显示动态字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:46
msgid "Extend Back End and Drivers Functionalities"
msgstr "扩展后端和驱动程序功能"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:48
msgid ""
"It might be possible that the back end object does not have a needed "
"function for custom developments, or could also be possible that it has the "
"function needed, but the return format does not match the needs of the "
"custom development, or that a new behavior is needed to execute the new or "
"the old functions."
msgstr ""
"后端对象可能没有自定义开发所需的函数，或者也可能具有所需的函数，但是返回格式"
"不符合自定义开发的需要，或者执行新的或旧的函数需要新的行为。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:50
msgid ""
"The easiest way to do this, is to extend the current field files. For this "
"it is necessary to create a new back end extension file that defines the new "
"functions and create also drivers extensions that implement these new "
"functions for each field. These new drivers will only need to implement the "
"new functions since the original drivers takes care of the standard "
"functions. All these new files do not need a constructor as they will be "
"loaded as a base for the back end object and the drivers."
msgstr ""
"最简单的方法是扩展当前字段文件。为此，有必要创建一个新的后端扩展文件来定义新"
"的函数，并创建驱动程序扩展来为每个字段实现这些新函数。这些新的驱动程序只需要"
"实现新的功能，因为原始驱动程序负责标准功能。所有这些新文件都不需要构造函数，"
"因为它们将作为后端对象和驱动程序的基础进行加载。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:52
msgid ""
"The only restrictions are that the functions should be named different than "
"the ones on the back end and drivers, otherwise they will be overwritten "
"with current objects."
msgstr ""
"唯一的限制是函数的命名应该与后端和驱动程序上的不同，否则它们将被当前对象覆"
"盖。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:54
msgid ""
"Put the new back end extension into the ``DynamicField`` directory (e.g. ``/"
"$OTRS_HOME/Kernel/System/DynamicField/NewPackageBackend.pm`` and its drivers "
"in ``/$OTRS_HOME/Kernel/System/DynamicField/Driver/NewPackage*.pm``)."
msgstr ""
"将新的后端扩展放入 ``DynamicField`` 目录（例如 ``/$OTRS_HOME/Kernel/System/"
"DynamicField/NewPackageBackend.pm`` 及其驱动程序位于 ``/$OTRS_HOME/Kernel/"
"System/DynamicField/Driver/NewPackage*.pm``）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:56
msgid ""
"New behaviors only need a small setting in the extensions configuration file."
msgstr "新行为只需要扩展配置文件中的一个小型设置。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:58
msgid "To create new back end functions is needed to:"
msgstr "要创建新的后端函数，需要："

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:60
msgid ""
"Create a new back end extension module to define only the new functions."
msgstr "创建一个新的后端扩展模块以仅定义新函数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:61
msgid ""
"Create the dynamic fields driver extensions to implement only the new "
"functions."
msgstr "创建动态字段驱动程序扩展以仅实现新函数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:62
msgid ""
"Implement new dynamic fields functions in the front end modules to be able "
"to use the new dynamic fields functions."
msgstr "在前端模块中实现新的动态字段功能，以便能够使用新的动态字段功能。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:63
msgid ""
"Create a configuration file to register the new back end and drivers "
"extensions and behaviors."
msgstr "创建一个配置文件以注册新的后端和驱动程序扩展和行为。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:67
msgid "Other Extensions"
msgstr "其它扩展"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-extend-options.rst:69
msgid "Other extensions could be a combination of the above examples."
msgstr "其它扩展可以是上述示例的组合。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:2
#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:11
msgid "Dynamic Fields Framework"
msgstr "动态字段框架"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:4
msgid ""
"Before creating new dynamic fields is necessary to understand its framework "
"and how OTRS screens interact with them, as well as their underlying API."
msgstr ""
"在创建新的动态字段之前，有必要了解它的框架以及OTRS屏幕如何与它们以及它们的底"
"层API交互。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:6
msgid ""
"The following picture shows the architecture of the dynamic fields framework."
msgstr "下图显示了动态字段框架的体系结构。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:15
msgid "Dynamic Field Back End Modules"
msgstr "动态字段后端模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:19
msgid "Dynamic Field (Back End)"
msgstr "动态字段（后端）"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:21
msgid ""
"Normally called as ``BackendObject`` in the front end modules is the "
"mediator between the front end modules and each specific dynamic field "
"implementation or driver. It defines a generic middle API for all dynamic "
"field drivers, and each driver has the responsibility to implement the "
"middle API for the specific needs for the field."
msgstr ""
"通常在前端模块中称为 ``BackendObject``，是前端模块与每个特定动态字段实现或驱"
"动程序之间的中介。它为所有动态字段驱动程序定义了通用的中间API，并且每个驱动程"
"序都有责任为字段的特定需求实现中间API。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:23
msgid ""
"The dynamic field back end is the master controller of all the drivers. Each "
"function in this module is responsible to check the required parameters and "
"call the same function in the specific driver according to the dynamic field "
"configuration parameter received."
msgstr ""
"动态字段后端是所有驱动程序的主控制器。此模块中的每个函数负责检查所需的参数，"
"并根据接收到的动态字段配置参数在特定驱动程序中调用相同的函数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:25
msgid ""
"This module is also responsible to call specific functions on each object "
"type delegate (like ``Ticket`` or ``Article``) e.g. to add a history entry "
"or fire an event."
msgstr ""
"此模块还负责调用每个对象类型委托上的特定函数（如 ``Ticket`` 或 "
"``Article``），例如添加一个历史记录条目或触发一个事件。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:27
msgid ""
"This module is located in ``$OTRS_HOME/Kernel/System/DynamicField/Backend."
"pm``."
msgstr "此模块位于 ``$OTRS_HOME/Kernel/System/DynamicField/Backend.pm``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:33
msgid "Dynamic Field Drivers"
msgstr "动态字段驱动程序"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:35
msgid ""
"A dynamic field driver is the implementation of the dynamic field. Each "
"driver must implement all the mandatory functions specified in the back end "
"(there are some functions that depends on a behavior and it is not needed to "
"implement those if the dynamic field does not have that particular behavior)."
msgstr ""
"动态字段驱动程序是动态字段的实现。每个驱动程序都必须实现后端中指定的所有强制"
"函数（有些函数依赖于某个行为，如果动态字段没有该特定行为，则不需要实现这些函"
"数）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:38
msgid ""
"A driver is responsible to know how to get its own value or values from a "
"web request, or from a profile (like a search profile). It also needs to "
"know the HTML code to render the field in edit or display screens, or how to "
"interact with the stats module, among other functions."
msgstr ""
"驱动程序负责知道如何从Web请求或配置文件（如搜索配置文件）获取自己的值。它还需"
"要知道在编辑或显示屏幕中呈现字段的HTML代码，或者如何与统计模块交互，以及其它"
"函数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:40
msgid ""
"These modules are located in ``$OTRS_HOME/Kernel/System/DynamicField/Driver/"
"*.pm``."
msgstr "这些模块位于 ``$OTRS_HOME/Kernel/System/DynamicField/Driver/*.pm``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:42
msgid ""
"It exists some base drivers like ``Base.pm``, ``BaseText.pm``, ``BaseSelect."
"pm`` and ``BaseDateTime.pm``, that implements common functions for certain "
"drivers (e.g. driver ``TextArea.pm`` uses ``BaseText.pm`` that also uses "
"``Base.pm`` then ``TextArea`` only needs to implement the functions that are "
"missing in ``Base.pm`` and ``BateText.pm`` or the ones that are special "
"cases)."
msgstr ""
"存在一些基本驱动程序，如 ``Base.pm``、 ``BaseText.pm``、 ``BaseSelect.pm`` "
"和 ``BaseDateTime.pm``，它们为某些驱动程序实现通用（例如，``TextArea.pm`` 驱"
"动程序使用 ``BaseText.pm`` 也使用 ``Base.pm`` ，然后 ``TextArea`` 只需要实现 "
"``Base.pm`` 和 ``BaseText.pm`` 缺失的函数或某些特殊情况的函数）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:44
msgid "The following is the drivers inheritance tree:"
msgstr "以下是驱动程序继承树："

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:46
msgid "``Base.pm``"
msgstr "``Base.pm``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:48
msgid "``BaseText.pm``"
msgstr "``BaseText.pm``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:50
msgid "``Text.pm``"
msgstr "``Text.pm``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:51
msgid "``TextArea.pm``"
msgstr "``TextArea.pm``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:53
msgid "``BaseSelect.pm``"
msgstr "``BaseSelect.pm``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:55
msgid "``Dropdown.pm``"
msgstr "``Dropdown.pm``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:56
msgid "``Multiselect.pm``"
msgstr "``Multiselect.pm``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:58
msgid "``BaseDateTime.pm``"
msgstr "``BaseDateTime.pm``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:60
msgid "``DateTime.pm``"
msgstr "``DateTime.pm``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:61
msgid "``Date.pm``"
msgstr "``Date.pm``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:63
msgid "``Checkbox.pm``"
msgstr "``Checkbox.pm``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:67
msgid "Object Type Delegate"
msgstr "对象类型委托"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:69
msgid ""
"An object type delegate is responsible to perform specific functions on the "
"object linked to the dynamic field. These functions are triggered by the "
"back end object as they are needed."
msgstr ""
"对象类型委托负责对链接到动态字段的对象执行特定功能。这些功能是由后端对象根据"
"需要触发的。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:71
msgid ""
"These modules are located in ``$OTRS_HOME/Kernel/System/DynamicField/"
"ObjectType/*.pm``."
msgstr ""
"这些模块位于 ``$OTRS_HOME/Kernel/System/DynamicField/ObjectType/*.pm``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:75
msgid "Dynamic Fields Admin Modules"
msgstr "动态字段管理模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:77
msgid ""
"To manage the dynamic fields (add, edit and list) a series of modules has "
"been already developed. There is one specific master module "
"(``AdminDynamicField.pm``) that shows the list of defined dynamic fields, "
"and from within other modules are called to create new dynamic fields or "
"modify an existing ones."
msgstr ""
"为了管理动态字段（添加、编辑和列出），已经开发了一系列模块。有一个特定的主模"
"块（``AdminDynamicField.pm``），它显示定义的动态字段列表，并从其它模块中调用"
"以创建新的动态字段或修改现有的动态字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:79
msgid ""
"Normally a dynamic field driver needs its own admin module (admin dialog) to "
"define its properties. This dialog might differ from other drivers. But this "
"is not mandatory, drivers can share admin dialogs, if they can provide "
"needed information for all the drivers that are linked to them, no matter if "
"they are from different type. What is mandatory is that each driver must be "
"linked to an admin dialog (e.g. text and textarea drivers share "
"``AdminDynamicFieldText.pm`` admin dialog, and date and date/time drivers "
"share ``AdminDynamicFieldDateTime.pm`` admin dialog)."
msgstr ""
"通常，动态字段驱动程序需要自己的管理模块（管理对话框）来定义其属性。此对话框"
"可能与其它驱动程序不同。但这不是强制性的，驱动程序可以共享管理对话框，前提是"
"它们可以为链接到它们的所有驱动程序提供所需的信息，无论它们来自不同的类型。必"
"须将每个驱动程序链接到管理对话框（例如，文本和文本区域驱动程序共享 "
"``AdminDynamicFieldText.pm`` 管理对话框，以及日期和日期/时间驱动程序共享 "
"``AdminDynamicFieldDateTime.pm`` 管理对话框）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:81
msgid ""
"Admin dialogs follow the normal OTRS admin module rules and architecture. "
"But for standardization all configuration common parts to all dynamic fields "
"should have the same look and feel among all admin dialogs."
msgstr ""
"管理对话框遵循正常的OTRS管理模块规则和体系结构。但是为了标准化，所有动态字段"
"的所有配置公共部分在所有管理对话框中应该具有相同的外观和感觉。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:83
msgid "These modules are located in ``$OTRS_HOME/Kernel/Modules/*.pm``."
msgstr "这些模块位于 ``$OTRS_HOME/Kernel/Modules/*.pm``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:87
msgid "Each admin dialog needs its corresponding HTML template file (``.tt``)."
msgstr "每个管理对话框都需要相应的HTML模板文件（``.tt``）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:91
msgid "Dynamic Fields Core Modules"
msgstr "动态字段核心模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:93
msgid ""
"This modules reads and writes the dynamic fields information from and to the "
"database tables."
msgstr "此模块从数据库表读取动态字段信息并将其写入数据库表。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:96
msgid "``DynamicField.pm``"
msgstr "``DynamicField.pm``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:96
msgid ""
"This module is responsible to manage the dynamic field definitions. It "
"provides the basic API for add, change, delete, list and get dynamic fields. "
"This module is located in ``$OTRS_HOME/Kernel/System/DynamicField.pm``."
msgstr ""
"此模块负责管理动态字段定义。它为添加、更改、删除、列出和获取动态字段提供了基"
"本的API。此模块位于 ``$OTRS_HOME/Kernel/System/DynamicField.pm``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:100
msgid "``DynamicFieldValue.pm``"
msgstr "``DynamicFieldValue.pm``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:99
msgid ""
"This module is responsible to read and write dynamic field values into the "
"form and into the database. This module is highly used by the drivers and is "
"located in ``$OTRS_HOME/Kernel/System/DynamicFieldValue.pm``."
msgstr ""
"此模块负责将动态字段值读写到表单和数据库中。此模块被驱动程序高度使用，位于 ``"
"$OTRS_HOME/Kernel/System/DynamicFieldValue.pm``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:103
msgid "Dynamic Fields Database Tables"
msgstr "动态字段数据库表"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:105
msgid ""
"There are two tables in the database to store the dynamic field information:"
msgstr "数据库中有两个表用于存储动态字段信息："

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:108
msgid "``dynamic_field``"
msgstr "``dynamic_field``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:108
msgid ""
"Used by the core module ``DynamicField.pm``, it stores the dynamic field "
"definitions."
msgstr "由核心模块 ``DynamicField.pm`` 使用，它存储动态字段定义。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:112
msgid "``dynamic_field_value``"
msgstr "``dynamic_field_value``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:111
msgid ""
"Used by the core module ``DynamicFieldValue.pm`` to save the dynamic field "
"values for each dynamic field and each object type instance."
msgstr ""
"由核心模块 ``DynamicFieldValue.pm`` 用于保存每个动态字段和每个对象类型实例的"
"动态字段值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:115
msgid "Dynamic Fields Configuration Files"
msgstr "动态字段配置文件"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:117
msgid ""
"The back end module needs a way to know which drivers exists and since the "
"amount of drivers can be easily extended. The easiest way to manage them is "
"to use the system configuration, where the information of dynamic field "
"drivers and object type drivers can be stored and extended."
msgstr ""
"后端模块需要一种方法来了解哪些驱动程序存在，并且因为驱动程序的数量可以轻松扩"
"展。 管理它们的最简单方法是使用系统配置，其中可以存储和扩展动态字段驱动程序和"
"对象类型驱动程序的信息。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:119
msgid ""
"The master admin module also needs to know this information about the "
"available dynamic field drivers to use the admin dialog linked with, to "
"create or modify the dynamic fields."
msgstr ""
"主管理模块还需要知道有关可用动态字段驱动程序的信息，以使用与之链接的管理对话"
"框来创建或修改动态字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-framework.rst:121
msgid ""
"Front end modules need to read the system configuration to know which "
"dynamic fields are active for each screen and which ones are also mandatory. "
"For example: ``Ticket::Frontend::AgentTicketPhone###DynamicField`` stores "
"the active, mandatory and inactive dynamic fields for *New Phone Ticket* "
"screen."
msgstr ""
"前端模块需要读取系统配置以了解每个屏幕的哪些动态字段是活动的，哪些是强制性"
"的。 例如：``Ticket::Frontend::AgentTicketPhone###DynamicField`` 存储 *新建电"
"话工单* 屏幕的活动、必填和非活动的动态字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-interaction.rst:2
msgid "Dynamic Field Interaction With Front End Modules"
msgstr "动态字段与前端模块交互"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-interaction.rst:4
msgid ""
"Knowing about how front end modules interact with dynamic fields is not "
"strictly necessary to extend dynamic fields for the ticket or article "
"objects, since all the screens that could use the dynamic fields are already "
"prepared. But in case of custom developments or to extend the dynamic fields "
"to other objects is very useful to know how to access dynamic fields "
"framework from a front end module."
msgstr ""
"了解前端模块如何与动态字段交互并不是扩展工单或信件对象的动态字段所必需的，因"
"为可以使用动态字段的所有屏幕都已经准备好了。但在定制开发或将动态字段扩展到其"
"它对象的情况下，了解如何从前端模块访问动态字段框架非常有用。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-interaction.rst:6
msgid ""
"The following picture shows a simple example of how the dynamic fields "
"interact with other OTRS framework parts."
msgstr "下图显示了动态字段如何与其它OTRS框架部分交互的简单示例。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-interaction.rst:11
msgid "Dynamic Field Interaction"
msgstr "动态字段交互"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-interaction.rst:13
msgid ""
"The first step is that the front end module reads the configured dynamic "
"fields. For example ``AgentTicketNote`` should read ``Ticket::Frontend::"
"AgentTicketNote###DynamicField`` setting. This setting can be used as the "
"filter parameter for ``DynamicField`` core module function "
"``DynamicFieldListGet()``. The screen can store the results of this function "
"to have the list of the dynamic fields activated for this particular screen."
msgstr ""
"第一步是前端模块读取配置的动态字段。 例如，``AgentTicketNote`` 应该读取 "
"``Ticket::Frontend::AgentTicketNote###DynamicField`` 设置。 此设置可用作 "
"``DynamicField`` 核心模块函数 ``DynamicFieldListGet()`` 的过滤器参数。 该屏幕"
"可以存储此功能的结果，以便为此特定屏幕激活动态字段列表。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-interaction.rst:15
msgid ""
"Next, the screen should try to get the values from the web request. It can "
"use the back end object function ``EditFieldValueGet()`` for this purpose, "
"and can use this values to trigger ACLs. The back end object will use each "
"driver to perform the specific actions for all functions."
msgstr ""
"接下来，该屏幕应该尝试从Web请求中获取值。 为此，它可以使用后端对象函数 "
"``EditFieldValueGet()``，并可以使用此值来触发ACL。 后端对象将使用每个驱动程序"
"执行所有功能的特定操作。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-interaction.rst:17
msgid ""
"To continue, the screen should get the HTML for each field to display it. "
"The back end object function ``EditFieldRender()`` can be used to perform "
"this action and the ACLs restriction as well as the values from the web "
"request can be passed to this function in order to get better results. In "
"case of a submit the screen could also use the back end object function "
"``EditFieldValueValidate()`` to check the mandatory fields."
msgstr ""
"要继续，该屏幕应获取每个字段的HTML以显示它。 后端对象函数 "
"``EditFieldRender()`` 可用于执行此操作，并且可以将ACL限制以及Web请求中的值传"
"递给此函数，以获得更好的结果。 如果提交，该屏幕也可以使用后端对象函数 "
"``EditFieldValueValidate()`` 来检查必填字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-interaction.rst:22
msgid ""
"Other screens could use ``DisplayFieldRender()`` instead of "
"``EditFieldRender()`` if the screen only shows the field value, and in such "
"case no value validation is needed."
msgstr ""
"如果屏幕只显示字段值，则其它屏幕可以使用 ``DisplayFieldRender()`` 而不是 "
"``EditFieldRender()``，在这种情况下，不需要进行值验证。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-interaction.rst:24
msgid ""
"To store the value of the dynamic field is necessary to get the object ID. "
"For this example if the dynamic field is linked to a ticket object, the "
"screen should already have the ``TicketID``, otherwise if the field is "
"linked to an article object in order to set the value of the field is "
"necessary to create the article first. ``ValueSet()`` from the back end "
"object can be used to set the dynamic field value."
msgstr ""
"要获取对象ID，需要存储动态字段的值。 对于此示例，如果动态字段链接到工单对象，"
"则屏幕应该已经具有 ``TicketID``，否则如果该字段链接到信件对象，要设置该字段的"
"值，则必须首先创建该信件。 后端对象的 ``ValueSet()`` 可用于设置动态字段值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-interaction.rst:26
msgid ""
"In summary the front end modules does not need to know how each dynamic "
"field works internally to get or set their values or to display them. It "
"just needs to call the back end object module and use the fields in a "
"generic way."
msgstr ""
"总之，前端模块不需要知道每个动态字段是如何在内部工作来获取或设置它们的值或显"
"示它们。它只需要调用后端对象模块并以通用的方式使用字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:2
msgid "Creating A New Dynamic Field"
msgstr "创建一个新动态字段"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:4
msgid ""
"To illustrate this process a new dynamic field *Password* will be created. "
"This new dynamic field type will show a new password field to ticket or "
"article objects. Since is very similar to a text dynamic field we will use "
"the ``Base`` and ``BaseText`` drivers as a basis to build this new field."
msgstr ""
"为了说明此过程，将创建一个新的动态字段 *Password*。 此新动态字段类型将为工单"
"或信件对象显示新的密码字段。 由于与文本动态字段非常相似，我们将使用 ``Base`` "
"和 ``BaseText`` 驱动程序作为构建此新字段的基础。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:9
msgid ""
"This new password field implementation is just for educational purposes, it "
"does not provide any level of security and is not recommended for production "
"systems."
msgstr ""
"此新密码字段实现仅用于教育目的，它不提供任何级别的安全性，不建议用于生产系"
"统。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:11
msgid "To create this new dynamic field we will create 4 files:"
msgstr "要创建这个新的动态字段，我们将创建4个文件："

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:14
msgid "An admin dialog module (Perl) to setup the field options."
msgstr "一个用于设置字段选项的管理对话框模块（Perl）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:15
msgid "A template module for the admin dialog."
msgstr "一个管理对话框的模板模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:16
msgid "A dynamic field driver (Perl)."
msgstr "一个动态字段驱动程序（Perl）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:47
msgid "Dynamic Field Password files"
msgstr "Password动态字段的文件"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:50
msgid "Dynamic Field Configuration File Example"
msgstr "动态字段配置文件示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:52
msgid ""
"The configuration files are used to register the dynamic field types "
"(driver) and the object type drivers for the back end object. They also "
"store standard registrations for admin modules in the framework."
msgstr ""
"配置文件用于注册后端对象的动态字段类型（驱动程序）和对象类型驱动程序。 它们还"
"在框架中存储管理模块的标准注册。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:54
msgid ""
"In this section a configuration file for password dynamic field is shown and "
"explained."
msgstr "在本节中，将显示和解释password动态字段的配置文件。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:78
msgid ""
"This setting registers the password dynamic field driver for the back end "
"module so it can be included in the list of available dynamic fields types. "
"It also specify its own admin dialog in the key ``ConfigDialog``. This key "
"is used by the master dynamic field admin module to manage this new dynamic "
"field type."
msgstr ""
"此设置为后端模块注册password动态字段驱动程序，以便它可以包含在可用动态字段类"
"型列表中。 它还在键 ``ConfigDialog`` 中指定了自己的管理对话框。 主动态字段管"
"理模块使用此键来管理此新的动态字段类型。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:99
msgid ""
"This is a standard module registration for the password admin dialog in the "
"admin interface."
msgstr "这是管理界面中password管理对话框的标准模块注册。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:109
msgid "Dynamic Field Admin Dialog Example"
msgstr "动态字段管理对话框示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:111
msgid ""
"The admin dialogs are standard admin modules to manage (add or edit) the "
"dynamic fields."
msgstr "管理对话框是管理（添加或编辑）动态字段的标准管理模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:113
msgid ""
"In this section an admin dialog for password dynamic field is shown and "
"explained."
msgstr "在本节中，将显示和解释password动态字段的管理对话框。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:166
#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:959
msgid ""
"The constructor ``new`` creates a new instance of the class. According to "
"the coding guidelines objects of other classes that are needed in this "
"module have to be created in ``new``."
msgstr ""
"构造函数 ``new`` 创建了一个新的类实例。 根据编码指南，必须在 ``new`` 中创建此"
"模块中所需的其它类的对象。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:208
msgid ""
"``Run`` is the default function to be called by the web request. We try to "
"make this function as simple as possible and let the helper functions to do "
"the hard work."
msgstr ""
"``Run`` 是Web请求调用的默认函数。 我们尝试使这个函数尽可能简单，并让helper函"
"数完成艰苦的工作。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:239
msgid ""
"``_Add`` function is also pretty simple, it just get some parameters from "
"the web request and call the ``_ShowScreen()`` function. Normally this "
"function is not needed to be modified."
msgstr ""
"``_Add`` 函数也很简单，它只是从Web请求获取一些参数并调用 ``_ShowScreen()`` 函"
"数。 通常，不需要修改此函数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:357
msgid ""
"The ``_AddAction`` function gets the configuration parameters from a new "
"dynamic field, and it validates that the dynamic field name only contains "
"letters and numbers. This function could validate any other parameter."
msgstr ""
"`_AddAction`` 函数从新的动态字段中获取配置参数，并验证动态字段名称只包含字母"
"和数字。 此函数可以验证任何其它参数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:359
msgid ""
"``Name``, ``Label``, ``FieldOrder``, ``Validity`` are common parameters for "
"all dynamic fields and they are required. Each dynamic field has its "
"specific configuration that must contain at least the ``DefaultValue`` "
"parameter. In this case it also have ``ShowValue`` and ``ValueMask`` "
"parameters for password field."
msgstr ""
"``Name``、``Label``、``FieldOrder``、``Validity`` 是所有动态字段的通用参数，"
"它们是必需的。 每个动态字段都有其特定的配置，必须至少包含 ``DefaultValue`` 参"
"数。 在这种情况下，它还有密码字段的 ``ShowValue`` 和 ``ValueMask`` 参数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:362
msgid ""
"If the field has the ability to store a fixed list of values they should be "
"stored in the ``PossibleValues`` parameter inside the specific configuration "
"hash."
msgstr ""
"如果该字段能够存储固定的值列表，则应将它们存储在特定配置哈希内的 "
"``PossibleValues`` 参数中。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:364
msgid ""
"As in other admin modules, if a parameter is not valid this function returns "
"to the add screen highlighting the erroneous form fields."
msgstr ""
"与其它管理模块一样，如果参数无效，则此函数将返回添加屏幕，突出显示错误的表单"
"字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:366
msgid "If all the parameters are correct it creates a new dynamic field."
msgstr "如果所有参数都正确，则会创建一个新的动态字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:429
msgid ""
"The ``_Change`` function is very similar to the ``_Add`` function but since "
"this function is used to edit an existing field it needs to validated the "
"``FieldID`` parameter and gather the current dynamic field data."
msgstr ""
"``_Change`` 函数与 ``_Add`` 函数非常相似，但由于此函数用于编辑现有字段，因此"
"需要验证 ``FieldID`` 参数并收集当前动态字段数据。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:574
msgid ""
"``_ChangeAction()`` is very similar to ``_AddAction()``, but adapted for the "
"update of an existing field instead of creating a new one."
msgstr ""
"``_ChangeAction()`` 与 ``_AddAction()`` 非常相似，但适用于更新现有字段而不是"
"创建新字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:667
msgid ""
"The ``_ShowScreen`` function is used to set and define the HTML elements and "
"blocks from a template to generate the admin dialog HTML code."
msgstr ""
"``_ShowScreen`` 函数用于设置和定义模板中的HTML元素和块，以生成管理对话框HTML"
"代码。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:671
msgid "Dynamic Field Template for Admin Dialog Example"
msgstr "用于管理对话框的动态字段模块示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:673
msgid "The template is the place where the HTML code of the dialog is stored."
msgstr "模板是存储对话框的HTML代码的位置。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:675
msgid ""
"In this section an admin dialog template for the password dynamic field is "
"shown and explained."
msgstr "在本节中，将显示和解释password动态字段的管理对话框模板。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:687
#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:401
msgid "This is common header that can be found in common OTRS modules."
msgstr "这是可在常见OTRS模块中找到的通用标头。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:712
msgid ""
"This part of the code has the main box and also the actions side bar. No "
"modifications are needed in this section."
msgstr "这部分代码有主框和动作侧栏。 本部分不需要修改。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:725
msgid ""
"In this section of the code is defined the right part of the dialog. Notice "
"that the value of the ``Action`` hidden input must match with the name of "
"the admin dialog."
msgstr ""
"在这部分代码中定义了对话框的右侧部分。 请注意，``Action`` 隐藏输入的值必须与"
"管理对话框的名称匹配。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:793
msgid ""
"This first widget contains the common form attributes for the dynamic "
"fields. For consistency with other dynamic fields is recommended to leave "
"this part of the code unchanged."
msgstr ""
"第一个小部件包含动态字段的通用表单属性。为了与其它动态字段保持一致，建议保持"
"代码的这部分不变。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:833
msgid ""
"The second widget has the dynamic field specific form attributes. This is "
"the place where new attributes can be set and it could use JavaScript and "
"AJAX technologies to make it more easy or friendly for the end user."
msgstr ""
"第二个小部件具有特定于动态字段的表单属性。这是可以设置新属性的地方，它可以使"
"用Javascript和AJAX技术使最终用户更容易或更友好。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:859
msgid ""
"The final part of the file contains the *Save* button and the *Cancel* link, "
"as well as other needed JavaScript code."
msgstr ""
"文件的最后一部分包含 *保存* 按钮和 *取消* 链接，以及其它需要的JavaScript代"
"码。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:863
msgid "Dynamic Field Driver Example"
msgstr "动态字段驱动程序示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:865
msgid ""
"The driver *is* the dynamic field. It contains several functions that are "
"used wide in the OTRS framework. A driver can inherit some functions form "
"base classes, for example ``TextArea`` driver inherits most of the functions "
"from ``Base.pm`` and ``BaseText.pm`` and it only implements the functions "
"that requires different logic or results. Checkbox field driver only "
"inherits from ``Base.pm`` as all other functions are very different from any "
"other base driver."
msgstr ""
"驱动程序 *即是* 动态字段。 它包含在OTRS框架中广泛使用的几个函数。 驱动程序可"
"以从基类继承一些函数，例如 ``TextArea`` 驱动程序从 ``Base.pm`` 和 ``BaseText."
"pm`` 继承大多数函数，它只实现需要不同逻辑的函数或结果。 复选框字段驱动程序仅"
"继承自 ``Base.pm``，因为所有其它函数与任何其它基本驱动程序非常不同。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:869
msgid ""
"Please refer to the Perl online documentation (POD) of the module ``/Kernel/"
"System/DynmicField/Backend.pm`` to have the list of all attributes and "
"possible return data for each function."
msgstr ""
"请参阅模块 ``/Kernel/System/DynmicField/Backend.pm`` 的Perl在线文档（POD），"
"以获得每个函数的所有属性和可能的返回数据的列表。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:871
msgid ""
"In this section the password dynamic field driver is shown and explained. "
"This driver inherits some functions from ``Base.pm`` and ``BaseText.pm`` and "
"only implements the functions that needs different results."
msgstr ""
"在本节中，将显示和解释password动态字段驱动程序。 这个驱动程序继承了 ``Base."
"pm`` 和 ``BaseText.pm`` 中的一些函数，只实现了需要不同结果的函数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:899
msgid ""
"This is the common header that can be found in common OTRS modules. The "
"class/package name is declared via the ``package`` keyword. Notice that "
"``BaseText`` is used as base class."
msgstr ""
"这是可在常见OTRS模块中找到的通用标头。 类/包名称通过 ``package`` 关键字声"
"明。 请注意，``BaseText`` 用作基类。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:961
msgid ""
"It is important to define the behaviors correctly as the field might or "
"might not be used in certain screens, functions that depends on behaviors "
"that are not active for this particular field might not be needed to be "
"implemented."
msgstr ""
"正确定义行为非常重要，因为在某些屏幕中可能会或可能不会使用该字段，可能不需要"
"实现依赖于对该特定字段不活动的行为的函数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:965
msgid ""
"Drivers are created only by the ``BackendObject`` and not directly from any "
"other module."
msgstr "驱动程序仅由 ``BackendObject`` 创建，而不是直接从任何其它模块创建。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1055
msgid ""
"This function is the responsible to create the HTML representation of the "
"field and its label, and is used in the edit screens like "
"``AgentTicketPhone``, ``AgentTicketNote``, etc."
msgstr ""
"此函数负责创建字段及其标签的HTML呈现，并在编辑屏幕（如 ``AgentTicketPhone``、"
"``AgentTicketNote`` 等）中使用。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1118
msgid ""
"``DisplayValueRender()`` function returns the field value as a plain text as "
"well as its title (both can be translated). For this particular example we "
"are checking if the password should be revealed or display a predefined mask "
"by a configuration parameter in the dynamic field."
msgstr ""
"``DisplayValueRender()`` 函数返回字段值作为纯文本及其标题（两者都可以翻"
"译）。 对于此特定示例，我们检查是否应显示密码或通过动态字段中的配置参数显示预"
"定义的掩码。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1163
msgid ""
"This function is similar to ``DisplayValueRender()`` but is used in places "
"where there is no ``LayoutObject``."
msgstr ""
"此函数类似于 ``DisplayValueRender()`` 但是用于没有 ``LayoutObject`` 的地方。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1167
msgid "Other Functions"
msgstr "其它函数"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1169
msgid ""
"The following are other functions that are might needed if the new dynamic "
"field does not inherit from other classes. To see the complete code of this "
"functions please take a look directly into the files ``Kernel/System/"
"DynamicField/Driver/Base.pm`` and ``Kernel/System/DynamicField/Driver/"
"BaseText.pm``."
msgstr ""
"如果新动态字段不从其它类继承，则以下是可能需要的其它函数。 要查看此函数的完整"
"代码，请直接查看文件 ``Kernel/System/DynamicField/Driver/Base.pm`` 和 "
"``Kernel/System/DynamicField/Driver/BaseText.pm``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1175
msgid ""
"This function retrieves the value from the field on a specified object. In "
"this case we are returning the first text value, since the field only stores "
"one text value at time."
msgstr ""
"此函数从指定对象上的字段中检索值。 在这种情况下，我们返回第一个文本值，因为该"
"字段仅存储一个文本值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1181
msgid ""
"This function is used to store a dynamic field value. In this case this "
"field only stores one text type value. Other fields could store more than "
"one value on either ``ValueText``, ``ValueDateTime`` or ``ValueInt`` format."
msgstr ""
"此函数用于存储动态字段值。 在这种情况下，该字段仅存储一个文本类型值。 其它字"
"段可以用 ``ValueText``、``ValueDateTime`` 或 ``ValueInt`` 格式存储多个值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1188
msgid ""
"This function is used to delete one field value attached to a particular "
"object ID. For example if the instance of an object is to be deleted, then "
"there is no reason to have the field value stored in the database for that "
"particular object instance."
msgstr ""
"此函数用于删除附加到特定对象ID的一个字段值。 例如，如果要删除对象的实例，则没"
"有理由将该字段值存储在该特定对象实例的数据库中。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1194
msgid ""
"This function is used to delete all values from a certain dynamic field. "
"This function is very useful when a dynamic field is going to be deleted."
msgstr ""
"此函数用于删除某个动态字段中的所有值。 要删除动态字段时，此功能非常有用。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1200
msgid "This function is used to check if the value is consistent to its type."
msgstr "此函数用于检查值是否与其类型一致。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1206
msgid ""
"This function is used by ``TicketSearch`` core module to build the internal "
"query to search for a ticket based on this field as a search parameter."
msgstr ""
"``TicketSearch`` 核心模块使用此函数构建内部查询，以基于此字段作为搜索参数搜索"
"工单。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1212
msgid ""
"This function is also a helper for ``TicketSearch`` module. ``"
"$Param{TableAlias}`` should be kept and ``value_text`` could be replaced "
"with ``value_date`` or ``value_int`` depending on the field."
msgstr ""
"此函数也是 ``TicketSearch`` 模块的一个helper。 ``$Param{TableAlias}`` 应该保"
"留，``value_text`` 可以用 ``value_date`` 或 ``value_int`` 替换，具体取决于字"
"段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1218
msgid ""
"This function is used in the edit screens of OTRS and its purpose is to get "
"the value of the field, either from a template like generic agent profile or "
"from a web request. This function gets the web request in the ``"
"$Param{ParamObject}``, that is a copy of the ``ParamObject`` of the front "
"end module or screen."
msgstr ""
"此函数用于OTRS的编辑屏幕，其目的是从自动任务配置文件或Web请求等模板获取字段的"
"值。 此函数在 ``$Param{ParamObject}`` 中获取Web请求，它是前端模块或屏幕的 "
"``ParamObject`` 的副本。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1220
msgid ""
"There are two return formats for this function. The normal that is just the "
"raw value or a structure that is the pair field name => field value. For "
"example a date dynamic field returns normally the date as string, and if it "
"should return a structure it returns a pair for each part of the date in the "
"hash."
msgstr ""
"此函数有两种返回格式。 通常只是 字段名称=>字段值 对的原始值或结构。 例如，日"
"期动态字段通常将日期作为字符串返回，如果它应返回结构，则它会为散列中的日期的"
"每个部分返回一对。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1222
msgid ""
"If the result should be a structure then, normally this is used to store its "
"values in a template, like a generic agent profile. For example a date field "
"uses several HTML components to build the field, like the used checkbox and "
"selects for year, month, day etc."
msgstr ""
"如果结果应该是结构，那么通常这用于将其值存储在模板中，如自动任务配置文件。 例"
"如，日期字段使用多个HTML组件来构建字段，如使用的复选框，并选择年、月、日等。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1229
msgid ""
"This function should provide at least a method to validate if the field is "
"empty, and return an error if the field is empty and mandatory, but it can "
"also do more validations for other kind of fields, like if the option "
"selected is valid, or if a date should be only in the past etc. It can "
"provide a custom error message also."
msgstr ""
"此函数应至少提供一种方法来验证字段是否为空，如果字段为空且是必需的，则返回错"
"误，但它也可以对其它类型的字段执行更多验证，例如，如果选择的选项有效，或者日"
"期是否应仅在过去等。它也可以提供自定义错误消息。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1235
msgid ""
"This function is used by ticket search dialog and it is similar to "
"``EditFieldRander()``, but normally on a search screen small changes has to "
"be done for all fields. For this example we use a HTML text input instead of "
"a password input. In other fields like drop-down field is displayed as a "
"multiple select in order to let the user search for more than one value at a "
"time."
msgstr ""
"工单搜索对话框使用此函数，它类似于 ``EditFieldRander()``，但通常在搜索屏幕"
"上，必须对所有字段进行小的更改。 对于此示例，我们使用HTML文本输入而不是密码输"
"入。 在其它字段中，下拉字段显示为多选，以便让用户一次搜索多个值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1241
msgid ""
"Very similar to ``EditFieldValueGet()``, but uses a different name prefix, "
"adapted for the search dialog screen."
msgstr ""
"非常类似于 ``EditFieldValueGet()``，但使用了不同的名称前缀，适用于搜索对话框"
"屏幕。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1247
msgid ""
"This function is used also by the ticket search dialog to set the correct "
"operator and value to do the search on this field. It also returns how the "
"value should be displayed in the used search attributes in the results page."
msgstr ""
"工单搜索对话框也使用此函数来设置正确的运算符和值，以便在此字段上进行搜索。 它"
"还返回值应在结果页面中使用的搜索属性中显示的方式。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1253
msgid ""
"This function is used by the stats modules. It includes the field definition "
"in the stats format. For fields with fixed values it also includes all this "
"possible values and if they can be translated, take a look to the "
"``BaseSelect`` driver code for an example how to implement those."
msgstr ""
"统计模块使用此函数。 它包括统计信息格式的字段定义。 对于具有固定值的字段，它"
"还包括所有这些可能的值，如果它们可以被转换，请查看 ``BaseSelect`` 驱动程序代"
"码，以获取如何实现它们的示例。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1259
msgid ""
"This function is very similar to the ``SearchFieldParameterBuild()``. The "
"difference is that the latter gets the value from the search profile and "
"this one gets the value directly from its parameters."
msgstr ""
"这个函数非常类似于 ``SearchFieldParameterBuild()``。 不同之处在于后者从搜索配"
"置文件中获取值，并且此值直接从其参数中获取值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1262
msgid "This function is used by statistics module."
msgstr "此函数用于统计模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1268
msgid ""
"This function is used to know how the dynamic field values stored on a "
"profile should be retrieved, as a scalar or as an array, and it also defines "
"the correct name of the field in the profile."
msgstr ""
"此函数用于了解如何检索存储在配置文件中的动态字段值，如标量或数组，还可以定义"
"配置文件中字段的正确名称。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1274
msgid ""
"This function is used by ``otrs.FillDB.pl`` script to populate the database "
"with some test and random data. The value inserted by this function is not "
"really relevant. The only restriction is that the value must be compatible "
"with the field value type."
msgstr ""
"``otrs.FillDB.pl`` 脚本使用此函数用一些测试和随机数据填充数据库。 此函数插入"
"的值并不真实相关。 唯一的限制是该值必须与字段值类型兼容。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-new-field.rst:1280
msgid ""
"Used by the notification modules. This function returns 1 if the field is "
"present in the ``$Param{ObjectAttributes}`` parameter and if it matches the "
"given value."
msgstr ""
"由通知模块使用。 如果字段出现在 ``$Param{ObjectAttributes}`` 参数中并且它与给"
"定值匹配，则此函数返回1。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-overview.rst:2
msgid "Overview"
msgstr "概览"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-overview.rst:4
msgid ""
"Dynamic fields are custom fields that can be added to a screen to enhance "
"and add information to an object (e.g. a ticket or an article)."
msgstr ""
"动态字段是可以添加到屏幕的自定义字段，以增强和添加信息到对象（例如工单或信"
"件）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-overview.rst:6
msgid ""
"Tickets or articles could have as many fields as needed. It is also possible "
"to use the dynamic fields framework for other objects rather than just "
"ticket or article."
msgstr ""
"工单或信件可以根据需要包含多个字段。 也可以将动态字段框架用于其它对象，而不仅"
"仅是工单或信件。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/dynamic-fields/dynamic-fields-overview.rst:9
msgid ""
"Due to its modular design each dynamic field type can be seen as a plug-in "
"to a framework, and this plug-in can be an OTRS standard package to extend "
"the available types of the dynamic fields or even to extend current dynamic "
"field with more functions."
msgstr ""
"由于其模块化设计，每个动态字段类型都可以看作框架的插件，这个插件可以是OTRS标"
"准包，用于扩展动态字段的可用类型，甚至可以扩展当前动态字段更多的功能。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:2
msgid "Invoker"
msgstr "调用程序"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:4
msgid ""
"The invoker is used to create a request from OTRS to a remote system. This "
"part of the GI is in charge of perform necessary tasks in OTRS side, to "
"gather the necessary data in order to construct the request."
msgstr ""
"调用程序用于创建从OTRS到远程系统的请求。 通用接口的这一部分负责在OTRS侧执行必"
"要的任务，以收集必要的数据以构建请求。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:8
msgid "Invoker Back End"
msgstr "调用程序后端"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:10
msgid ""
"Next we will show how to develop a new invoker. Each invoker has to "
"implement these subroutines:"
msgstr ""
"接下来我们将展示如何开发一个新的调用程序。 每个调用程序都必须实现这些子程序："

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:12
#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:42
#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:12
#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:21
#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:12
#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:633
msgid "``new``"
msgstr "``new``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:13
msgid "``PrepareRequest``"
msgstr "``PrepareRequest``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:14
msgid "``HandleResponse``"
msgstr "``HandleResponse``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:16
msgid ""
"We should implement each one of this methods in order to be able to execute "
"a request using the request handler (``Kernel/GenericInterface/Requester."
"pm``)."
msgstr ""
"我们应该实现这些方法中的每一个，以便能够使用请求处理程序（``Kernel/"
"GenericInterface/Requester.pm``）执行请求。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:20
msgid "Invoker Code Example"
msgstr "调用程序代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:22
msgid ""
"In this section a sample invoker module is shown and each subroutine is "
"explained."
msgstr "在本节中，将显示一个调用程序模块的样本，并解释每个子程序。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:46
msgid ""
"This is common header that can be found in common OTRS modules. The class/"
"package name is declared via the ``package`` keyword. Invokers can not be "
"instantiated by the object manager."
msgstr ""
"这是可在常见OTRS模块中找到的通用标头。类/包名称通过 ``package`` 关键字声明。 "
"调用程序无法由对象管理器实例化。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:70
#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:120
#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:69
#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:82
msgid ""
"The constructor ``new`` creates a new instance of the class. According to "
"the coding guidelines only objects of other classes not handled by the "
"object manager that are needed in this module have to be created in ``new``."
msgstr ""
"构造函数 ``new`` 创建了一个新的类实例。 根据编码指南，只有对象管理器没有处理"
"的其它类的对象才需要在在 ``new`` 中创建。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:102
msgid ""
"The ``PrepareRequest`` function is used to handle and collect all needed "
"data to be sent into the request. Here we can receive data from the request "
"handler, use it, extend it, generate new data, and after that, we can "
"transfer the results to the mapping layer."
msgstr ""
"``PrepareRequest`` 函数用于处理和收集要发送到请求中的所有需要的数据。 在这"
"里，我们可以从请求处理程序接收数据，使用它、扩展它、生成新数据并随后将结果传"
"输到映射层。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:104
msgid ""
"For this example we are expecting to receive a ticket number. If there isn't "
"then we use the debugger method ``Error()`` that creates an entry in the "
"debug log and also returns a structure with the parameter ``Success`` as 0 "
"and an error message as the passed ``Summary``."
msgstr ""
"对于此示例，我们希望收到一个工单编号。 如果没有那么我们使用调试器方法 "
"``Error()`` 在调试日志中创建一个条目，并返回一个参数 ``Success`` 为0的结构和"
"一个错误消息作为传递 ``Summary``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:106
msgid ""
"Also this example appends the word *Test* to the parameter ``Action`` and if "
"``GetSystemTime`` is requested, it will fill the ``SystemTime`` parameter "
"with the current system time. This part of the code is to prepare the data "
"to be sent. On a real invoker some calls to core modules (``Kernel/System/*."
"pm``) should be made here."
msgstr ""
"此示例还将单词 *Test* 附加到 ``Action`` 参数，如果请求 ``GetSystemTime``，它"
"将使用当前系统时间填充 ``SystemTime`` 参数。 这部分代码是准备要发送的数据。 "
"在一个真正的调用程序上，应该在这里调用核心模块(``Kernel/System/*.pm``)。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:108
msgid ""
"If during any part of the ``PrepareRequest`` function the request need to be "
"stop without generating and error an entry in the debug log the following "
"code can be used:"
msgstr ""
"如果在 ``PrepareRequest`` 函数的任何部分期间需要停止请求而不生成并在调试日志"
"中输入错误，则可以使用以下代码："

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:118
msgid ""
"Using this, the requester will understand that the request should not "
"continue (it will not be sent to mapping layer and will also not be sent to "
"the network transport). The requester will not send an error on the debug "
"log, it will only silently stop."
msgstr ""
"使用此方法，请求者将理解请求不应继续（它不会被发送到映射层，也不会被发送到网"
"络传输）。 请求者不会在调试日志上发送错误，它只会静默停止。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:168
msgid ""
"The ``HandleResponse`` function is used to receive and process the data from "
"the previous request, that was made to the remote system. This data already "
"passed by mapping layer, to transform it from remote system format to OTRS "
"format (if needed)."
msgstr ""
"``HandleResponse`` 函数用于接收和处理来自先前请求的数据，该数据是对远程系统进"
"行的。 此数据已由映射层传递，以将其从远程系统格式转换为OTRS格式（如果需要）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:171
msgid ""
"For this particular example it checks the ticket number again and check if "
"the action ends with the word *Test* (as was done in the ``PrepareRequest`` "
"function)."
msgstr ""
"对于这个特定的例子，它再次检查工单编号并检查操作是否以单词 *Test* 结束（如在 "
"``PrepareRequest`` 函数中所做的那样）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:175
msgid ""
"This invoker is only used for tests, a real invoker will check if the "
"response was on the format described by the remote system and can perform "
"some actions like: call another invoker, perform a call to a core module, "
"update the database, send an error, etc."
msgstr ""
"这个调用程序仅用于测试，真正的调用程序将检查响应是否采用远程系统描述的格式，"
"并且可以执行以下操作：调用另一个调用者、执行对核心模块的调用、更新数据库、发"
"送一个错误等。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:179
msgid "Invoker Configuration Example"
msgstr "调用程序配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-invoker.rst:181
msgid ""
"There is the need to register this invoker module to be accessible in the "
"OTRS GUI. This can be done using the XML configuration below."
msgstr ""
"需要注册此调用程序模块才能在OTRS GUI中访问。 这可以使用下面的XML配置来完成。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:2
msgid "Mapping"
msgstr "映射"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:4
msgid ""
"The mapping is used to convert data from OTRS to the external systems, and "
"vice versa. This data can be represented as key => value pairs. Mapping "
"modules can be developed to transform not just values but also the keys."
msgstr ""
"映射用于将数据从OTRS转换为外部系统，反之亦然。 该数据可以表示为key => value"
"对。 可以开发映射模块，不仅可以转换值，还可以转换键。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:6
msgid "For example:"
msgstr "例如："

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:9
msgid "Mapping from"
msgstr "映射自"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:9
msgid "Mapping to"
msgstr "映射至"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:11
msgid "Prio => Warning"
msgstr "Prio => Warning（优先级设为警告）"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:11
msgid "PriorityID => 3"
msgstr "PriorityID => 3（优先级ID设置为3）"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:14
msgid ""
"The mapping layer is not absolutely necessary, a web service can skip it "
"completely depending on the web service configuration and how invokers and "
"operation are implemented. But if some data transformations are needed, is "
"highly recommended to use an existing mapping module or create a new one."
msgstr ""
"映射层不是绝对必要的，Web服务可以完全跳过它，具体取决于Web服务配置以及如何实"
"现调用程序和操作。 但是，如果需要进行某些数据转换，强烈建议使用现有的映射模块"
"或创建新的映射模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:16
msgid ""
"Mapping modules can be called more than one time during a normal "
"communication, take a look to the following examples."
msgstr "在正常通信期间，可以多次调用映射模块，请看下面的示例。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:23
msgid "OTRS as provider example"
msgstr "OTRS作为提供程序示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:19
msgid ""
"The remote system sends the request with the data in the remote system "
"format."
msgstr "远程系统使用远程系统格式的数据发送请求。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:20
msgid "The data is mapped from the remote system format to the OTRS format."
msgstr "数据从远程系统格式映射到OTRS格式。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:21
msgid "OTRS performs the operation and return the response in OTRS format."
msgstr "OTRS执行操作并以OTRS格式返回响应。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:22
#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:27
msgid "The data is mapped from the OTRS format to the remote system format."
msgstr "数据从OTRS格式映射到远程系统格式。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:23
msgid ""
"The response with the data in the remote system format is sent to the remote "
"system."
msgstr "将远程系统格式的数据响应发送到远程系统。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:31
msgid "OTRS as requester example"
msgstr "OTRS作为请求程序的例子"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:26
msgid ""
"OTRS prepares the request to the remote system using the data in the OTRS "
"format."
msgstr "OTRS使用OTRS格式的数据准备对远程系统的请求。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:28
msgid ""
"The request is sent to the remote system which performs the action and sends "
"the response back to OTRS with the data in remote system format."
msgstr ""
"请求被发送到执行操作的远程系统，并使用远程系统格式的数据将响应发送回OTRS。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:29
msgid ""
"The data is mapped form remote system format (again) to the OTRS format."
msgstr "数据以远程系统格式（再次）映射到OTRS格式。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:30
msgid "OTRS processes the response."
msgstr "OTRS处理响应内容。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:34
msgid "Mapping Back End"
msgstr "映射后端"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:36
msgid ""
"Generic interface provides a mapping module called *Simple*. With this "
"module most of the data transformations including key and value mapping can "
"be done, and also it defines rules for to handling the default mappings for "
"both keys and values."
msgstr ""
"通用接口提供了一个名为 *Simple* 的映射模块。 使用此模块，可以完成大多数数据转"
"换，包括键和值映射，还定义了处理键和值的默认映射的规则。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:38
msgid ""
"So it is highly probable that you don't need to develop a custom mapping "
"module. Please check *Simple* mapping module (``Kernel/GenericInterface/"
"Mapping/Simple.pm``) and its on-line documentation before continue."
msgstr ""
"因此，您很可能不需要开发自定义映射模块。 在继续之前，请检查 *Simple* 映射模块"
"（``Kernel/GenericInterface/Mapping/Simple.pm``）及其在线文档。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:40
msgid ""
"If *Simple* mapping module does not match your needs then we will show how "
"to develop a new mapping back end. Each mapping back end has to implement "
"these subroutines:"
msgstr ""
"如果 *Simple* 映射模块不符合您的需求，那么我们将展示如何开发新的映射后端。 每"
"个映射后端都必须实现这些子程序："

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:43
msgid "``Map``"
msgstr "``Map``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:45
msgid ""
"We should implement each one of this methods in order to be able to map the "
"data in the communication, handled either by the requester or provider. All "
"mapping back ends are handled by the mapping module (``Kernel/"
"GenericInterface/Mapping.pm``)."
msgstr ""
"我们应该实现这些方法中的每一个，以便能够映射通信中的数据，由请求者或提供者处"
"理。 所有映射后端都由映射模块处理（``Kernel/GenericInterface/Mapping.pm``）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:49
msgid "Mapping Code Example"
msgstr "映射码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:51
msgid ""
"In this section a sample mapping module is shown and each subroutine is "
"explained."
msgstr "在本节中，将显示一个映射模块的样本，并解释每个子程序。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:74
msgid ""
"We also include ``VariableCheck`` module to perform certain validation over "
"some variables. Mappings can not be instantiated by the object manager."
msgstr ""
"我们还包括 ``VariableCheck`` 模块，用于对某些变量执行某些验证。 对象管理器无"
"法实例化映射。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:187
msgid ""
"The ``Map`` function is the main part of each mapping module. It receives "
"the mapping configuration (rules) and the data in the original format "
"(either OTRS or remote system format) and converts it to a new format, even "
"if the structure of the data can be changed during the mapping process."
msgstr ""
"``Map`` 函数是每个映射模块的主要部分。 它接收映射配置（规则）和原始格式的数据"
"（OTRS或远程系统格式）并将其转换为新格式，在映射过程中甚至可以更改数据结构。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:189
msgid ""
"In this particular example there are three rules to map the values. This "
"rules are set in the mapping configuration key ``TestOption`` and they are "
"``ToUpper``, ``ToLower`` and ``Empty``."
msgstr ""
"在此特定示例中，有三个规则来映射值。 此规则在映射配置键 ``TestOption`` 中设"
"置，它们是 ``ToUpper``、 ``ToLower`` 和 ``Empty``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:191
msgid "``ToUpper``: converts each data value to upper case."
msgstr "``ToUpper``：将每个数据值转换为大写。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:192
msgid "``ToLower``: converts each data value to lower case."
msgstr "``ToLower``：将每个数据值转换为小写。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:193
msgid "``Empty``: converts each data value into an empty string."
msgstr "``Empty``：将每个数据值转换为空字符串。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:195
msgid "In this example no data key transformations were implemented."
msgstr "在此示例中，未实现任何数据键转换。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:232
msgid ""
"This are the helper functions that actually performs the string conversions."
msgstr "这是实际执行字符串转换的辅助函数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:236
msgid "Mapping Configuration Example"
msgstr "映射配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-mapping.rst:238
msgid ""
"There is the need to register this mapping module to be accessible in the "
"OTRS GUI. This can be done using the XML configuration below."
msgstr ""
"需要将此映射模块注册以便在OTRS GUI中访问。 这可以使用下面的XML配置来完成。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:2
msgid "Operation"
msgstr "操作"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:4
msgid ""
"The operation is used to perform an action within OTRS. This action is "
"requested by the external system and can include special parameters in order "
"to correctly execute the action. After the action is performed, OTRS sends a "
"defined confirmation to the external system."
msgstr ""
"操作（operation ）用于在OTRS内执行一个动作（action）。 此动作由外部系统请求，"
"并且可以包含特殊参数以便正确执行动作。 执行此动作后，OTRS会向外部系统发送已定"
"义的确认。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:8
msgid "Operation Back End"
msgstr "操作的后端"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:10
msgid ""
"Next we will show how to develop a new operation, each operation has to "
"implement these subroutines:"
msgstr "接下来我们将展示如何开发一个新操作，每个操作都必须实现这些子程序："

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:13
#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:635
msgid "``Run``"
msgstr "``Run``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:15
msgid ""
"We should implement each one of this methods in order to be able to execute "
"the action handled by the provider (``Kernel/GenericInterface/Provider.pm``)."
msgstr ""
"我们应该实现这些方法中的每一个子程序，以便能够执行提供程序处理的动作"
"（``Kernel/GenericInterface/Provider.pm``）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:19
msgid "Operation Code Example"
msgstr "操作代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:21
msgid ""
"In this section a sample operation module is shown and each subroutine is "
"explained."
msgstr "在本节中，展示了一个示例操作模块，并解释了每个子程序。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:44
msgid ""
"We also include ``VariableCheck`` module to perform certain validation over "
"some variables. Operations can not be instantiated by the object manager."
msgstr ""
"我们还使用 ``VariableCheck`` 模块来对某些变量执行某些验证。 对象管理器无法实"
"例化操作。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:112
msgid ""
"The ``Run`` function is the main part of each operation. It receives all "
"internal mapped data from remote system needed by the provider to execute "
"the action, it performs the action and returns the result to the provider to "
"be external mapped and deliver back to the remote system."
msgstr ""
"``Run`` 函数是每个操作的主要部分。 它接收来自提供程序执行操作所需的远程系统的"
"所有内部映射数据，它执行动作并将结果返回给提供程序以进行外部映射并将其传送回"
"远程系统。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:114
msgid ""
"This particular example returns the same data as came from the remote "
"system, unless ``TestError`` parameter is passed. In this case it returns an "
"error."
msgstr ""
"此特定示例返回与远程系统相同的数据，除非传递了 ``TestError`` 参数。 在这种情"
"况下，它会返回错误。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:118
msgid "Operation Configuration Example"
msgstr "操作配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:120
msgid ""
"There is the need to register this operation module to be accessible in the "
"OTRS GUI. This can be done using the XML configuration below."
msgstr ""
"需要将此操作模块注册以便在OTRS GUI中访问。 这可以使用下面的XML配置来完成。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:139
msgid "Unit Test Example"
msgstr "单元测试示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:141
msgid ""
"Unit test for generic interface operations does not differs from other unit "
"tests but it is needed to consider testing locally, but also simulating a "
"remote connection. It is a good practice to test both separately since "
"results could be slightly different."
msgstr ""
"通用接口操作的单元测试与其它单元测试没有区别，但需要考虑本地测试，还需要模拟"
"一个远程连接。 由于结果可能略有不同，因此分别测试两者是一个好习惯。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:145
msgid ""
"To learn more about unit tests, please take a look to the :doc:`../../"
"contributing/unit-tests` chapter."
msgstr ""
"要学习有关单元测试的更多信息，请查看 :doc:`../../contributing/unit-tests` 一"
"章。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:147
msgid "The following is just the starting point for a unit test:"
msgstr "以下只是单元测试的起点："

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:427
msgid "WSDL Extension Example"
msgstr "WSDL扩展示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:429
msgid ""
"WSDL files contain the definitions of the web services and its operations "
"for SOAP messages, in case we will extend ``development/webservices/"
"GenericTickeConnectorSOAP.wsdl`` in some places:"
msgstr ""
"WSDL文件包含Web服务的定义及其SOAP消息的操作，本例中我们将在部分地方扩展 "
"``development/webservices/GenericTickeConnectorSOAP.wsdl``："

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:431
msgid "Port Type:"
msgstr "端口类型："

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:443
msgid "Binding:"
msgstr "绑定："

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:462
msgid "Type:"
msgstr "类型："

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:488
msgid "Message:"
msgstr "消息："

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:503
msgid "WADL Extension Example"
msgstr "WADL扩展示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:505
msgid ""
"WADL files contain the definitions of the web services and its operations "
"for REST interface, add a new resource to ``development/webservices/"
"GenericTickeConnectorREST.wadl``."
msgstr ""
"WADL文件包含Web服务的定义及其REST接口的操作，向 ``development/webservices/"
"GenericTickeConnectorREST.wadl`` 添加新资源。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:529
msgid "Web Service SOAP Extension Example"
msgstr "Web服务SOAP扩展示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:531
msgid ""
"Web services can be imported into OTRS by a YAML with a predefined structure "
"in this case we will extend ``development/webservices/"
"GenericTickeConnectorSOAP.yml`` for a SOAP web service."
msgstr ""
"Web服务可以通过具有预定义结构的YAML导入到OTRS中，在本例中我们将为SOAP Web服务"
"扩展 ``development/webservices/GenericTickeConnectorSOAP.yml``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:546
msgid "Web Service REST Extension Example"
msgstr "Web服务REST扩展示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-operation.rst:548
msgid ""
"Web services can be imported into OTRS by a YAML with a predefined structure "
"in this case we will extend ``development/webservices/"
"GenericTickeConnectorREST.yml`` for a REST web service."
msgstr ""
"Web服务可以通过具有预定义结构的YAML导入到OTRS中，在本例中我们将为REST Web服务"
"扩展 ``development/webservices/GenericTickeConnectorREST.yml`` 。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:2
msgid "Network Transport"
msgstr "网络传输"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:4
msgid ""
"The network transport is used as method to send and receive information "
"between OTRS and a remote system. The generic interface configuration allows "
"a web service to use different network transport modules for provider and "
"requester, but the most common scenario is that the same transport module is "
"used for both."
msgstr ""
"网络传输用作在OTRS和远程系统之间发送和接收信息的方法。 通用接口配置允许Web服"
"务为提供程序和请求程序使用不同的网络传输模块，但最常见的情况是两者都使用相同"
"的传输模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:8
msgid "OTRS as provider"
msgstr "OTRS作为服务提供方"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:8
msgid ""
"OTRS uses the network transport modules to get the data from the remote "
"system and the operation to be executed. After the operation is performed "
"OTRS uses them again to send the response back to the remote system."
msgstr ""
"OTRS使用网络传输模块从远程系统获取数据并执行操作。 执行操作后，OTRS再次使用网"
"络传输模块将响应发送回远程系统。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:11
msgid "OTRS as requester"
msgstr "OTRS作为服务请求方"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:11
msgid ""
"OTRS uses the network transport modules to send petitions to the remote "
"system to perform a remote action along with the required data. OTRS waits "
"for the remote system response and send it back to the requester module."
msgstr ""
"OTRS使用网络传输模块向远程系统发送请求以执行远程操作以及所需数据。 OTRS等待远"
"程系统响应并将其发送回请求者模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:13
msgid ""
"In both ways network transport modules deal with the data in the remote "
"system format. It is not recommended to do any data transformation in this "
"modules, as the mapping layer is the responsible to perform any data "
"transformation needed during the communication. An exception of this is the "
"data conversion that is required specifically by for the transport e.g. XML "
"or JSON from / to Perl conversions."
msgstr ""
"在这两种方式中，网络传输模块处理远程系统格式的数据。 建议不要在此模块中进行任"
"何数据转换，因为映射层负责执行通信期间所需的任何数据转换。 例外情况是传输中特"
"别需要的数据转换，例如 从或到Perl转换的XML或JSON。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:17
msgid "Transport Back End"
msgstr "传输后端"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:19
msgid ""
"Next we will show how to develop a new transport back end. Each transport "
"back end has to implement these subroutines:"
msgstr ""
"接下来我们将展示如何开发新的传输后端。 每个传输后端都必须实现这些子程序："

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:22
msgid "``ProviderProcessRequest``"
msgstr "``ProviderProcessRequest``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:23
msgid "``ProviderGenerateResponse``"
msgstr "``ProviderGenerateResponse``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:24
msgid "``RequesterPerformRequest``"
msgstr "``RequesterPerformRequest``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:26
msgid ""
"We should implement each one of this methods in order to be able to "
"communicate correctly with a remote system in both ways. All network "
"transport back ends are handled by the transport module (``Kernel/"
"GenericInterface/Transport.pm``)."
msgstr ""
"我们应该实现这些方法中的每一种，以便能够以两种方式与远程系统正确通信。 所有网"
"络传输后端都由传输模块（``Kernel/GenericInterface/Transport.pm``）处理。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:28
msgid ""
"Currently generic interface implements the HTTP SOAP and HTTP REST "
"transports. If the planned web service can use HTTP SOAP or HTTP SOAP there "
"is no need to create a new network transport module, instead we recommend to "
"take a look into HTTP SOAP or HTTP REST configurations to check their "
"settings and how it can be tuned according to the remote system."
msgstr ""
"当前通用接口实现HTTP SOAP和HTTP REST传输。 如果计划的Web服务可以使用HTTP SOAP"
"或HTTP REST，则无需创建新的网络传输模块，而是建议您查看HTTP SOAP或HTTP REST配"
"置以检查其设置以及如何根据远程系统进行调整。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:32
msgid "Network Transport Code Example"
msgstr "网络传输代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:34
msgid ""
"In case that the provided network transports does not match the web service "
"needs, then in this section a sample network transport module is shown and "
"each subroutine is explained. Normally transport modules uses CPAN modules "
"as back ends. For example the HTTP SOAP transport modules uses ``SOAP::"
"Lite`` module as back end."
msgstr ""
"如果提供的网络传输与Web服务需求不匹配，则在本节中展示一个示例网络传输模块，并"
"解释每个子程序。 通常，传输模块使用CPAN模块作为后端。 例如，HTTP SOAP传输模块"
"使用 ``SOAP::Lite`` 模块作为后端。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:36
msgid ""
"For this example a custom package is used to return the data without doing a "
"real network request to a remote system, instead this custom module acts as "
"a loop-back interface."
msgstr ""
"对于此示例，自定义包用于返回数据而不向远程系统发出真实的网络请求，而是将此自"
"定义模块用作环回接口。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:62
msgid ""
"This is common header that can be found in common OTRS modules. The class/"
"package name is declared via the ``package`` keyword. Transports can not be "
"instantiated by the object manager."
msgstr ""
"这是可在常见OTRS模块中找到的通用标头。类/包名称通过 ``package`` 关键字声明。 "
"传输无法由对象管理器实例化。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:124
msgid ""
"The ``ProviderProcessRequest`` function gets the request from the remote "
"system (in this case the same OTRS) and extracts the data and the operation "
"to perform from the request. For this example the operation is always "
"``test_operation``."
msgstr ""
"``ProviderProcessRequest`` 函数从远程系统获取请求（在本例中与OTRS相同），并从"
"请求中提取数据和要执行的操作。 对于这个例子，操作总是 ``test_operation``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:126
msgid ""
"The way this function parses the request to get the data and the operation "
"name, depends completely on the protocol to be implemented and the external "
"modules that are used for."
msgstr ""
"此函数解析请求以获取数据和操作名称的方式，完全取决于要实现的协议和用于的外部"
"模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:176
msgid ""
"This function sends the response back to the remote system for the requested "
"operation."
msgstr "此函数将响应发送回远程系统以进行请求的操作。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:178
msgid ""
"For this particular example we return a standard HTTP response success (200) "
"or not (500), along with the required data on each case."
msgstr ""
"对于此特定示例，我们返回标准HTTP响应成功（200）或不成功（500），以及每种情况"
"下所需的数据。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:209
msgid ""
"This is the only function that is used by OTRS as requester. It sends the "
"request to the remote system and waits for its response."
msgstr ""
"这是OTRS作为请求者使用的唯一函数。 它将请求发送到远程系统并等待其响应。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:211
msgid ""
"For this example we use a custom protocol handler to avoid send the request "
"to the real network. This custom protocol is specified below."
msgstr ""
"对于此示例，我们使用自定义协议处理程序来避免将请求发送到真实网络。 此自定义协"
"议如下所示。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:242
msgid ""
"This is the code for the custom protocol that we use. This approach is only "
"useful for training or for testing environments where the remote systems are "
"not available."
msgstr ""
"这是我们使用的自定义协议的代码。 此方法仅适用于培训或测试远程系统不可用的环"
"境。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:244
msgid ""
"For a new module development we do not recommend to use this approach, a "
"real protocol needs to be implemented."
msgstr "对于新模块开发，我们不建议使用此方法，需要实现真正的协议。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:248
msgid "Network Transport Configuration Example"
msgstr "网络传输配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/gi-transport.rst:250
msgid ""
"There is the need to register this network transport module to be accessible "
"in the OTRS GUI. This can be done using the XML configuration below."
msgstr ""
"需要将该网络传输模块注册以便在OTRS GUI中访问。 这可以使用下面的XML配置来完"
"成。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/log.rst:2
msgid "Log Module"
msgstr "日志模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/log.rst:4
msgid ""
"There is a global log interface for OTRS that provides the possibility to "
"create own log back ends."
msgstr "OTRS有一个全局日志接口，可以创建自己的日志后端。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/log.rst:6
msgid ""
"Writing an own logging back end is as easy as reimplementing the ``Kernel::"
"System::Log::Log()`` method."
msgstr ""
"编写自己的日志记录后端就像重新实现 ``Kernel::System::Log::Log()`` 方法一样简"
"单。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/log.rst:10
msgid "Log Module Code Example"
msgstr "日志模块代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/log.rst:12
msgid ""
"In this small example, we'll write a little file logging back end which "
"works similar to ``Kernel::System::Log::File``, but prepends a string to "
"each logging entry."
msgstr ""
"在这个小例子中，我们将编写一个小的文件日志后端，其工作方式类似于 ``Kernel::"
"System::Log::File``，但是为每个日志条目添加一个字符串。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/log.rst:115
msgid "Log Module Configuration Example"
msgstr "日志模块配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/log.rst:117
msgid ""
"To activate our custom logging module, the administrator can either set the "
"existing configuration item ``LogModule`` manually to ``Kernel::System::Log::"
"CustomFile``. To realize this automatically, you can provide an XML "
"configuration file which overrides the default setting."
msgstr ""
"要激活我们的自定义日志模块，管理员可以手动将现有配置项 ``LogModule`` 设置为 "
"``Kernel::System::Log::CustomFile``。 要自动实现此功能，您可以提供覆盖默认设"
"置的XML配置文件。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/log.rst:132
msgid "Log Module Use Case Example"
msgstr "日志模块用例示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/log.rst:134
msgid ""
"Useful logging back ends could be logging to a web service or to encrypted "
"files."
msgstr "有用的日志后端可以记录到Web服务或加密文件。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/log.rst:138
msgid ""
"``Kernel::System::Log`` has other methods than ``Log()`` which cannot be "
"reimplemented, for example code for working with shared memory segments and "
"log data caching."
msgstr ""
"``Kernel::System::Log`` 除了 ``Log()`` 之外还有其它方法，它们不能重新实现，例"
"如用于处理共享内存段和日志数据缓存的代码。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/notify.rst:2
msgid "Notification Module"
msgstr "通知模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/notify.rst:4
msgid ""
"Notification modules are used to display a notification below the main "
"navigation. You can write and register your own notification module. There "
"are currently 5 ticket menus in the OTRS framework."
msgstr ""
"通知模块用于在主导航下方显示通知。 您可以编写和注册自己的通知模块。 OTRS框架"
"中目前有5个工单菜单。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/notify.rst:6
msgid "``AgentOnline``"
msgstr "``AgentOnline``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/notify.rst:7
msgid "``AgentTicketEscalation``"
msgstr "``AgentTicketEscalation``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/notify.rst:8
msgid "``CharsetCheck``"
msgstr "``CharsetCheck``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/notify.rst:9
msgid "``CustomerOnline``"
msgstr "``CustomerOnline``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/notify.rst:10
msgid "``UIDCheck``"
msgstr "``UIDCheck``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/notify.rst:14
msgid "Notification Module Code Example"
msgstr "通知模块代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/notify.rst:16
msgid ""
"The notification modules are located under ``Kernel/Output/HTML/"
"TicketNotification*.pm``. Following, there is an example of a notify module. "
"Save it under ``Kernel/Output/HTML/TicketNotificationCustom.pm``. You just "
"need 2 functions: ``new()`` and ``Run()``."
msgstr ""
"通知模块位于 ``Kernel/Output/HTML/TicketNotification*.pm``。 下面是一个通知模"
"块的示例。 将它保存为 ``Kernel/Output/HTML/TicketNotificationCustom.pm``。 你"
"只需要2个函数：``new()`` 和 ``Run()``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/notify.rst:92
msgid "Notification Module Configuration Example"
msgstr "通知模块配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/notify.rst:94
msgid ""
"There is the need to activate your custom notification module. This can be "
"done using the XML configuration below. There may be additional parameters "
"in the config hash for your notification module."
msgstr ""
"需要激活自定义通知模块。 这可以使用下面的XML配置来完成。 通知模块的配置哈希中"
"可能还有其它参数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/notify.rst:113
msgid "Notification Module Use Case Example"
msgstr "通知模块用例示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/notify.rst:115
#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-menu.rst:138
msgid ""
"Useful ticket menu implementation could be a link to an external tool if "
"parameters (e.g. ``FreeTextField``) have been set."
msgstr ""
"如果已设置参数（例如 ``FreeTextField``），则有用的工单菜单实现可以是指向外部"
"工具的链接。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:2
msgid "Output Filter"
msgstr "输出过滤器"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:4
msgid ""
"Output filters allow to modify HTML on the fly. It is best practice to use "
"output filters instead of modifying ``.tt`` files directly. There are three "
"good reasons for that. When the same adaptation has to be applied to several "
"front end modules then the adaption only has to be implemented once. The "
"second advantage is that when OTRS is upgraded there is a chance that the "
"filter doesn't have to be updated, when the relevant pattern has not "
"changed. When two extensions modify the same file there is a conflict during "
"the installation of the second package. This conflict can be resolved by "
"using two output filters that modify the same front end module."
msgstr ""
"输出过滤器允许动态修改HTML。 最佳做法是使用输出过滤器而不是直接修改 ``.tt`` "
"文件。 这有三个很好的理由。 当必须将相同的适配应用于多个前端模块时，则仅需要"
"实现一次适配。 第二个优点是当OTRS升级时，当相关模式没有改变时，有可能不必更新"
"过滤器。 当两个扩展修改同一文件时，在安装第二个包期间会发生冲突。 通过使用修"
"改相同前端模块的两个输出过滤器可以解决此冲突。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:7
msgid ""
"There are three different kinds of output filters. They are active at "
"different stages of the generation of HTML content."
msgstr "有三种不同的输出过滤器。 他们在生成HTML内容的不同阶段激活。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:11
msgid "``FilterElementPost``"
msgstr "``FilterElementPost``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:13
msgid ""
"These filters allow to modify the output of a template after it was rendered."
msgstr "这些过滤器允许在渲染模板后修改模板的输出。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:15
msgid ""
"To translate content, you can run ``$LayoutObject->Translate()`` directly. "
"If you need other template features, just define a small template file for "
"your output filter and use it to render your content before injecting it "
"into the main data. It can also be helpful to use jQuery DOM operations to "
"reorder/replace content on the screen in some cases instead of using regular "
"expressions. In this case you would inject the new code somewhere in the "
"page as invisible content (e. g. with the class ``Hidden``), and then move "
"it with jQuery to the correct location in the DOM and show it."
msgstr ""
"要翻译内容，您可以直接运行 ``$LayoutObject->Translate()`` 。 如果您需要其它模"
"板功能，只需为输出过滤器定义一个小的模板文件，并在将其注入主数据之前使用它来"
"呈现您的内容。 在某些情况下使用jQuery DOM操作来重新排序/替换屏幕上的内容，而"
"不是使用正则表达式也是有帮助的。 在这种情况下，您会将新代码注入页面中的某个地"
"方作为不可见的内容（例如，使用 ``Hidden`` 类），然后将其与jQuery一起移动到DOM"
"中的正确位置并显示它。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:17
msgid ""
"To make using post output filters easier, there is also a mechanism to "
"request HTML comment hooks for certain templates/blocks. You can add in your "
"module config XML like:"
msgstr ""
"为了更容易地使用渲染后输出过滤器，还有一种机制来为某些模板/块请求HTML注释钩"
"子。 您可以在模块中添加配置XML，如："

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:35
msgid ""
"This will cause the block ``CustomerTable`` in ``AgentTicketZoom.tt`` to be "
"wrapped in HTML comments each time it is rendered:"
msgstr ""
"这将导致 ``AgentTicketZoom.tt`` 中的 ``CustomerTable`` 块在每次渲染时都封装在"
"HTML注释中："

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:43
msgid ""
"With this mechanism every package can request just the block hooks it needs, "
"and they are consistently rendered. These HTML comments can then be used in "
"your output filter for easy regular expression matching."
msgstr ""
"使用这种机制，每个包都可以请求它所需的块钩子，并且它们一致地被渲染。 然后，可"
"以在输出过滤器中使用这些HTML注释，以便于正则表达式匹配。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:47
msgid "``FilterContent``"
msgstr "``FilterContent``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:49
msgid ""
"This kind of filter allows to process the complete HTML output for the "
"request right before it is sent to the browser. This can be used for global "
"transformations."
msgstr ""
"这种过滤器允许在将请求发送到浏览器之前处理请求的完整HTML输出。 这可以用于全局"
"转换。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:53
msgid "``FilterText``"
msgstr "``FilterText``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:55
msgid ""
"This kind of output filter is a plugin for the method ``Kernel::Output::"
"HTML::Layout::Ascii2HTML()`` and is only active when the parameter "
"``LinkFeature`` is set to 1. Thus the ``FilterText`` output filters are "
"currently only active for the display of the body of plain text articles. "
"Plain text articles are generated by incoming non-HTML mails and when OTRS "
"is configured to not use the Rich Text feature in the front end."
msgstr ""
"这种输出过滤器是 ``Kernel::Output::HTML::Layout::Ascii2HTML()`` 方法的插件，"
"仅当参数 ``LinkFeature`` 设置为1时才有效。这样 ``FilterText`` 输出过滤器目前"
"仅用于显示纯文本信件的正文。 纯文本信件由传入的非HTML邮件生成，并且OTRS配置为"
"不在前端使用富文本功能。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:59
msgid "Output Filter Code Example"
msgstr "输出过滤器代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:61
msgid ""
"See package `TemplateModule <https://github.com/OTRS/TemplateModule/tree/"
"master/Kernel/Output/HTML>`__."
msgstr ""
"请参阅软件包 `TemplateModule <https://github.com/OTRS/TemplateModule/tree/"
"master/Kernel/Output/HTML>`__。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:65
msgid "Output Filter Configuration Example"
msgstr "输出过滤器配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:67
msgid ""
"See package `TemplateModule <https://github.com/OTRS/TemplateModule/tree/"
"master/Kernel/Config/Files>`__."
msgstr ""
"请参阅软件包 `TemplateModule <https://github.com/OTRS/TemplateModule/tree/"
"master/Kernel/Config/Files>`__。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:71
msgid "Output Filter Use Case Example"
msgstr "输出过滤器用例示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:74
msgid "Show additional ticket attributes in ``AgentTicketZoom``"
msgstr "在 ``AgentTicketZoom`` 中显示其它工单属性"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:74
msgid "This can be achieved with a ``FilterElementPost`` output filter."
msgstr "这可以通过 ``FilterElementPost`` 输出过滤器来实现。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:77
msgid "Show the service selection as a multi level menu"
msgstr "将服务选择显示为多级菜单"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:77
msgid ""
"Use a ``FilterElementPost`` for this feature. The list of selectable "
"services can be parsed from the processed template output. The multi level "
"selection can be constructed from the service list and inserted into the "
"template content. A ``FilterElementPost`` output filter must be used for "
"that."
msgstr ""
"对此功能使用 ``FilterElementPost``。 可以从处理的模板输出中解析可选服务的列"
"表。 可以从服务列表构造多级选择并将其插入到模板内容中。 必须使用 "
"``FilterElementPost`` 输出过滤器。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:80
msgid "Create links within plain text article bodies"
msgstr "在纯文本信件正文中创建链接"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:80
msgid ""
"A biotech company uses gene names like IPI00217472 in plain text articles. A "
"``FilterText`` output filter can be used to create links to a sequence "
"database, e.g. http://srs.ebi.ac.uk/srsbin/cgi-bin/wgetz?-e+[IPI-acc:"
"IPI00217472]+-vn+2, for the gene names."
msgstr ""
"一家生物技术公司在纯文章文章中使用IPI00217472等基因名称。 可以使用 "
"``FilterText`` 输出过滤器来创建到序列数据库的链接，例如，用于基因名称的 "
"http://srs.ebi.ac.uk/srsbin/cgi-bin/wgetz?-e+[IPI-acc:IPI00217472 ]+-vn+2。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:83
msgid "Prohibit active content"
msgstr "禁止有效内容"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:83
msgid ""
"There is firewall rule that disallows all active content. In order to avoid "
"rejection by the firewall, the HTML tag ``<applet>`` can be filtered with a "
"``FilterContent`` output filter."
msgstr ""
"防火墙规则禁止所有活动内容。 为了避免被防火墙拒绝，可以使用 "
"``FilterContent`` 输出过滤器过滤HTML的 ``<applet>`` 标签。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:87
msgid ""
"Every ``FilterElementPost`` output filter is constructed and run for every "
"configured template that is needed for the current request. Thus low "
"performance of the output filter or a large number of filters can severely "
"degrade performance."
msgstr ""
"为当前请求所需的每个配置模板构造并运行每个 ``FilterElementPost`` 输出过滤器。"
"因此，低性能的输出过滤器或大量的过滤器会严重降低性能。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:91
msgid "Best Practices"
msgstr "最佳实践"

#: ../../content/how-to-extend-otrs/otrs-module-layers/outputfilter.rst:93
msgid ""
"In order to increase flexibility the list of affected templates should be "
"configured in system configuration."
msgstr "为了增加灵活性，应在系统配置中配置受影响的模板列表。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:4
msgid ""
"Since OTRS 7 process management can use script modules to perform activities "
"(script tasks) and/or sequence flow actions (know before as transition "
"actions). This modules are located in ``Kernel::System::ProcessManagement::"
"Modules``."
msgstr ""
"由于OTRS 7流程管理可以使用脚本模块来执行活动（脚本任务）和/或序列流操作（之前"
"称为转换操作）。 这些模块位于 ``Kernel::System::ProcessManagement::Modules`` "
"中。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:8
msgid "Process Management Modules"
msgstr "流程管理模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:10
msgid ""
"The process management modules are scripts written in Perl language to "
"perform certain action or actions over the process ticket like set a dynamic "
"field or change a queue. Or to any other part of the system like create new "
"tickets."
msgstr ""
"流程管理模块是用Perl语言编写的脚本，用于执行某些操作或基于流程工单的操作（如"
"设置动态字段或更改队列）。 或者到系统的任何其它部分，比如创建新工单。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:12
msgid ""
"By default modules use a set of key value pairs to use them as parameters "
"for the action e.g. to change queue of the process ticket, the queue or "
"queue ID and its corresponding value is needed."
msgstr ""
"默认情况下，模块使用一组键值对将它们用作操作的参数，例如： 要更改流程工单的队"
"列，需要队列或队列ID及其对应的值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:14
msgid ""
"Some scripts might require more than a simple key value pairs as parameters "
"or its configuration might need to have a more user friendly GUI. In such "
"cases OTRS provides some configuration field types that can be also extended "
"if needed."
msgstr ""
"某些脚本可能需要多个简单的键值对作为参数，或者其配置可能需要具有更加用户友好"
"的GUI。 在这种情况下，OTRS提供了一些配置字段类型，如果需要也可以扩展。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:16
msgid "Current field types:"
msgstr "当前字段类型："

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:19
msgid "Dropdown"
msgstr "下拉选择框"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:19
msgid "Shows a drop-down list with predefined values."
msgstr "显示包含预定义值的下拉列表框。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:22
msgid "Key-value list"
msgstr "键-值列表"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:22
msgid ""
"Shows a list of simple key value pairs (text inputs). Pairs can be added or "
"deleted."
msgstr "显示简单键值对（文本输入）的列表。 可以添加或删除键值对。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:25
msgid "Multi language Rich Text"
msgstr "多语言富文本"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:25
msgid ""
"Shows a Rich Text editor associated to a system language, also shows a "
"language selector to add Rich Text fields for the proper selected language."
msgstr ""
"显示与系统语言关联的富文本编辑器，还显示语言选择器，以便为选择的特定语言添加"
"富文本字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:28
msgid "Recipients"
msgstr "收件人"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:28
msgid ""
"Shows a multi select field pre-filled with agents to be used as email "
"recipients, also displays a free input field to be used to specify external "
"email addresses to be added to the recipients list."
msgstr ""
"显示一个多选字段，其中预先填充了用作电子邮件收件人的服务人员，还显示一个自由"
"输入字段，用于指定要添加到收件人列表中的外部电子邮件地址。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:32
msgid "Rich Text"
msgstr "富文本"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:31
msgid "Shows a single Rich Text field."
msgstr "显示单个富文本字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:35
msgid "Creating a New Process Management Module"
msgstr "创建新的流程管理模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:37
msgid ""
"The following is an example of how to create a process management module. It "
"includes a section where all possible fields are defined as a reference. To "
"create a new module only one field type is needed but consider that by "
"convention the parameter user ID is used to impersonate all the actions in "
"the module with another user than the one that triggers the action. Then it "
"is a good practice to always include the key-value list field type along "
"with any other needed field."
msgstr ""
"下面是如何创建流程管理模块的示例。 它包括一个部分，其中所有可能的字段都被定义"
"为一个引用。 要创建新模块，只需要一种字段类型，但考虑到按照惯例，用户ID参数用"
"于模拟模块中的所有操作，而不是触发操作的用户。 然后，最好始终包含键值列表字段"
"类型以及任何其它所需字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:41
msgid "Process Management Module Code Example"
msgstr "流程管理模块代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:43
msgid ""
"The following code implements a dummy process management module that can be "
"used in script task activities or sequence flow actions."
msgstr "以下代码实现了一个虚拟的流程管理模块，可用于脚本任务活动或序列流操作。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:69
msgid ""
"In this case we are inheriting from ``Base`` class, and the object manager "
"dependencies are set."
msgstr "在本例中我们继承自 ``Base`` 类，并设置了对象管理器依赖项。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:154
msgid ""
"The constructor ``new()`` creates a new instance of the class. The "
"configuration fields are defined here and they are set in ``$Self->{Config}"
"``."
msgstr ""
"构造函数 ``new()`` 创建一个新的类实例。 配置字段在这里定义，它们在 ``$Self-"
">{Config}`` 中设置。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:156
msgid "The configuration has two main entries:"
msgstr "该配置有两个主要条目："

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:159
msgid "``Description``"
msgstr "``Description``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:159
msgid ""
"This is used to explain the administrators what does the module do and/or "
"considerations for its configuration."
msgstr "这用于向管理员解释模块执行的操作和/或其配置注意事项。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:162
msgid "``ConfigSets``"
msgstr "``ConfigSets``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:162
msgid "This is just a container for the actual configuration fields."
msgstr "这只是实际配置字段的容器。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:164
msgid ""
"All configuration fields requires a type that defines the kind of field and "
"they could also have an internal description to be used as the title of the "
"field widget. If it is not defined, a default description is used."
msgstr ""
"所有配置字段都需要一个定义字段类型的类型，并且它们还可以具有内部描述以用作字"
"段小部件的标题。 如果未定义，则使用默认描述。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:166
msgid ""
"Each field defines its configuration parameters and capabilities. The "
"following is a small reference for the fields provided by OTRS out of the "
"box."
msgstr ""
"每个字段定义其配置参数和功能。 以下是OTRS提供的开箱即用的字段的小参考。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:168
msgid "``Dropdown``"
msgstr "``Dropdown``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:171
#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:206
#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:232
msgid "``Mandatory``"
msgstr "``Mandatory``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:171
#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:232
msgid "Used to define if a value is required to be set."
msgstr "用于定义是否必须设置值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:192
msgid "``Config``"
msgstr "``Config``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:174
msgid "Holds the information to display the drop-down field."
msgstr "保存信息以显示下拉选择框字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:177
#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:712
msgid "``Data``"
msgstr "``Data``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:177
msgid ""
"Simple hash that defines the options for the drop-down. The keys are used "
"internally, and the values are the options that the user sees in the screen."
msgstr ""
"简单哈希定义下拉选择框的选项。 键在内部使用，值是用户在屏幕中看到的选项。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:180
#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:146
#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:709
msgid "``Name``"
msgstr "``Name``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:180
msgid "The name of the parameter."
msgstr "参数的名称。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:183
msgid "``Multiple``"
msgstr "``Multiple``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:183
msgid "To define if only one or multiple values can be selected."
msgstr "定义是否只能选择一个或多个值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:186
msgid "``PossibleNone``"
msgstr "``PossibleNone``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:186
msgid "Defines if the list of values offer an empty value or not."
msgstr "定义值列表是否提供空值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:189
msgid "``Sort``"
msgstr "``Sort``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:189
msgid ""
"Defines how the options will be sorted when the field is rendered. The "
"possible values are: ``AlphanumericValue``, ``NumericValue``, "
"``AlphanumericKey`` and ``NumericKey``."
msgstr ""
"定义在渲染字段时如何对选项进行排序。 可能的值是：``AlphanumericValue``、"
"``NumericValue``、``AlphanumericKey`` 和 ``NumericKey``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:192
msgid "``Translation``:"
msgstr "``Translation``:"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:192
msgid "Set if the displayed values should be translated."
msgstr "设置是否应翻译显示的值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:194
msgid "``KeyValueList``"
msgstr "``KeyValueList``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:206
#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:217
#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:232
msgid "``Defaults``"
msgstr "``Defaults``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:197
msgid ""
"Array of hashes that holds the default configuration for its key value pairs."
msgstr "包含其键值对的默认配置的哈希数组。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:200
#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:214
msgid "``Key``"
msgstr "``Key``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:200
msgid "The name of a parameter."
msgstr "参数的名称。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:203
#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:217
#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:229
msgid "``Value``"
msgstr "``Value``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:203
msgid "The default value of the parameter (optional)."
msgstr "参数的默认值（可选）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:206
msgid "Mandatory parameters can not be renamed or removed (optional)."
msgstr "不能重命名或删除必填参数（可选）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:208
msgid "``MultiLanguageRichText``"
msgstr "``MultiLanguageRichText``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:211
msgid ""
"Array of hashes that holds the default configuration each language and field "
"part."
msgstr "哈希数组，包含每个语言和字段部分的默认配置。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:214
msgid ""
"This is composed by language such as ``en`` or ``es_MX``, followed by a "
"``_`` (underscore character) and then ``Subject`` or ``Body`` for the "
"corresponding part of the field."
msgstr ""
"它由 ``en`` 或 ``es_MX`` 等语言组成，后跟一个 ``_`` （下划线字符），然后是 "
"``Subject`` 或 ``Body``，用于字段相应的部分。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:217
msgid "The default value of the field part (optional)."
msgstr "字段部分的默认值（可选）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:219
msgid "``Recipients``"
msgstr "``Recipients``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:221
msgid "No further configuration is provided for this kind of field."
msgstr "没有为这种字段提供进一步的配置。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:223
msgid "``RichText``"
msgstr "``RichText``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:226
msgid ""
"Array of hashes that holds the default configuration field (only the first "
"element is used)."
msgstr "保存默认配置字段的哈希数组（仅使用第一个元素）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:229
msgid "The default value of the field."
msgstr "该字段的默认值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:274
msgid ""
"The ``Run`` method is the main part of the module. First sets a common "
"message that can be used in error logs or any other purpose. For consistency "
"its highly recommended to use it as described above."
msgstr ""
"``Run`` 方法是模块的主要部分。 首先设置可以在错误日志或任何其它目的中使用的公"
"共消息。 为了保持一致性，强烈建议如上所述使用它。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:276
msgid "Next step is to check if the global parameters was sent correctly."
msgstr "下一步是检查是否正确发送了全局参数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:278
msgid ""
"By convention all modules should be able to override the current user ID by "
"one is provided in the parameters (if any). This passed user ID should be "
"used in any function call that requires it."
msgstr ""
"按照惯例，所有模块都应该能够覆盖参数中提供的当前用户ID（如果有的话）。 此传递"
"的用户ID应该在需要它的任何函数调用中使用。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:280
msgid ""
"User defined attribute values can use current ticket values by using OTRS "
"smart tags. ``_ReplaceTicketAttributes`` is used for normal text attributes, "
"while ``_ReplaceAdditionalAttributes`` for Rich Texts. For more complex "
"parameters it might need customized functions to replace this smart tags."
msgstr ""
"用户定义的属性值可以使用OTRS智能标签来使用当前工单值。 "
"``_ReplaceTicketAttributes`` 用于普通文本属性，而 "
"``_ReplaceAdditionalAttributes`` 用于富文本。 对于更复杂的参数，可能需要自定"
"义函数来替换此智能标签。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:282
msgid "The following is the proper logic of the module."
msgstr "以下是该模块的正确逻辑。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:284
msgid "If everything was OK it must return 1."
msgstr "如果一切正常，则必须返回1。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:288
msgid "Creating a New Process Management Module Configuration Field"
msgstr "创建新的流程管理模块配置字段"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:290
msgid ""
"The following is an example of how to create a process management module "
"configuration field. This field can be used by any process management module "
"after its configuration."
msgstr ""
"以下是如何创建流程管理模块配置字段的示例。 任何流程管理模块在配置后都可以使用"
"该字段。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:294
msgid "Process Management Module Configuration Field Code Example"
msgstr "流程管理模块配置字段代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:296
msgid ""
"The following code implements a simple input process management module "
"configuration field (test). The name of the field and its default value can "
"be set trough a process management module ``ConfigSets``."
msgstr ""
"以下代码实现了一个简单的输入流程管理模块配置字段（test）。 可以通过流程管理模"
"块 ``ConfigSets`` 设置字段的名称及其默认值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:337
msgid ""
"Every configuration field requires to implement at least 2 main methods: "
"``Render`` and ``GetParams``."
msgstr "每个配置字段都需要实现至少2个主要方法：``Render`` 和 ``GetParams``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:362
msgid ""
"``Render`` method is responsible to create the required HTML for the field."
msgstr "``Render`` 方法负责为字段创建所需的HTML。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:364
msgid ""
"In this example it first localize some parameters for more easy read and "
"maintain."
msgstr "在此示例中，它首先本地化一些参数，以便更容易地读取和维护。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:366
msgid ""
"The following lines set the data to display. The field widget title "
"``Description`` is gather from the ``ConfigSet`` if defined, otherwise it "
"uses a default text. Similar to the field ``Name``, for the ``Value`` it "
"first checks if the activity or sequence flow action already have a stored "
"value, if not it tries to use the default value from the ``ConfigSet``, or "
"use empty otherwise."
msgstr ""
"以下行设置要显示的数据。 如果定义了字段小部件标题 ``Description`` 则从 "
"``ConfigSet`` 收集，否则它使用默认文本。 类似于字段 ``Name``，对于 "
"``Value``，它首先检查活动或序列流操作是否已经存储了值，如果没有，它会尝试使"
"用 ``ConfigSet`` 中的默认值， 否则使用空。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:368
msgid ""
"At the end it returns a structure with the HTML code from a template filled "
"with the gathered data."
msgstr "最后，它返回一个结构，其中包含填充了所收集数据的模板中的HTML代码。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:383
msgid ""
"For this example the ``GetParams`` method is very straight forward. It gets "
"the name of the field from the ``ConfigSet`` or use a default, and gets the "
"value from the web request."
msgstr ""
"对于这个例子，``GetParams`` 方法非常简单。 它从 ``ConfigSet`` 获取字段的名称"
"或使用默认值，并从Web请求中获取值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:387
msgid "Process Management Module Configuration Field Template Example"
msgstr "流程管理模块配置字段模板示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:389
msgid ""
"The following code implements a basic HTML template for the test process "
"management module configuration field."
msgstr "以下代码实现了测试流程管理模块配置字段的基本HTML模板。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/process-management-modules.rst:423
msgid ""
"The template shows a simple text input element with its associated label."
msgstr "模板显示一个简单的文本输入元素及其关联的标签。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/queue-preferences.rst:2
msgid "Queue Preferences Module"
msgstr "队列首选项模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/queue-preferences.rst:4
msgid ""
"There is a DB queue preferences module which come with the OTRS framework. "
"It is also possible to develop your own queue preferences modules. The queue "
"preferences modules are located under ``Kernel/System/Queue/*.pm``. For more "
"information about their configuration see the admin manual. Following, there "
"is an example of a queue preferences module. Save it under ``Kernel/System/"
"Queue/PreferencesCustom.pm``. You just need 3 functions: ``new()``, "
"``QueuePreferencesSet()`` and ``QueuePreferencesGet()``. Return 1, then the "
"synchronization is ok."
msgstr ""
"有一个与OTRS框架一起提供的DB队列首选项模块。还可以开发自己的队列首选项模块。"
"队列首选项模块位于 ``kernel/system/queue/*.pm`` 下。有关其配置的更多信息，请"
"参阅管理手册。下面是队列首选项模块的示例。将其保存在 ``kernel/system/queue/"
"preferrencescustom.pm`` 下。您只需要3个函数：``new()``、"
"``queuePreferrencesSet()`` 和 ``queuePreferrencesGet()``。返回1，则同步正常。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/queue-preferences.rst:8
msgid "Queue Preferences Code Example"
msgstr "队列首选项代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/queue-preferences.rst:10
msgid ""
"The interface class is called ``Kernel::System::Queue``. The example queue "
"preferences may be called ``Kernel::System::Queue::PreferencesCustom``. You "
"can find an example below."
msgstr ""
"接口类称为 ``Kernel::System::Queue``。示例队列首选项可以叫做 ``Kernel::"
"System::Queue::PreferencesCustom``。您可以在下面找到一个示例。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/queue-preferences.rst:114
msgid "Queue Preferences Configuration Example"
msgstr "队列首选项配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/queue-preferences.rst:116
msgid ""
"There is the need to activate your custom queue preferences module. This can "
"be done using the XML configuration below."
msgstr "需要激活自定义的队列首选项模块。这可以使用下面的XML配置来完成。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/queue-preferences.rst:131
msgid "Queue Preferences Use Case Example"
msgstr "队列首选项用例示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/queue-preferences.rst:133
#: ../../content/how-to-extend-otrs/otrs-module-layers/service-preferences.rst:134
msgid "Useful preferences implementation could be a SOAP or RADIUS back end."
msgstr "有用的首选项实现可以是SOAP或RADIUS后端。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/service-preferences.rst:2
msgid "Service Preferences Module"
msgstr "服务首选项模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/service-preferences.rst:4
msgid ""
"There is a DB service preferences module which come with the OTRS framework. "
"It is also possible to develop your own service preferences modules. The "
"service preferences modules are located under ``Kernel/System/Service/*."
"pm``. For more information about their configuration see the admin manual. "
"Following, there is an example of a service preferences module. Save it "
"under ``Kernel/System/Service/PreferencesCustom.pm``. You just need 3 "
"functions: ``new()``, ``ServicePreferencesSet()`` and "
"``ServicePreferencesGet()``. Return 1, then the synchronization is ok."
msgstr ""
"有一个与OTRS框架一起提供的DB服务首选项模块。还可以开发自己的服务首选项模块。"
"服务首选项模块位于 ``kernel/system/service/*.pm`` 下。有关其配置的更多信息，"
"请参阅管理手册。下面是服务首选项模块的示例。保存在 ``kernel/system/service/"
"preferrencescustom.pm`` 下。您只需要3个函数：``new()``、"
"``ServicePreferrencesSet()`` 和 ``ServicePreferrencesGet()``。返回1，则同步正"
"常。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/service-preferences.rst:8
msgid "Service Preferences Code Example"
msgstr "服务首选项代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/service-preferences.rst:10
msgid ""
"The interface class is called ``Kernel::System::Service``. The example "
"service preferences may be called ``Kernel::System::Service::"
"PreferencesCustom``. You can find an example below."
msgstr ""
"接口类称为 ``Kernel::System::Service``。示例服务首选项可以叫做 ``Kernel::"
"System::Service::PreferencesCustom``。您可以在下面找到一个示例。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/service-preferences.rst:115
msgid "Service Preferences Configuration Example"
msgstr "服务首选项配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/service-preferences.rst:117
msgid ""
"There is the need to activate your custom service preferences module. This "
"can be done using the XML configuration below."
msgstr "需要激活自定义的服务首选项模块。这可以使用下面的XML配置来完成。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/service-preferences.rst:132
msgid "Service Preferences Use Case Example"
msgstr "服务首选项用例示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/sla-preferences.rst:2
msgid "SLA Preferences Module"
msgstr "SLA首选项模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/sla-preferences.rst:4
msgid ""
"There is a DB SLA preferences module which come with the OTRS framework. It "
"is also possible to develop your own SLA preferences modules. The SLA "
"preferences modules are located under ``Kernel/System/SLA/*.pm``. For more "
"information about their configuration see the admin manual. Following, there "
"is an example of an SLA preferences module. Save it under ``Kernel/System/"
"SLA/PreferencesCustom.pm``. You just need 3 functions: ``new()``, "
"``SLAPreferencesSet()`` and ``SLAPreferencesGet()``. Make sure the function "
"returns 1."
msgstr ""
"有一个与OTRS框架一起提供的DB SLA首选项模块。还可以开发自己的SLA首选项模块。"
"SLA首选项模块位于 ``kernel/system/sla/*.pm`` 下。有关其配置的更多信息，请参阅"
"管理手册。下面是一个SLA首选项模块的示例。将其保存在 ``kernel/system/sla/"
"preferrencescustom.pm`` 下。您只需要3个函数：``new()``、"
"``SLAPreferencesSet()`` 和 ``SLAPreferencesGet()``。确保函数返回1。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/sla-preferences.rst:8
msgid "SLA Preferences Code Example"
msgstr "SLA首选项代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/sla-preferences.rst:10
msgid ""
"The interface class is called ``Kernel::System::SLA``. The example SLA "
"preferences may be called ``Kernel::System::SLA::PreferencesCustom``. You "
"can find an example below."
msgstr ""
"接口类称为 ``Kernel::System::SLA``。示例SLA首选项可以叫做 ``Kernel::System::"
"SLA::PreferencesCustom``。您可以在下面找到一个示例。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/sla-preferences.rst:114
msgid "SLA Preferences Configuration Example"
msgstr "SLA首选项配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/sla-preferences.rst:116
msgid ""
"There is the need to activate your custom SLA preferences module. This can "
"be done using the XML configuration below."
msgstr "需要激活自定义的SLA首选项模块。这可以使用下面的XML配置来完成。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/sla-preferences.rst:131
msgid "SLA Preferences Use Case Example"
msgstr "SLA首选项用例示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/sla-preferences.rst:133
msgid ""
"Useful preferences implementation could be to store additional values on "
"SLAs."
msgstr "有用的首选项实现可以在SLA上存储额外的值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:2
msgid "Stats Module"
msgstr "统计模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:4
msgid ""
"There are two different types of internal stats modules - dynamic and "
"static. This section describes how such stats modules can be developed."
msgstr ""
"有两种不同类型的内部统计模块-动态和静态。本节描述如何开发这些统计模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:8
msgid "Dynamic Stats"
msgstr "动态统计"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:10
msgid ""
"In contrast to static stats modules, dynamic statistics can be configured "
"via the OTRS web interface. In this section a simple statistic module is "
"developed. Each dynamic stats module has to implement these subroutines:"
msgstr ""
"与静态统计模块不同，动态统计可以通过OTRS Web界面进行配置。本节开发了一个简单"
"的统计模块。每个动态统计模块都必须实现这些子程序："

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:13
msgid "``GetObjectName``"
msgstr "``GetObjectName``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:14
msgid "``GetObjectAttributes``"
msgstr "``GetObjectAttributes``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:15
msgid "``ExportWrapper``"
msgstr "``ExportWrapper``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:16
msgid "``ImportWrapper``"
msgstr "``ImportWrapper``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:18
msgid ""
"Furthermore the module has to implement either ``GetStatElement`` or "
"``GetStatTable``. And if the header line of the result table should be "
"changed, a sub called ``GetHeaderLine`` has to be developed."
msgstr ""
"此外，模块必须实现 `GetStatElement`` 或 ``GetStatTable``。如果结果表的标题行"
"应该更改，则必须开发名为 ``GetHeaderLine`` 的子程序。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:22
msgid "Stats Code Example"
msgstr "统计代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:24
msgid ""
"In this section a sample stats module is shown and each subroutine is "
"explained."
msgstr "在本节中，将显示一个统计模块的样本，并解释每个子程序。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:45
msgid ""
"This is a common boilerplate that can be found in common OTRS modules. The "
"class/package name is declared via the ``package`` keyword. Then the needed "
"modules are used via the ``use`` keyword."
msgstr ""
"这是一个常见的样板文件，可以在常见的OTRS模块中找到。类/包名称通过 "
"``package`` 关键字声明。然后通过关键字 ``use`` 使用所需的模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:72
msgid ""
"The ``new`` is the constructor for this statistic module. It creates a new "
"instance of the class. According to the coding guidelines objects of other "
"classes that are needed in this module have to be created in ``new``. In "
"lines 27 to 29 the object of the stats module is created. Lines 31 to 37 "
"check if objects that are needed in this code - either for creating other "
"objects or in this module - are passed. After that the other objects are "
"created."
msgstr ""
"``new`` 是这个统计模块的构造函数。 它创建了一个新的类实例。 根据编码指南，必"
"须在 ``new`` 中创建此模块中所需的其它类的对象。 在第27至29行中，创建了统计模"
"块的对象。 第31到37行检查是否传递了此代码中所需的对象 - 用于创建其它对象或在"
"此模块中。 之后，创建其它对象。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:82
msgid ""
"``GetObjectName`` returns a name for the statistics module. This is the "
"label that is shown in the drop down in the configuration as well as in the "
"list of existing statistics (column *object*)."
msgstr ""
"``GetObjectName`` 返回统计模块的名称。 这是在配置的下拉列表中以及现有统计信息"
"列表（ *对象* 列）中显示的标签。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:141
msgid ""
"In this sample stats module, we want to provide three attributes the user "
"can chose from: a list of queues, a list of states and a time drop down. To "
"get the values shown in the drop down, some operations are needed. In this "
"case ``StateList`` and ``GetAllQueues`` are called."
msgstr ""
"在此示例统计模块中，我们希望提供用户可以选择的三个属性：队列列表、状态列表和"
"时间下拉列表。 要获得下拉列表中显示的值，需要执行一些操作。 在本例中是调用 "
"``StateList`` 和 ``GetAllQueues``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:143
msgid ""
"Then the list of attributes is created. Each attribute is defined via a hash "
"reference. You can use these keys:"
msgstr "然后创建属性列表。 每个属性都通过哈希引用定义。 您可以使用以下键："

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:146
#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:706
msgid "The label in the web interface."
msgstr "Web界面中的标签。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:149
msgid "``UseAsXvalue``"
msgstr "``UseAsXvalue``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:149
msgid "This attribute can be used on the x-axis."
msgstr "该属性可以在X轴上使用。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:152
msgid "``UseAsValueSeries``"
msgstr "``UseAsValueSeries``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:152
msgid "This attribute can be used on the y-axis."
msgstr "该属性可以在Y轴上使用。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:155
msgid "``UseAsRestriction``"
msgstr "``UseAsRestriction``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:155
msgid "This attribute can be used for restrictions."
msgstr "此属性可用于限制。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:158
msgid "``Element``"
msgstr "``Element``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:158
#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:709
msgid "The HTML field name."
msgstr "HTML字段名。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:161
msgid "``Block``"
msgstr "``Block``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:161
msgid ""
"The block name in the template file (e.g. ``<OTRS_HOME>/Kernel/Output/HTML/"
"Standard/AgentStatsEditXaxis.tt``)."
msgstr ""
"模板文件中的块名称（例如： ``<OTRS_HOME>/Kernel/Output/HTML/Standard/"
"AgentStatsEditXaxis.tt``）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:164
msgid "``Values``"
msgstr "``Values``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:164
#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:712
msgid "The values shown in the attribute."
msgstr "属性中显示的值。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:166
msgid ""
"Hint: If you install this sample and you configure a statistic with some "
"queues - lets say 'queue A' and 'queue B' - then these queues are the only "
"ones that are shown to the user when he starts the statistic. Sometimes a "
"dynamic drop down or multiselect field is needed. In this case, you can set "
"``SelectedValues`` in the definition of the attribute:"
msgstr ""
"提示：如果您安装此示例并配置带有某些队列的统计信息 - 比如说'队列A'和'队列B' "
"- 那么这些队列是用户在启动统计信息时显示的唯一队列。 有时需要动态下拉或多选字"
"段。 在这种情况下，您可以在属性的定义中设置 ``SelectedValues``："

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:197
msgid ""
"``GetStatElement`` gets called for each cell in the result table. So it "
"should be a numeric value. In this sample it does a simple ticket search. "
"The hash ``%Param`` contains information about the *current* x-value and the "
"y-value as well as any restrictions. So, for a cell that should count the "
"created tickets for queue *Misc* with state *open* the passed parameter hash "
"looks something like this:"
msgstr ""
"为结果表中的每个单元格调用 ``GetStatElement``。 所以它应该是一个数值。 在此示"
"例中，它执行简单的工单搜索。 哈希 ``%Param`` 包含有关 *当前* x值和y值以及任何"
"限制的信息。 因此，对于一个计算使用状态为 *处理中* 、已创建的 *Misc* 队列的工"
"单的单元格，传递的参数哈希看起来像这样："

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:208
msgid ""
"If the *per cell* calculation should be avoided, ``GetStatTable`` is an "
"alternative. ``GetStatTable`` returns a list of rows, hence an array of "
"array references. This leads to the same result as using ``GetStatElement``."
msgstr ""
"如果应该避免 *按单元格* 的计算，``GetStatTable`` 是另一种选择。 "
"``GetStatTable`` 返回一个行列表，因此返回一个数组引用数组。 这导致与使用 "
"``GetStatElement`` 相同的结果。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:237
msgid ""
"``GetStatTable`` gets all information about the stats query that is needed. "
"The passed parameters contain information about the attributes "
"(``Restrictions``, attributes that are used for x/y-axis) and the table "
"structure. The table structure is a hash reference where the keys are the "
"values of the y-axis and their values are hash references with the "
"parameters used for ``GetStatElement`` subroutines."
msgstr ""
"``GetStatTable`` 获取有关所需统计信息查询的所有信息。 传递的参数包含有关属性"
"的信息（``Restrictions``，用于x / y轴的属性）和表结构。 表结构是一个哈希引"
"用，其中键是y轴的值，它们的值是哈希引用，其参数用于 ``GetStatElement`` 子程"
"序。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:310
msgid ""
"Sometimes the headers of the table have to be changed. In that case, a "
"subroutine called ``GetHeaderLine`` has to be implemented. That subroutine "
"has to return an array reference with the column headers as elements. It "
"gets information about the x-values passed."
msgstr ""
"有时候必须更改表格的标题。 在这种情况下，必须实现一个名为 ``GetHeaderLine`` "
"的子程序。 该子程序必须返回一个数组引用，并将列标题作为元素。 它获取有关传递"
"的x值的信息。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:358
msgid ""
"Configured statistics can be exported into XML format. But as queues with "
"the same queue names can have different IDs on different OTRS instances it "
"would be quite painful to export the IDs (the statistics would calculate the "
"wrong numbers then). So an export wrapper should be written to use the names "
"instead of ids. This should be done for each *dimension* of the stats module "
"(x-axis, y-axis and restrictions)."
msgstr ""
"配置的统计信息可以导出为XML格式。 但是由于具有相同队列名称的队列在不同的OTRS"
"实例上可以具有不同的ID，因此导出ID将非常痛苦（统计数据将计算错误的数字）。 因"
"此，应编写导出封装器以使用名称而不是ID。 应该对统计模块的每个 *维度* （x轴、y"
"轴和限制）进行此操作。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:360
msgid ""
"``ImportWrapper`` works the other way around - it converts the name to the "
"ID in the instance the configuration is imported to."
msgstr ""
"``ImportWrapper`` 以相反的方式工作 - 它将名称转换为导入配置的实例中的ID。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:362
msgid "This is a sample export:"
msgstr "这是一个示例导出："

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:398
msgid ""
"Now, that all subroutines are explained, this is the complete sample stats "
"module."
msgstr "现在，解释了所有子程序，这是完整的样本统计模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:605
msgid "Stats Configuration Example"
msgstr "统计配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:625
msgid ""
"If you have a lot of cells in the result table and the ``GetStatElement`` is "
"quite complex, the request can take a long time."
msgstr ""
"如果结果表中有很多单元格并且 ``GetStatElement`` 非常复杂，那么请求可能需要很"
"长时间。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:629
msgid "Static Stats"
msgstr "静态统计"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:631
msgid ""
"The subsequent paragraphs describe the static stats. Static stats are very "
"easy to create as these modules have to implement only three subroutines."
msgstr ""
"后续段落描述了静态统计数据。 静态统计信息很容易创建，因为这些模块只需要实现三"
"个子程序。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:634
msgid "``Param``"
msgstr "``Param``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:639
msgid "Static Stats Code Example"
msgstr "静态统计代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:641
msgid ""
"The following paragraphs describe the subroutines needed in a static stats."
msgstr "以下段落描述了静态统计信息中所需的子程序。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:669
msgid ""
"The ``new`` creates a new instance of the static stats class. First it "
"creates a new object and then it checks for the needed objects."
msgstr ""
"``new`` 创建静态统计类的新实例。 首先，它创建一个新对象，然后检查所需的对象。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:701
msgid ""
"The ``Param`` method provides the list of all parameters/attributes that can "
"be selected to create a static stat. It gets some parameters passed: The "
"values for the stats attributes provided in a request, the format of the "
"stats and the name of the object (name of the module)."
msgstr ""
"``Param`` 方法提供了可以选择创建静态统计的所有参数/属性的列表。 它传递了一些"
"参数：请求中提供的统计属性的值，统计的格式和对象的名称（模块的名称）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:703
msgid ""
"The parameters/attributes have to be hash references with these key-value "
"pairs:"
msgstr "参数/属性必须是具有这些键值对的哈希引用："

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:706
msgid "``Frontend``"
msgstr "``Frontend``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:714
msgid ""
"Other parameter for the ``BuildSelection`` method of the ``LayoutObject`` "
"can be used, as it is done with ``Size`` and ``Multiple`` in this sample "
"module."
msgstr ""
"可以使用 ``LayoutObject`` 的 ``BuildSelection`` 方法的其他参数，比如在此示例"
"模块中使用了 ``Size`` 和 ``Multiple``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:761
msgid ""
"The ``Run`` method actually generates the table data for the stats. It gets "
"the attributes for this stats passed. In this sample in ``%Param`` a key "
"``TypeIDs`` and a key ``QueueIDs`` exist (see attributes in ``Param`` "
"method) and their values are array references. The returned data consists of "
"three parts: Two array references and an array. In the first array reference "
"the title for the statistic is stored, the second array reference contains "
"the headlines for the columns in the table. And then the data for the table "
"body follow."
msgstr ""
"``Run`` 方法实际上生成了统计数据的表数据。 它获取传递此统计数据的属性。 在这"
"个示例中的 ``％Param`` 存在一个 ``TypeIDs`` 键和一个 ``QueueIDs`` 键（参见 "
"``Param`` 方法中的属性），它们的值是数组引用。 返回的数据由三部分组成：两个数"
"组引用和一个数组。 在第一个数组引用中存储统计信息的标题，第二个数组引用包含表"
"中列的标题。 然后表体的数据如下。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:961
msgid "Static Stats Configuration Example"
msgstr "静态统计配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/stats.rst:963
msgid ""
"There is no configuration needed. Right after installation, the module is "
"available to create a statistic for this module."
msgstr "无需配置。 安装后，该模块可用于为此模块创建统计信息。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-menu.rst:2
msgid "Ticket Menu Module"
msgstr "工单菜单模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-menu.rst:4
msgid ""
"Ticket menu modules are used to display an additional link in the menu above "
"a ticket. You can write and register your own ticket menu module. There are "
"4 ticket menus (*Generic*, *Lock*, *Responsible* and *TicketWatcher*) which "
"come with the OTRS framework. For more information please have a look at the "
"OTRS admin manual."
msgstr ""
"工单菜单模块用于在工单上方的菜单中显示其他链接。 您可以编写并注册自己的工单菜"
"单模块。 OTRS框架附带4个工单菜单（*通用*， *锁定*， *负责人* 和 *关注人*）。 "
"有关更多信息，请查看OTRS管理手册。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-menu.rst:8
msgid "Ticket Menu Module Code Example"
msgstr "工单菜单模块代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-menu.rst:10
msgid ""
"The ticket menu modules are located under ``Kernel/Output/HTML/TicketMenu*."
"pm``. Following, there is an example of a ticket menu module. Save it under "
"``Kernel/Output/HTML/TicketMenuCustom.pm``. You just need 2 functions: "
"``new()`` and ``Run()``."
msgstr ""
"工单菜单模块位于 ``Kernel/Output/HTML/TicketMenu*.pm`` 下。 下面是一个工单菜"
"单模块的示例。 将它保存在 ``Kernel/Output/HTML/TicketMenuCustom.pm`` 下。 你"
"只需要2个函数：``new()`` 和 ``Run()``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-menu.rst:115
msgid "Ticket Menu Module Configuration Example"
msgstr "工单菜单模块配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-menu.rst:117
msgid ""
"There is the need to activate your custom ticket menu module. This can be "
"done using the XML configuration below. There may be additional parameters "
"in the config hash for your ticket menu module."
msgstr ""
"需要激活自定义的工单菜单模块。 这可以使用下面的XML配置来完成。 您的工单菜单模"
"块的配置哈希中可能还有其他参数。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-menu.rst:136
msgid "Ticket Menu Module Use Case Example"
msgstr "工单菜单模块用例示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-menu.rst:142
msgid ""
"The ticket menu directs to an URL that can be handled. If you want to handle "
"that request via the OTRS framework, you have to write your own front end "
"module."
msgstr ""
"工单菜单指向可以处理的URL。 如果要通过OTRS框架处理该请求，则必须编写自己的前"
"端模块。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-postmaster-modules.rst:2
msgid "Ticket Postmaster Module"
msgstr "工单邮箱管理员模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-postmaster-modules.rst:4
msgid ""
"Postmaster modules are used during the postmaster process. There are two "
"kinds of postmaster modules:"
msgstr "邮箱管理员模块在邮箱管理员流程中使用。 邮箱管理员模块有两种："

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-postmaster-modules.rst:6
msgid "``PostMasterPre``: used after parsing an email."
msgstr "``PostMasterPre``：解析邮件后使用。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-postmaster-modules.rst:7
msgid ""
"``PostMasterPost``: used after an email is processed and is in the database."
msgstr "``PostMasterPost``：在处理完电子邮件并保存到数据库后使用。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-postmaster-modules.rst:9
msgid ""
"If you want to create your own postmaster filter, just create your own "
"module. These modules are located under ``Kernel/System/PostMaster/Filter/*."
"pm``. For default modules see the admin manual. You just need two functions: "
"``new()`` and ``Run()``."
msgstr ""
"如果您想创建自己的邮箱管理员过滤器，只需创建自己的模块。 这些模块位于 "
"``Kernel/System/PostMaster/Filter/*.pm`` 下。 有关默认模块，请参阅管理员手"
"册。 你只需要两个函数：``new()`` 和 ``Run()``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-postmaster-modules.rst:11
msgid ""
"The following is an exemplary module to match emails and set X-OTRS-Headers "
"(see ``doc/X-OTRS-Headers.txt`` for more info)."
msgstr ""
"以下是匹配电子邮件和设置X-OTRS-Headers的示例模块（有关详细信息，请参阅 ``doc/"
"X-OTRS-Headers.txt``）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-postmaster-modules.rst:13
msgid "``Kernel/Config/Files/XML/MyModule.xml``:"
msgstr "``Kernel/Config/Files/XML/MyModule.xml``:"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-postmaster-modules.rst:38
msgid ""
"And the actual filter code in ``Kernel/System/PostMaster/Filter/Example.pm``:"
msgstr ""
"以及 ``Kernel/System/PostMaster/Filter/Example.pm`` 中的实际过滤器代码："

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-postmaster-modules.rst:128
msgid "The following image shows you the email processing flow."
msgstr "下图显示了电子邮件处理流程。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticket-postmaster-modules.rst:133
msgid "Email Processing Flow"
msgstr "电子邮件处理流程"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:2
msgid "Ticket Event Module"
msgstr "工单事件模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:4
msgid ""
"Ticket event modules are running right after a ticket action takes place. "
"Per convention these modules are located in the directory ``Kernel/System/"
"Ticket/Event``. A ticket event module needs only two functions: ``new()`` "
"and ``Run()``. The method ``Run()`` receives at least the parameters "
"``Event``, ``UserID`` and ``Data``. ``Data`` is a hash ref containing data "
"of the ticket, and in case of article related events also containing article "
"data."
msgstr ""
"工单事件模块在工单操作发生后立即运行。 按照惯例，这些模块位于 ``Kernel/"
"System/Ticket/Event`` 目录中。 工单事件模块只需要两个函数：``new()`` 和 "
"``Run()``。 ``Run()`` 方法至少接收参数 ``Event``、``UserID`` 和 ``Data``。 "
"``Data`` 是包含工单数据的哈希引用，如果事件有相关的信件也包含信件数据。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:8
msgid "Ticket Event Module Code Example"
msgstr "工单事件模块代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:10
msgid "See files in ``Kernel/System/Ticket/Event`` folder of the source code."
msgstr "请参见源代码的 ``Kernel/System/Ticket/Event`` 目录中的文件。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:14
msgid "Ticket Event Module Configuration Example"
msgstr "工单事件模块配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:16
msgid ""
"See settings in ``Kernel/Config/Files/XML/Ticket.xml`` started with the name "
"``Ticket::EventModulePost###``."
msgstr ""
"请参见 ``Kernel/Config/Files/XML/Ticket.xml`` 中以名称 ``Ticket::"
"EventModulePost###`` 开头的设置。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:20
msgid "Ticket Event Module Use Case Example"
msgstr "工单事件模块用例示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:23
msgid "A ticket should be unlocked after a move action"
msgstr "移动操作后解锁工单"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:23
msgid ""
"This standard feature has been implemented with the ticket event module "
"``Kernel::System::Ticket::Event::ForceUnlock``. When this feature is not "
"wanted, then it can be turned off by unsetting the system configuration "
"entry ``Ticket::EventModulePost###910-ForceUnlockOnMove``."
msgstr ""
"这个标准功能已经使用工单事件模块 ``Kernel::System::Ticket::Event::"
"ForceUnlock`` 实现。 当不需要此功能时，可以通过取消系统配置条目 ``Ticket::"
"EventModulePost###910-ForceUnlockOnMove`` 设置来关闭它。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:26
msgid "Perform extra cleanup action when a ticket is deleted"
msgstr "删除工单时执行额外的清理操作"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:26
msgid ""
"A customized OTRS might hold non-standard data in additional database "
"tables. When a ticket is deleted then this additional data needs to be "
"deleted. This functionality can be achieved with a ticket event module "
"listening to ``TicketDelete`` events."
msgstr ""
"自定义OTRS可能会在其他数据库表中保存非标准数据。 删除工单后，需要删除此附加数"
"据。 使用工单事件模块监听 ``TicketDelete`` 事件可以实现此功能。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:30
msgid "New tickets should be twittered"
msgstr "新的工单通过twitter发布"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:29
msgid ""
"A ticket event module listening to ``TicketCreate`` can send out tweets."
msgstr "监听 ``TicketCreate`` 的工单事件模块可以发送推文。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:33
msgid "Ticket and Article Events"
msgstr "工单和信件事件"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:35
msgid "Available ticket events:"
msgstr "可用的工单事件："

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:37
msgid "``TicketCreate``"
msgstr "``TicketCreate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:38
msgid "``TicketDelete``"
msgstr "``TicketDelete``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:39
msgid "``TicketTitleUpdate``"
msgstr "``TicketTitleUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:40
msgid "``TicketUnlockTimeoutUpdate``"
msgstr "``TicketUnlockTimeoutUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:41
msgid "``TicketQueueUpdate``"
msgstr "``TicketQueueUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:42
msgid "``TicketTypeUpdate``"
msgstr "``TicketTypeUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:43
msgid "``TicketServiceUpdate``"
msgstr "``TicketServiceUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:44
msgid "``TicketSLAUpdate``"
msgstr "``TicketSLAUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:45
msgid "``TicketCustomerUpdate``"
msgstr "``TicketCustomerUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:46
msgid "``TicketPendingTimeUpdate``"
msgstr "``TicketPendingTimeUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:47
msgid "``TicketLockUpdate``"
msgstr "``TicketLockUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:48
msgid "``TicketArchiveFlagUpdate``"
msgstr "``TicketArchiveFlagUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:49
msgid "``TicketStateUpdate``"
msgstr "``TicketStateUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:50
msgid "``TicketOwnerUpdate``"
msgstr "``TicketOwnerUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:51
msgid "``TicketResponsibleUpdate``"
msgstr "``TicketResponsibleUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:52
msgid "``TicketPriorityUpdate``"
msgstr "``TicketPriorityUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:53
msgid "``HistoryAdd``"
msgstr "``HistoryAdd``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:54
msgid "``HistoryDelete``"
msgstr "``HistoryDelete``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:55
msgid "``TicketAccountTime``"
msgstr "``TicketAccountTime``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:56
msgid "``TicketMerge``"
msgstr "``TicketMerge``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:57
msgid "``TicketSubscribe``"
msgstr "``TicketSubscribe``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:58
msgid "``TicketUnsubscribe``"
msgstr "``TicketUnsubscribe``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:59
msgid "``TicketFlagSet``"
msgstr "``TicketFlagSet``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:60
msgid "``TicketFlagDelete``"
msgstr "``TicketFlagDelete``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:61
msgid "``EscalationResponseTimeNotifyBefore``"
msgstr "``EscalationResponseTimeNotifyBefore``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:62
msgid "``EscalationUpdateTimeNotifyBefore``"
msgstr "``EscalationUpdateTimeNotifyBefore``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:63
msgid "``EscalationSolutionTimeNotifyBefore``"
msgstr "``EscalationSolutionTimeNotifyBefore``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:64
msgid "``EscalationResponseTimeStart``"
msgstr "``EscalationResponseTimeStart``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:65
msgid "``EscalationUpdateTimeStart``"
msgstr "``EscalationUpdateTimeStart``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:66
msgid "``EscalationSolutionTimeStart``"
msgstr "``EscalationSolutionTimeStart``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:67
msgid "``EscalationResponseTimeStop``"
msgstr "``EscalationResponseTimeStop``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:68
msgid "``EscalationUpdateTimeStop``"
msgstr "``EscalationUpdateTimeStop``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:69
msgid "``EscalationSolutionTimeStop``"
msgstr "``EscalationSolutionTimeStop``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:70
msgid "``NotificationNewTicket``"
msgstr "``NotificationNewTicket``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:71
msgid "``NotificationFollowUp``"
msgstr "``NotificationFollowUp``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:72
msgid "``NotificationLockTimeout``"
msgstr "``NotificationLockTimeout``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:73
msgid "``NotificationOwnerUpdate``"
msgstr "``NotificationOwnerUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:74
msgid "``NotificationResponsibleUpdate``"
msgstr "``NotificationResponsibleUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:75
msgid "``NotificationAddNote``"
msgstr "``NotificationAddNote``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:76
msgid "``NotificationMove``"
msgstr "``NotificationMove``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:77
msgid "``NotificationPendingReminder``"
msgstr "``NotificationPendingReminder``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:78
msgid "``NotificationEscalation``"
msgstr "``NotificationEscalation``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:79
msgid "``NotificationEscalationNotifyBefore``"
msgstr "``NotificationEscalationNotifyBefore``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:80
msgid "``NotificationServiceUpdate``"
msgstr "``NotificationServiceUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:82
msgid "Available article events:"
msgstr "可用的信件事件："

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:84
msgid "``ArticleCreate``"
msgstr "``ArticleCreate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:85
msgid "``ArticleUpdate``"
msgstr "``ArticleUpdate``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:86
msgid "``ArticleSend``"
msgstr "``ArticleSend``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:87
msgid "``ArticleBounce``"
msgstr "``ArticleBounce``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:88
#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:93
msgid "``ArticleAgentNotification``"
msgstr "``ArticleAgentNotification``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:89
#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:94
msgid "``ArticleCustomerNotification``"
msgstr "``ArticleCustomerNotification``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:90
msgid "``ArticleAutoResponse``"
msgstr "``ArticleAutoResponse``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:91
msgid "``ArticleFlagSet``"
msgstr "``ArticleFlagSet``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketevent.rst:92
msgid "``ArticleFlagDelete``"
msgstr "``ArticleFlagDelete``"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketnumber-generator.rst:2
msgid "Ticket Number Generator Modules"
msgstr "工单编号生成器模块"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketnumber-generator.rst:4
msgid ""
"Ticket number generators are used to create distinct identifiers aka ticket "
"number for new tickets. Any method of creating a string of numbers is "
"possible, you should use common sense about the length of the resulting "
"string (guideline: 5-10)."
msgstr ""
"票号生成器用于创建不同的标识符，即新票证的票号。 任何创建数字串的方法都是可能"
"的，你应该使用关于结果字符串长度的常识（参考：5-10）。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketnumber-generator.rst:6
msgid ""
"When creating a ticket number, make sure the result is prefixed by the "
"system configuration variable ``SystemID`` in order to enable the detection "
"of ticket numbers on inbound email responses. A ticket number generator "
"module needs the two functions ``TicketCreateNumber()`` and "
"``GetTNByString()``."
msgstr ""
"创建工单编号时，请确保结果以系统配置变量 ``SystemID`` 为前缀，以便检测入站电"
"子邮件响应中的工单编号。 工单编号生成器模块需要两个函数 "
"``TicketCreateNumber()`` 和 ``GetTNByString()``。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketnumber-generator.rst:8
msgid ""
"The method ``TicketCreateNumber()`` is called without parameters and returns "
"the new ticket number."
msgstr "不带参数调用 ``TicketCreateNumber()`` 方法，并返回新的工单编号。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketnumber-generator.rst:10
msgid ""
"The method ``GetTNByString()`` is called with the param ``String`` which "
"contains the string to be parsed for a ticket number and returns the ticket "
"number if found."
msgstr ""
"使用 ``String`` 参数调用 ``GetTNByString()`` 方法，其中包含要为工单编号解析的"
"字符串，如果找到则返回工单编号。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketnumber-generator.rst:14
msgid "Ticket Number Generator Code Example"
msgstr "工单编号生成器代码示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketnumber-generator.rst:16
msgid "See files in ``Kernel/System/Ticket/Number`` folder of the source code."
msgstr "请参见源代码的 ``Kernel/System/Ticket/Number`` 目录中的文件。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketnumber-generator.rst:20
msgid "Ticket Number Generator Configuration Example"
msgstr "工单编号生成器配置示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketnumber-generator.rst:22
msgid ""
"See settings in ``Kernel/Config/Files/XML/Ticket.xml`` started with the name "
"``Ticket::NumberGenerator``."
msgstr ""
"请参见 ``Kernel/Config/Files/XML/Ticket.xml`` 中以名称 ``Ticket::"
"NumberGenerator`` 开头的设置。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketnumber-generator.rst:26
msgid "Ticket Number Generator Use Case Example"
msgstr "工单编号生成器用例示例"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketnumber-generator.rst:29
msgid "Ticket numbers should follow a specific scheme"
msgstr "工单编号应遵循特定方案"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketnumber-generator.rst:29
msgid ""
"You will need to create a new ticket number generator if the default modules "
"don't provide the ticket number scheme you'd like to use."
msgstr ""
"如果默认模块未提供您要使用的工单编号方案，则需要创建新的工单编号生成器。"

#: ../../content/how-to-extend-otrs/otrs-module-layers/ticketnumber-generator.rst:33
msgid ""
"You should stick to the code of ``GetTNByString()`` as used in existing "
"ticket number generators to prevent problems with ticket number parsing. "
"Also the routine to detect a loop in ``TicketCreateNumber()`` should be kept "
"intact to prevent duplicate ticket numbers."
msgstr ""
"你应该坚持现有工单编号生成器中使用的 ``GetTNByString()`` 代码，以防止工单编号"
"解析出现问题。 此外，检测 ``TicketCreateNumber()`` 中循环的程序应保持不变，以"
"防止重复的工单编号。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:2
msgid "Writing A New OTRS Front End Component"
msgstr "编写新的OTRS前端组件"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:4
msgid ""
"In this example, we will try to write a new OTRS front end component. "
"Starting with OTRS 7, the framework supports single page application front "
"ends written in Vue.js and based on a new JavaScript toolchain. First "
"iteration contains the new external interface, for which we will try to "
"write a custom component. You will need to have a running OTRS :doc:`../get-"
"started/development-environment` as specified in the chapter of the same "
"name."
msgstr ""
"在这个例子中，我们将尝试编写一个新的OTRS前端组件。 从OTRS 7开始，OTRS框架支持"
"用Vue.js编写的单页面应用程序前端，并基于新的JavaScript工具链。 第一次迭代包含"
"新的外部接口，我们将尝试编写自定义组件。 您需要有一个正在运行的OTRS :doc:`../"
"get-started/development-environment`，如开发环境部分所述。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:8
msgid "The Goal"
msgstr "目标"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:10
msgid ""
"We want to write a small front end component that displays the text *Hello "
"World* when called up. This will be a route component, meaning it will be "
"available in the external interface when called with a carefully crafted URL."
msgstr ""
"我们想要编写一个小的前端组件，在调用时显示文本 *Hello World*。 这将是一个路由"
"组件，这意味着当使用精心设计的URL调用时，它将在外部人员界面中可用。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:14
msgid "Using The Skeleton Command"
msgstr "使用Skeleton命令"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:16
msgid ""
"To speed up the development, we should use a skeleton command to get a "
"boilerplate template file which we can build upon."
msgstr ""
"为了加快开发速度，我们应该使用skeleton命令来获取我们可以构建的样板模板文件。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:18
msgid ""
"On a running OTRS instance, call the following command to generate the "
"template. We will use ``HelloWorld`` as the name of our new component:"
msgstr ""
"在正在运行的OTRS实例上，调用以下命令以生成模板。 我们将使用 ``HelloWorld`` 作"
"为新组件的名称："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:24
msgid ""
"In the command ``--component-directory`` is the directory of your module, "
"``--component-subdirectory`` path under ``Frontend/`` folder that will house "
"the component file. For now, use ``--no-docs`` switch to skip creation of "
"the documentation component for the design system."
msgstr ""
"在命令中 ``--component-directory`` 是你的模块的目录，在 ``Frontend/`` 文件夹"
"下的 ``--component-subdirectory`` 路径，将容纳组件文件。 现在，使用 ``--no-"
"docs`` 开关跳过设计系统的文档组件的创建。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:26
msgid "This command will generate two files with following paths:"
msgstr "此命令将生成具有以下路径的两个文件："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:36
msgid "The Route Configuration"
msgstr "路由配置"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:38
msgid ""
"In order to allow the route in the external interface application, we need "
"to add a correct route configuration that points to our component. Therefore "
"we create a file ``Kernel/Config/Files/XML/HelloWorld.xml`` with following "
"definition:"
msgstr ""
"为了允许外部人员界面应用程序路由，我们需要添加指向组件的正确路由配置。 因此，"
"我们使用以下定义创建文件 ``Kernel/Config/Files/XML/HelloWorld.xml``："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:75
msgid ""
"``Group`` and ``GroupRo`` can be used to limit the route screen to users "
"with certain groups. Please note that this only concerns the authenticated "
"customer users."
msgstr ""
"``Group`` 和 ``GroupRo`` 可用于限制具有特定组的用户的路由屏幕。 请注意，这仅"
"涉及经过身份验证的客户用户。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:76
msgid ""
"``Path`` is actually the slug under which the route component will be "
"available. The full URL in this case will be ``/external/hello-world``, and "
"any subsequent path component will be passed as a parameter named "
"``headingText``. If your system has ``Frontend::PrefixPath`` configured, "
"full URL will be prepended by it."
msgstr ""
"``Path`` 实际上是路由组件可用的slug。 在本例中完整的URL将是 ``/external/"
"hello-world``，任何后续的路由组件都将作为名为 ``headingText`` 的参数传递。 如"
"果您的系统配置了 ``Frontend::PrefixPath``，则会在其前面加上完整的URL。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:77
msgid ""
"``Alias`` can be used to provide an alias for the same route (e. g. ``/hello-"
"world-alt``). It will point to the same component."
msgstr ""
"``Alias`` 可用于为同一路由提供别名（例如 ``/hello-world-alt``）。 它将指向相"
"同的组件。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:78
msgid ""
"``Component`` is the component identifier, first part of the filename, "
"without the ``.vue`` extension. In case of component folders, it's the name "
"of the root folder. See :ref:`Component Folders` for more information."
msgstr ""
"``Component`` 是组件标识符，文件名的第一部分，没有 ``.vue`` 扩展名。 如果是组"
"件文件夹，则它是根文件夹的名称。 有关更多信息，请参阅 :ref:`Component "
"Folders`。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:79
msgid ""
"``IsPublic`` defines if the route will be accessible by unauthenticated "
"users (0/Empty - not accessible, 1 - accessible)."
msgstr ""
"``IsPublic`` 定义未经身份验证的用户是否可以访问该路由（0/空 - 不可访问，1 - "
"可访问）。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:80
msgid ""
"``Props`` defines if the route will be passed URI parameters as prop values "
"(0/Empty - not passed, 1 - passed). See :ref:`Passing Parameters to the "
"Route Component` for more information."
msgstr ""
"``Props`` 定义路由是否将URI参数作为prop值传递（0 / Empty - 未传递，1 - 传"
"递）。 有关更多信息，请参阅 :ref:`Passing Parameters to the Route "
"Component` 。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:84
msgid "Component Template Code"
msgstr "组件模板代码"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:86
msgid ""
"Let's fire up the code editor now and take a closer look at the ``HelloWorld."
"vue`` file that our skeleton command created."
msgstr ""
"让我们现在启动代码编辑器，仔细看看我们的骨架命令创建的 ``HelloWorld.vue`` 文"
"件。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:88
msgid ""
"Top part of the file contains a template section which should contain Vue.js "
"template code. For example, let's modify it so it displays a heading with a "
"text variable:"
msgstr ""
"该文件的顶部包含一个模板部分，其中应包含Vue.js模板代码。 例如，让我们修改它，"
"以便显示带有文本变量的标题："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:106
msgid ""
"OTRS supports number of filters, with ``translate`` being one of them. It "
"even supports translation of string literals with placeholder values, you "
"can use it like this:"
msgstr ""
"OTRS支持多个过滤器，``translate`` 就是其中之一。 它甚至支持使用占位符值转换字"
"符串文字，您可以像这样使用它："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:114
msgid "Component Core Code"
msgstr "组件核心代码"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:116
msgid ""
"Next, we add a support for a prop to our component core code block, "
"following is a modified and abridged version suitable for an example:"
msgstr ""
"接下来，我们为组件核心代码块添加对prop的支持，以下是适用于示例的已修改和删节"
"版本："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:133
msgid ""
"This adds a prop with the name ``headingText`` to our component, which is of "
"type string and has a sensible default value."
msgstr ""
"这会向我们的组件添加一个名为 ``headingText`` 的prop，它的类型为string，并且具"
"有合理的默认值。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:135
msgid ""
"Usage of ``translatable()`` no-op method is limited to marking translatable "
"strings which appear in the code. Please note that this is not required for "
"string literals which are piped to the translate filter, as this will be "
"assumed from the start. Rule of thumb is to use the marker anywhere where "
"the string is not translated at the place where it is defined."
msgstr ""
"``translatable()`` no-op方法的用法仅限于标记出现在代码中的可翻译字符串。 请注"
"意，对于通过管道传输到翻译过滤器的字符串文字，这不是必需的，因为这将从一开始"
"就假定。 经验法则是在字符串未在定义位置翻译的任何位置使用标记。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:139
msgid "Component Style Code"
msgstr "组件样式代码"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:141
msgid ""
"Last, but not the least, we have an option to specify styles used by the "
"component. For this we have access to the SCSS, which is a flavor of SASS "
"CSS extension set. To leverage it, just add a style tag at the end of the "
"component file:"
msgstr ""
"最后，但并非最不重要，我们可以选择指定组件使用的样式。 为此，我们可以访问"
"SCSS，它是SASS CSS扩展集的一种风格。 要利用它，只需在组件文件的末尾添加样式标"
"记："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:154
msgid ""
"Inside the style block, you will have access to certain set of global "
"variables and mixins. Please refer to the framework code for details (take a "
"look at the ``Frontend/Styles/globals.js``)."
msgstr ""
"在样式块中，您可以访问某些全局变量和mixin。 有关详细信息，请参阅框架代码（请"
"参阅 ``Frontend/Styles/globals.js``）。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:156
msgid ""
"Please note that while the styles will be loaded only when your component is "
"referenced, these will be globally available afterwards since the CSS is "
"inherently global for the same page. There is an option to scope the styles "
"just to your component, you can do this via the ``scoped`` attribute on the "
"style tag, but this might not be necessary with clever usage of BEM approach "
"in designing your class names."
msgstr ""
"请注意，虽然仅在引用组件时才会加载样式，但之后这些样式将全局可用，因为CSS对于"
"同一页面本质上是全局的。 可以选择将样式范围仅限于组件，可以通过样式标记上的 "
"``scoped`` 属性来实现，但在设计类名时巧妙使用BEM方法可能不需要这样做。【译"
"注：BEM--前端命名方法论,BEM的意思就是块（block）、元素（element）、修饰符"
"（modifier）,是由Yandex团队提出的一种前端命名方法论。这种巧妙的命名方法让你的"
"CSS类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多"
"的信息，它们用于一个团队开发一个耗时的大项目。】"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:160
msgid "Passing Parameters to the Route Component"
msgstr "传递参数给路由组件"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:162
msgid ""
"In the route configuration above, we defined the route path that contains a "
"parameter placeholder (``headingText``). By activating the ``Props`` flag, "
"we made sure that the value of this parameter will be bound to our component "
"prop with the same name every time a route is entered."
msgstr ""
"在上面的路由配置中，我们定义一个包含参数占位符（``headingText``）的路由路"
"径。 通过激活 ``Props`` 标志，我们确保每次进入路由时，此参数的值将绑定到具有"
"相同名称的组件prop。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:164
msgid ""
"For example, if we enter the route via the ``/external/hello-world`` URL, "
"our component prop will be undefined and therefore will get its default "
"value."
msgstr ""
"例如，如果我们通过 ``/external/hello-world`` URL进入路由，我们的组件prop将是"
"未定义的，因此将获得其默认值。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:169
msgid "Passing Parameters - Default Prop Value"
msgstr "传递参数 - 默认Prop 值"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:171
msgid ""
"But, if we access the route via the ``/external/hello-world/Value``, the "
"prop will be set to string ``Value``, and even automatically translated in "
"the current user language (where applicable)."
msgstr ""
"但是，如果我们通过 ``/external/hello-world/Value`` 访问路由，prop将被设置为字"
"符串 ``Value``，甚至自动翻译为当前用户语言（如果已有翻译）。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:176
msgid "Passing Parameters - Translated Prop Value"
msgstr "传递参数 - 已翻译的Prop 值"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:180
msgid "Component Folders"
msgstr "组件目录"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:182
msgid ""
"In case of self-enclosed components, you might want to ship some additional "
"files with it. Sometimes it's better to modularize the code base since it's "
"easier to maintain. In case of front end components you have a really simple "
"way of doing this: component folders. Instead of a single ``.vue`` file for "
"a component, enclose the file named ``index.vue`` in a folder named as your "
"component. Something like this:"
msgstr ""
"如果是自封闭组件，您可能需要随附一些其他文件。 有时最好模块化代码库，因为它更"
"容易维护。 对于前端组件，您可以使用一种非常简单的方法：组件目录，而不是组件的"
"单个 ``.vue`` 文件，将名为 ``index.vue`` 的文件包含在名为组件的目录中。 像这"
"样的："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:189
msgid ""
"Then, simply add new files in the same folder, following a sane structure:"
msgstr "然后，只需按照理智的结构在同一目录中添加新文件："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:203
msgid ""
"You get the idea. It will then be possible to reference the new files via "
"relative paths, in order to achieve something like this in the parent "
"component (``index.vue``):"
msgstr ""
"你懂的。 然后可以通过相对路径引用新文件，以便在父组件（``index.vue``）中实现"
"类似的功能："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:211
msgid "Or, something like this:"
msgstr "或者，像这样："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:225
msgid "Even external styles can be referenced in the correct block:"
msgstr "甚至可以在正确的块中引用外部样式："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:233
msgid ""
"With this approach you will be left with a packaged component in a single "
"folder that follows the logical tree hierarchy, and makes all resources "
"easily findable when needed."
msgstr ""
"使用这种方法，您将在遵循逻辑树层次结构的单个目录中保留一个打包的组件，并使所"
"有资源在需要时都易于查找。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:237
msgid "Packaging Additional Vendor Modules"
msgstr "打包其它供应商模块"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:239
msgid ""
"In certain cases, you might need to ship additional Node.js modules with "
"your package. Unfortunately, both NPM and OTRS do not support easy addition "
"of modules to the root ``node_modules/`` folder, but there is a mechanism to "
"provide pre-packaged module files."
msgstr ""
"在某些情况下，您可能需要在包中附加其它Node.js模块。 遗憾的是，NPM和OTRS都不支"
"持在根 ``node_modules/`` 目录中轻松添加模块，但是有一种机制可以提供预先打包的"
"模块文件。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:241
msgid ""
"Simply create a ``Frontend/Vendor`` folder in your package, and add your "
"module resources in sub-folders within it."
msgstr ""
"只需在包中创建一个 ``Frontend/Vendor`` 目录，然后在其中的子目录中添加模块资"
"源。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:243
msgid ""
"For example, let us assume we want to ship a useful ``vue-full-calendar`` "
"component and its dependencies as part of our package. This component has "
"following NPM dependencies:"
msgstr ""
"例如，假设我们想要发送一个有用的 ``vue-full-calendar`` 组件及其依赖项作为我们"
"的包的一部分。 该组件具有以下NPM依赖项："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:250
msgid ""
"However, some of its dependencies have even more dependencies and we can "
"inspect them too:"
msgstr "但是，它的一些依赖项可能具有更多依赖项，我们也可以检查它们："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:262
msgid ""
"Quick check will inform us that both ``babel-runtime`` and ``moment`` are "
"actually part of the OTRS framework dependencies:"
msgstr ""
"快速检查会告诉我们 ``babel-runtime`` 和 ``moment`` 实际上都是OTRS框架依赖项的"
"一部分："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:283
msgid ""
"This means that we don't have to ship those modules too, since they will be "
"available out-of-box. While it's cumbersome to check all dependencies, it "
"will be worthwhile because our package will be smaller. We will also prevent "
"issues with overriding framework dependencies, since ``Frontend/Vendor`` "
"wins always."
msgstr ""
"这意味着我们也不必打包这些模块，因为它们可以开箱即用。 虽然检查所有依赖项很麻"
"烦，但这是值得的，因为我们的包会更小。 我们还将防止覆盖框架依赖性的问题，因"
"为 ``Frontend/Vendor`` 总是获胜。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:285
msgid ""
"Let's now install what we need and discard what we don't need. The easiest "
"way to do it is via the following NPM command:"
msgstr ""
"现在安装我们需要的东西并丢弃我们不需要的东西。 最简单的方法是通过以下NPM命"
"令："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:304
msgid ""
"Now we remove those modules which we know are provided by the framework:"
msgstr "现在删除那些我们知道由框架提供的模块："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:317
msgid "Much better. Now we move the modules to their correct place:"
msgstr "好多了。 现在将模块移动到正确的位置："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:325
msgid ""
"Final optimization would be to remove unneeded files from the specific "
"module folders. This might prove to be complicated, but it's worth it since "
"it will further reduce size of the modules and number of files that need to "
"be included in the package."
msgstr ""
"最终的优化是从特定模块文件夹中删除不需要的文件。 这可能会很复杂，但它值得，因"
"为它会进一步减少模块的大小和需要包含在包中的文件数量。"

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:327
msgid ""
"For example, let's remove minimized JS files from the ``fullcalendar`` "
"module because we identified that the Vue component uses full dist files "
"only:"
msgstr ""
"例如，让我们从 ``fullcalendar`` 模块中删除最小化的JS文件，因为我们发现Vue组件"
"仅使用完整的dist文件："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:333
msgid ""
"It's also safe to remove jQuery source and minimized files as well, since "
"the ``fullcalendar`` uses original dist files too:"
msgstr ""
"由于 ``fullcalendar`` 也使用原始dist文件，因此删除jQuery源和最小化文件也是安"
"全的："

#: ../../content/how-to-extend-otrs/writing-new-otrs-frontend-component.rst:341
msgid ""
"We are left with approx. 100+ files which we need to include in our SOPM "
"files, like any other regular package file. Once we do this, these "
"dependencies will be present and resolvable in the target system:"
msgstr ""
"我们留下约100多个需要包含在我们的SOPM文件中的文件，就像任何其他常规包文件一"
"样。 完成此操作后，这些依赖项将在目标系统中存在并可解析："

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:2
msgid "Writing A New OTRS Front End Module"
msgstr "编写新的OTRS前端模块"

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:4
msgid ""
"In this chapter, the writing of a new OTRS module is illustrated on the "
"basis of a simple small program. Necessary prerequisite is an OTRS "
"development environment as specified in the chapter of the same name."
msgstr ""
"在本节中，基于一个简单的小程序来说明新OTRS模块的编写。 必要的先决条件是在开发"
"环境章节中指定的OTRS开发环境。"

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:8
msgid "What we want to write"
msgstr "要编写的内容"

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:10
msgid ""
"We want to write a little OTRS module that displays the text 'Hello World' "
"when called up. First of all we must build the directory ``/Hello World`` "
"for the module in the developer directory. In this directory, all "
"directories existent in OTRS can be created. Each module should at least "
"contain the following directories:"
msgstr ""
"我们想要编写一个小的OTRS模块，在调用时显示文本“Hello World”。 首先，我们必须"
"为开发人员目录中的模块构建 ``/Hello World`` 目录。 在此目录中，可以创建OTRS中"
"存在的所有目录。 每个模块至少应包含以下目录："

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:24
msgid "Default Config File"
msgstr "默认配置文件"

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:26
msgid ""
"The creation of a module registration facilitates the display of the new "
"module in OTRS. Therefore we create a file ``/Kernel/Config/Files/XML/"
"HelloWorld.xml``. In this file, we create a new config element. The impact "
"of the various settings is described in the chapter :doc:`../how-it-works/"
"config-mechanism`."
msgstr ""
"创建模块注册有助于在OTRS中显示新模块。 因此我们创建一个文件 ``/Kernel/Config/"
"Files/XML/HelloWorld.xml``。 在这个文件中，我们创建了一个新的配置元素。 各种"
"设置的影响在 :doc:`../how-it-works/config-mechanism` 章节中描述。"

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:108
msgid "Front End Module"
msgstr "前端模块"

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:110
msgid ""
"After creating the links and executing the system configuration, a new "
"module with the name 'HelloWorld' is displayed. When calling it up, an error "
"message is displayed as OTRS cannot find the matching front end module yet. "
"This is the next thing to be created. To do so, we create the following file:"
msgstr ""
"创建链接并执行系统配置后，将显示名为“HelloWorld”的新模块。 调用它时，会显示一"
"条错误消息，因为OTRS尚未找到匹配的前端模块。 这是接下来要创建的东西。 为此，"
"我们创建以下文件："

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:165
msgid "Core Module"
msgstr "核心模块"

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:167
msgid ""
"Next, we create the file for the core module ``/HelloWorld/Kernel/System/"
"HelloWorld.pm`` with the following content:"
msgstr ""
"接下来，我们使用以下内容为核心模块 ``/HelloWorld/Kernel/System/HelloWorld."
"pm`` 创建文件："

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:263
msgid "Template File"
msgstr "模板文件"

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:265
msgid ""
"The last thing missing before the new module can run is the relevant HTML "
"template. Thus, we create the following file:"
msgstr ""
"新模块可以运行之前缺少的最后一件事是相关的HTML模板。 因此，我们创建以下文件："

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:281
msgid ""
"The module is working now and displays the text *Hello World* when called."
msgstr "该模块现在正在工作，并在调用时显示文本 *Hello World*。"

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:285
msgid "Language File"
msgstr "语言文件"

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:287
msgid ""
"If the text *Hello World!* is to be translated into for instance German, you "
"can create a translation file for this language in ``HelloWorld/Kernel/"
"Language/de_AgentHelloWorld.pm``. Example:"
msgstr ""
"如果要将文本 *Hello World！* 翻译成其它语言如德语，您可以在 ``HelloWorld/"
"Kernel/Language/de_AgentHelloWorld.pm`` 中为该语言创建翻译文件。 例如："

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:307
msgid "Summary"
msgstr "摘要"

#: ../../content/how-to-extend-otrs/writing-otrs-application.rst:309
msgid ""
"The example given above shows that it is not too difficult to write a new "
"module for OTRS. It is important, though, to make sure that the module and "
"file name are unique and thus do not interfere with the framework or other "
"expansion modules. When a module is finished, an OPM package must be "
"generated from it (see chapter :doc:`../how-to-publish-otrs-extensions/"
"package-building`)."
msgstr ""
"上面给出的示例表明，为OTRS编写新模块并不困难。 但是，重要的是确保模块和文件名"
"是唯一的，从而不会干扰框架或其他扩展模块。 模块完成后，必须从中生成一个OPM包"
"（参见 :doc:`../how-to-publish-otrs-extensions/package-building`）。"

#: ../../content/how-to-publish-otrs-extensions.rst:2
msgid "How to Publish Your OTRS Extensions"
msgstr "如何发布你的OTRS扩展"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:2
msgid "Package Building"
msgstr "创建软件包"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:4
msgid ""
"If you want to create an OPM package (``.opm``) you need to create a spec "
"file (``.sopm``) which includes the properties of the package."
msgstr ""
"如果你想创建一个OPM包（``.opm``），你需要创建一个规范文件（``.sopm``），包含"
"包的属性。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:8
msgid "Package Spec File"
msgstr "包规范文件"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:10
msgid ""
"The OPM package is XML based. You can create/edit the ``.sopm`` via a text "
"or XML editor. It contains meta data, a file list and database options."
msgstr ""
"OPM包是基于XML的。 您可以通过文本或XML编辑器创建/编辑该 ``.sopm`` 文件。 它包"
"含元数据、文件列表和数据库选项。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:17
msgid "``<Name>`` \\*"
msgstr "``<Name>`` \\*"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:13
msgid "The package name."
msgstr "包名称。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:24
msgid "``<Version>`` \\*"
msgstr "``<Version>`` \\*"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:20
msgid "The package version."
msgstr "包版本。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:39
msgid "``<Framework>`` \\*"
msgstr "``<Framework>`` \\*"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:27
msgid "The targeted framework version (7.0.x means e.g. 7.0.1 or 7.0.2)."
msgstr "目标框架版本（7.0.x 表示 7.0.1 或 7.0.2之类）。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:33
msgid "Can also be used several times."
msgstr "也可以多次使用。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:46
msgid "``<Vendor>`` \\*"
msgstr "``<Vendor>`` \\*"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:42
msgid "The package vendor."
msgstr "包的提供商。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:53
msgid "``<URL>`` \\*"
msgstr "``<URL>`` \\*"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:49
msgid "The vendor URL."
msgstr "提供商的URL。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:60
msgid "``<License>`` \\*"
msgstr "``<License>`` \\*"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:56
msgid "The license of the package."
msgstr "包的许可证。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:68
msgid "``<ChangeLog>``"
msgstr "``<ChangeLog>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:63
msgid "The package change log."
msgstr "包更改日志。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:76
msgid "``<Description>`` \\*"
msgstr "``<Description>`` \\*"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:71
msgid "The package description in different languages."
msgstr "不同语言的包描述。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:91
msgid "Package Actions"
msgstr "包的操作"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:79
msgid ""
"The possible actions for the package after installation. If one of these "
"actions is not defined on the package, it will be considered as possible."
msgstr "安装后包的可能操作。 如果未在包中定义其中一个操作，则将被视为可能。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:87
msgid ""
"A special package action is ``PackageAllowDirectUpdate``. Only if it is "
"defined on the package and set to true, a package can be upgraded from a "
"lower major version (earlier than the last one) to the latest version. (e.g. "
"a package for OTRS 5 updated to OTRS 7)."
msgstr ""
"一个特殊的包操作是 ``PackageAllowDirectUpdate``。 只有在该包上定义并设置为"
"true时，才能将该包从较低的主要版本（早于最后一个版本）升级到最新版本。 （例"
"如，将OTRS 5的包更新到OTRS 7）。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:98
msgid "``<BuildHost>``"
msgstr "``<BuildHost>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:94
#: ../../content/how-to-publish-otrs-extensions/package-building.rst:101
msgid "This will be filled in automatically by OPM."
msgstr "这将由OPM自动填写。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:105
msgid "``<BuildDate>``"
msgstr "``<BuildDate>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:113
msgid "``<PackageRequired>``"
msgstr "``<PackageRequired>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:108
msgid ""
"Packages that must be installed beforehand. If ``PackageRequired`` is used, "
"a version of the required package must be specified."
msgstr ""
"必须事先安装的软件包。 如果使用 ``PackageRequired``，则必须指定所需包的版本。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:121
msgid "``<ModuleRequired>``"
msgstr "``<ModuleRequired>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:116
msgid "Perl modules that must be installed beforehand."
msgstr "必须事先安装的Perl模块。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:130
msgid "``<OS>``"
msgstr "``<OS>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:124
msgid "Required OS."
msgstr "所需操作系统。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:142
msgid "``<Filelist>``"
msgstr "``<Filelist>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:133
msgid "This is a list of files included in the package."
msgstr "这是包中包含的文件列表。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:161
msgid "``<DatabaseInstall>``"
msgstr "``<DatabaseInstall>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:145
msgid "Database entries that have to be created when a package is installed."
msgstr "安装软件包时必须创建的数据库条目。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:161
msgid ""
"You also can choose ``<DatabaseInstall Type=\"post\">`` or "
"``<DatabaseInstall Type=\"pre\">`` to define the time of execution "
"separately (``post`` is default). For more info see :ref:`Package Life "
"Cycle`."
msgstr ""
"你还可以选择 ``<DatabaseInstall Type=\"post\">`` 或 ``<DatabaseInstall Type="
"\"pre\">`` 来分别定义执行时间（``post`` 是默认的）。 有关更多信息，请参阅 :"
"ref:`Package Life Cycle`。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:177
msgid "``<DatabaseUpgrade>``"
msgstr "``<DatabaseUpgrade>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:164
msgid ""
"Information on which actions have to be performed in case of an upgrade."
msgstr "有关升级软件包时必须执行哪些操作的信息。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:166
#: ../../content/how-to-publish-otrs-extensions/package-building.rst:286
msgid ""
"Example if already installed package version is below 1.3.4 (e. g. 1.2.6), "
"the defined action will be performed:"
msgstr ""
"例如，如果已安装的软件包版本低于1.3.4（例如1.2.6），则将执行定义的操作："

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:177
msgid ""
"You also can choose ``<DatabaseUpgrade Type=\"post\">`` or "
"``<DatabaseUpgrade Type=\"pre\">`` to define the time of execution "
"separately (``post`` is default). For more info see :ref:`Package Life "
"Cycle`."
msgstr ""
"你还可以选择 ``<DatabaseUpgrade Type=\"post\">`` 或 ``<DatabaseUpgrade Type="
"\"pre\">`` 来分别定义执行时间（``post`` 是默认的）。 有关更多信息，请参阅 :"
"ref:`Package Life Cycle`。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:186
msgid "``<DatabaseReinstall>``"
msgstr "``<DatabaseReinstall>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:180
msgid ""
"Information on which actions have to be performed if the package is "
"reinstalled."
msgstr "有关安装软件包时必须执行哪些操作的信息。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:186
msgid ""
"You also can choose ``<DatabaseReinstall Type=\"post\">`` or "
"``<DatabaseReinstall Type=\"pre\">`` to define the time of execution "
"separately (``post`` is default). For more info see :ref:`Package Life "
"Cycle`."
msgstr ""
"你还可以选择 ``<DatabaseReinstall Type=\"post\">`` 或 ``<DatabaseReinstall "
"Type=\"pre\">`` 来分别定义执行时间（``post`` 是默认的）。 有关更多信息，请参"
"阅 :ref:`Package Life Cycle`。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:197
msgid "``<DatabaseUninstall>``"
msgstr "``<DatabaseUninstall>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:189
msgid "Actions to be performed on package uninstall."
msgstr "卸载软件包时要执行的操作。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:197
msgid ""
"You also can choose ``<DatabaseUninstall Type=\"post\">`` or "
"``<DatabaseUninstall Type=\"pre\">`` to define the time of execution "
"separately (``post`` is default). For more info see :ref:`Package Life "
"Cycle`."
msgstr ""
"你还可以选择 ``<DatabaseUninstall Type=\"post\">`` 或 ``<DatabaseUninstall "
"Type=\"pre\">`` 来分别定义执行时间（``post`` 是默认的）。 有关更多信息，请参"
"阅 :ref:`Package Life Cycle`。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:209
msgid "``<IntroInstall>``"
msgstr "``<IntroInstall>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:200
msgid "To show a pre or post install introduction in installation dialog."
msgstr "在安装对话框中显示安装前或安装后的介绍。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:208
#: ../../content/how-to-publish-otrs-extensions/package-building.rst:220
#: ../../content/how-to-publish-otrs-extensions/package-building.rst:231
#: ../../content/how-to-publish-otrs-extensions/package-building.rst:242
msgid ""
"You can also use the ``Format`` attribute to define if you want to use "
"``html`` (which is default) or ``plain`` to use automatically a ``<pre></"
"pre>`` tag when intro is shown (to keep the newlines and whitespace of the "
"content)."
msgstr ""
"您还可以使用 ``Format`` 属性来定义在显示介绍时是否要使用 ``html`` （默认值）"
"或 ``plain`` 来自动使用 ``<pre> </pre>`` 标签（保留内容的换行符和空格）。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:220
msgid "``<IntroUninstall>``"
msgstr "``<IntroUninstall>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:212
msgid "To show a pre or post uninstall introduction in uninstallation dialog."
msgstr "在卸载对话框中显示卸载前或卸载后的介绍。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:231
msgid "``<IntroReinstall>``"
msgstr "``<IntroReinstall>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:223
msgid "To show a pre or post reinstall introduction in re-installation dialog."
msgstr "在重新安装对话框中显示重新安装前或重新安装后的介绍。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:242
msgid "``<IntroUpgrade>``"
msgstr "``<IntroUpgrade>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:234
msgid "To show a pre or post upgrade introduction in upgrading dialog."
msgstr "在升级对话框中显示升级前或升级后的介绍。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:257
msgid "``<CodeInstall>``"
msgstr "``<CodeInstall>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:245
msgid "Perl code to be executed when the package is installed."
msgstr "安装包后要执行的Perl代码。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:259
msgid ""
"You also can choose ``<CodeInstall Type=\"post\">`` or ``<CodeInstall Type="
"\"pre\">`` to define the time of execution separately (``post`` is default). "
"For more info see :ref:`Package Life Cycle`."
msgstr ""
"你还可以选择 ``<CodeInstall Type=\"post\">`` 或 ``<CodeInstall Type=\"pre"
"\">`` 来分别定义执行时间（``post`` 是默认的）。 有关更多信息，请参阅 :ref:"
"`Package Life Cycle`。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:270
msgid "``<CodeUninstall>``"
msgstr "``<CodeUninstall>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:262
msgid ""
"Perl code to be executed when the package is uninstalled. On pre or post "
"time of package uninstallation."
msgstr "卸载软件包后要执行的Perl代码。 在卸载软件包之前或之后的时间。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:270
msgid ""
"You also can choose ``<CodeUninstall Type=\"post\">`` or ``<CodeUninstall "
"Type=\"pre\">`` to define the time of execution separately (``post`` is "
"default). For more info see :ref:`Package Life Cycle`."
msgstr ""
"你还可以选择 ``<CodeUninstall Type=\"post\">`` 或 ``<CodeUninstall Type=\"pre"
"\">`` 来分别定义执行时间（``post`` 是默认的）。 有关更多信息，请参阅 :ref:"
"`Package Life Cycle`。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:281
msgid "``<CodeReinstall>``"
msgstr "``<CodeReinstall>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:273
msgid "Perl code to be executed when the package is reinstalled."
msgstr "重新安装软件包后要执行的Perl代码。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:281
msgid ""
"You also can choose ``<CodeReinstall Type=\"post\">`` or ``<CodeReinstall "
"Type=\"pre\">`` to define the time of execution separately (``post`` is "
"default). For more info see :ref:`Package Life Cycle`."
msgstr ""
"你还可以选择 ``<CodeReinstall Type=\"post\">`` 或 ``<CodeReinstall Type=\"pre"
"\">`` 来分别定义执行时间（``post`` 是默认的）。 有关更多信息，请参阅 :ref:"
"`Package Life Cycle`。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:294
msgid "``<CodeUpgrade>``"
msgstr "``<CodeUpgrade>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:284
msgid ""
"Perl code to be executed when the package is upgraded (subject to "
"``version`` tag)."
msgstr "升级软件包后要执行的Perl代码（以 ``version`` 标签为准）。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:294
msgid ""
"You also can choose ``<CodeUpgrade Type=\"post\">`` or ``<CodeUpgrade Type="
"\"pre\">`` to define the time of execution separately (``post`` is default). "
"For more info see :ref:`Package Life Cycle`."
msgstr ""
"你还可以选择 ``<CodeUpgrade Type=\"post\">`` 或 ``<CodeUpgrade Type=\"pre"
"\">`` 来分别定义执行时间（``post`` 是默认的）。 有关更多信息，请参阅 :ref:"
"`Package Life Cycle`。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:320
msgid "``<PackageMerge>``"
msgstr "``<PackageMerge>``"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:297
msgid ""
"This tag signals that a package has been merged into another package. In "
"this case the original package needs to be removed from the file system and "
"the packages database, but all data must be kept."
msgstr ""
"此标记表示包已合并到另一个包中。 在这种情况下，需要从文件系统和包数据库中删除"
"原始包，但必须保留所有数据。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:299
msgid ""
"Let's assume that ``PackageOne`` was merged into ``PackageTwo``. Then "
"``PackageTwo.sopm`` should contain this:"
msgstr ""
"我们假设 ``PackageOne`` 被合并到 ``PackageTwo`` 中。 那么 ``PackageTwo."
"sopm`` 应该包含这个："

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:305
msgid ""
"If ``PackageOne`` also contained database structures, we need to be sure "
"that it was at the latest available version of the package to have a "
"consistent state in the database after merging the package. The attribute "
"``TargetVersion`` does just this: it signifies the last known version of "
"``PackageOne`` at the time ``PackageTwo`` was created. This is mainly to "
"stop the upgrade process if in the user's system a version of ``PackageOne`` "
"was found that is *newer* than the one specified in ``TargetVersion`` as "
"this could lead to problems."
msgstr ""
"如果 ``PackageOne`` 也包含数据库结构，我们需要确保它是在包的最新可用版本，以"
"便在合并包后在数据库中具有一致状态。 ``TargetVersion`` 属性的作用：它表示在创"
"建 ``PackageTwo`` 时 ``PackageOne`` 的最后一个已知版本。 这主要是为了在用户的"
"系统中发现了一个 ``PackageOne`` 版本比 ``TargetVersion`` 中指定的版本 *更新* "
"时停止升级过程，因为这可能会导致问题。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:307
msgid ""
"Additionally it is possible to add required database and code upgrade tags "
"for ``PackageOne`` to make sure that it gets properly upgraded to the "
"``TargetVersion`` *before* merging it - to avoid inconsistency problems. "
"Here's how this could look like:"
msgstr ""
"另外，可以为 ``PackageOne`` 添加所需的数据库和代码升级标签，以确保在 *合并之"
"前* 将其正确升级到 ``TargetVersion`` - 以避免不一致问题。 这看起来是这样的："

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:320
msgid ""
"As you can see the attribute ``Type=\"merge\"`` needs to be set in this "
"case. These sections will only be executed if a package merge is possible."
msgstr ""
"正如您所看到的，在这种情况下需要设置属性 ``Type=\"merge\"`` 。 只有在可以进行"
"包合并时才会执行这些部分。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:342
msgid "Package Conditions"
msgstr "软件包条件"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:325
msgid ""
"``IfPackage`` and ``IfNotPackage`` attributes can be added to the regular "
"``Database*`` and ``Code*`` sections. If they are present, the section will "
"only be executed if another package is or is not in the local package "
"repository."
msgstr ""
"``IfPackage`` 和 ``IfNotPackage`` 属性可以添加到常规 ``Database*`` 和 "
"``Code*`` 部分。 如果它们存在，则只有在本地软件包存储库中存在或不存在另一个软"
"件包时才会执行该部分。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:333
msgid "or"
msgstr "or（或）"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:341
msgid ""
"These attributes can be also set in the ``Database*`` and ``Code*`` sections "
"inside the ``PackageMerge`` tags."
msgstr ""
"这些属性也可以在 ``PackageMerge`` 标签内的 ``Database*`` 和 ``Code*`` 部分设"
"置。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:345
msgid "Example .sopm"
msgstr ".sopm示例"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:347
msgid "This is an example spec file looks with some of the above tags."
msgstr "这是一个示例规范文件，包含一些上述标签。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:394
msgid "Package Build"
msgstr "构建软件包"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:396
msgid "To build an .opm package from the spec opm."
msgstr "若要从opm规范文件构建.opm包。"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:407
#: ../../content/how-to-publish-otrs-extensions/package-building.rst:414
msgid "Package Life Cycle"
msgstr "软件包生命周期"

#: ../../content/how-to-publish-otrs-extensions/package-building.rst:409
msgid ""
"The following image shows you how the life cycle of a package installation, "
"upgrade and uninstallation works in the back end step by step."
msgstr "下图显示了软件包安装、升级和卸载的生命周期如何在后端逐步进行。"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:2
msgid "Package Management"
msgstr "软件包管理"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:4
msgid ""
"The OPM (OTRS Package Manager) is a mechanism to distribute software "
"packages for the OTRS framework via HTTP, FTP or file upload."
msgstr ""
"OPM（OTRS包管理器）是一种通过HTTP、FTP或文件上载为OTRS框架分发软件包的机制。"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:6
msgid ""
"For example, the OTRS project offers OTRS modules like a calendar, a file "
"manager or web mail in OTRS packages via online repositories on our FTP "
"servers. The packages can be managed (install, upgrade and uninstall) via "
"the admin interface."
msgstr ""
"例如，OTRS项目通过我们的FTP服务器上的在线软件仓库提供OTRS模块，如OTRS软件包中"
"的日历、文件管理器或Web邮件。 可以通过管理员界面管理（安装、升级和卸载）软件"
"包。"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:10
msgid "Package Distribution"
msgstr "软件包分发"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:12
msgid ""
"If you want to create an OPM online repository, just tell the OTRS framework "
"where the location is by activating the system configuration setting "
"``Package::RepositoryList`` and adding the new location there. Then you will "
"have a new select option in the package manager."
msgstr ""
"如果您想创建一个OPM在线软件仓库，只需通过激活系统配置设置 ``Package::"
"RepositoryList`` 并在那里添加新位置，告诉OTRS框架该位置。 然后，您将在软件包"
"管理器中有一个新的选择选项。"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:14
msgid ""
"In your repository, create an index file for your OPM packages. OTRS just "
"reads this index file and knows what packages are available."
msgstr ""
"在您的存储库中，为您的OPM软件包创建索引文件。 OTRS只读取此索引文件来获取可用"
"的软件包。"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:22
msgid "Package Commands"
msgstr "软件包命令"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:24
msgid ""
"You can use the following OPM commands over the admin interface or over "
"``bin/otrs.Console.pl`` to manage admin jobs for OPM packages."
msgstr ""
"您可以通过管理员界面或 ``bin/otrs.Console.pl`` 来使用以下OPM命令来管理OPM软件"
"包的管理任务。"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:28
msgid "Install"
msgstr "安装"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:30
msgid "Install OPM packages."
msgstr "安装OPM软件包。"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:32
#: ../../content/how-to-publish-otrs-extensions/package-management.rst:42
#: ../../content/how-to-publish-otrs-extensions/package-management.rst:52
#: ../../content/how-to-publish-otrs-extensions/package-management.rst:62
msgid "Web: http://localhost/otrs/index.pl?Action=AdminPackageManager"
msgstr "Web: http://localhost/otrs/index.pl?Action=AdminPackageManager"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:34
msgid ""
"CMD: ``bin/otrs.Console.pl Admin::Package::Install /path/to/package.opm``"
msgstr ""
"CMD: ``bin/otrs.Console.pl Admin::Package::Install /path/to/package.opm``"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:38
msgid "Uninstall"
msgstr "卸载"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:40
msgid "Uninstall OPM packages."
msgstr "卸载OPM软件包。"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:44
msgid ""
"CMD: ``bin/otrs.Console.pl Admin::Package::Uninstall /path/to/package.opm``"
msgstr ""
"CMD: ``bin/otrs.Console.pl Admin::Package::Uninstall /path/to/package.opm``"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:48
msgid "Upgrade"
msgstr "升级"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:50
msgid "Upgrade OPM packages."
msgstr "升级OPM软件包。"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:54
msgid ""
"CMD: ``bin/otrs.Console.pl Admin::Package::Upgrade /path/to/package.opm``"
msgstr ""
"CMD: ``bin/otrs.Console.pl Admin::Package::Upgrade /path/to/package.opm``"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:58
msgid "List"
msgstr "列表"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:60
msgid "List all OPM packages."
msgstr "列出所有的OPM软件包。"

#: ../../content/how-to-publish-otrs-extensions/package-management.rst:64
msgid "CMD: ``bin/otrs.Console.pl Admin::Package::List``"
msgstr "CMD: ``bin/otrs.Console.pl Admin::Package::List``"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:2
msgid "Package Porting"
msgstr "软件包移植"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:4
msgid ""
"With every new minor or major version of OTRS, you need to port your "
"packages and make sure they still work with the OTRS API."
msgstr ""
"对于每个新的次要或主要版本的OTRS，您需要移植软件包并确保它们仍然可以使用OTRS "
"API。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:6
msgid ""
"This section lists changes that you need to examine when porting your "
"package from OTRS 6 to 7."
msgstr "本节列出了将软件包从OTRS 6移植到7时需要检查的更改。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:10
msgid "Sessions Always Require Cookies"
msgstr "会话始终需要Cookie"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:12
msgid ""
"Starting from OTRS 7, `sessions always require cookies to be enabled "
"<https://github.com/OTRS/otrs/"
"commit/831aba1cfe6893d0633af6f18584216e89198072>`__. Therefore, the "
"``SessionIDCookie`` value was removed from ``LayoutObject``, :doc:`../how-it-"
"works/templates` and JavaScript. It is no longer necessary to append session "
"variables to URLs or HTTP request payloads."
msgstr ""
"从OTRS 7开始，`会话总是要求启用cookie <https://github.com/OTRS/otrs/"
"commit/831aba1cfe6893d0633af6f18584216e89198072>`__。 因此，"
"``SessionIDCookie`` 值已从 ``LayoutObject`` 、:doc:`../how-it-works/"
"templates` 和JavaScript中删除。 不再需要将会话变量附加到URL或HTTP请求负载。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:16
msgid "The ``groups`` Table Was Renamed"
msgstr "``groups`` 表被重命名"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:18
msgid ""
"Due to a change in MySQL 8, the table ``groups`` had to be renamed to "
"``groups_table``. If you use this table directly in any SQL statements, they "
"will need to be adapted. For more information, see `bug#13866 <https://bugs."
"otrs.org/show_bug.cgi?id=13866>`__."
msgstr ""
"由于MySQL 8的变化， ``groups`` 表必须重命名为 ``groups_table``。 如果直接在任"
"何SQL语句中使用此表，则需要对其进行调整。 有关更多信息，请参阅 `bug#13866 "
"<https://bugs.otrs.org/show_bug.cgi?id=13866>`__。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:22
msgid "New External Interface"
msgstr "新的外部人员界面"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:24
msgid ""
"The existing customer (``customer.pl``) and public (``public.pl``) "
"interfaces were replaced by a new REST backend (``Kernel/WebApp``) and a "
"modern Vue.js based front end application. This means that all related code "
"has to be ported and/or rewritten."
msgstr ""
"现有的客户（``customer.pl``）和公共（``public.pl``）界面被新的REST后端"
"（``Kernel/WebApp``）和现代的基于Vue.js的前端应用程序所取代。 这意味着必须移"
"植和/或重写所有相关代码。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:26
msgid ""
"There is one special case for public front end modules that don't serve an "
"HTML application. These can be ported rather easily to the new REST back end "
"(see also `the REST API docs <https://doc.otrs.com/doc/api/otrs/7.0/REST/"
">`__). See for example ``Kernel/WebApp/Controller/API/Public/Package/"
"Repository.pm``. This example also shows how endpoints can support both new "
"REST-like URLs and the legacy URLs based on the ``/otrs/customer.pl?"
"Action=MyAction`` routes at the same time."
msgstr ""
"对于不提供HTML应用程序的公共前端模块，有一种特殊情况。 这些可以很容易地移植到"
"新的REST后端（另请参阅 `REST API文档 <https://doc.otrs.com/doc/api/otrs/7.0/"
"REST/>`__）。 例如，参见 ``Kernel/WebApp/Controller/API/Public/Package/"
"Repository.pm``。 此示例还显示了端点如何同时支持新的REST类URL和基于 ``/otrs/"
"customer.pl?Action=MyAction`` 路由的旧URL。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:28
msgid ""
"For some important URLs in the customer interface that are linked from "
"legacy systems, redirect controllers may need to be provided to make sure "
"the old URLs keep working."
msgstr ""
"对于从旧系统链接的客户界面中的一些重要URL，可能需要提供重定向控制器以确保旧"
"URL继续工作。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:32
msgid "Changes in Process Management"
msgstr "流程管理中的更改"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:34
msgid ""
"The migration script ``scripts/DBUpdate-to-7.pl`` will upgrade all processes "
"that are already in the database. Manual action is only needed to make use "
"of any new features that OTRS 7 provides."
msgstr ""
"迁移脚本 ``scripts/DBUpdate-to-7.pl`` 将升级数据库中已有的所有流程。 只有使用"
"OTRS 7提供的任何新功能才需要手动操作。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:38
msgid "New Activity Types"
msgstr "新的活动类型"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:40
msgid ""
"Since OTRS 7 is capable of managing more activity types, all existing "
"activities now become *User Task* activities. To update a task definition on "
"a YAML file, please add ``Type: UserTask`` with the same indentation as "
"``Name`` or ``ID``."
msgstr ""
"由于OTRS 7能够管理更多活动类型，因此所有现有活动现在都成为*用户任务*活动。 要"
"更新YAML文件上的任务定义，请添加 ``Type: UserTask``，其缩写与 ``Name`` 或 "
"``ID`` 相同。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:44
msgid "Renamed Process Management Components"
msgstr "重命名流程管理组件"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:47
msgid "``Transition`` to ``SequenceFlow``"
msgstr "``Transition（转换）`` 变为 ``SequenceFlow（序列流）``"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:47
msgid ""
"This process component was renamed to be more aligned with BPMN. Files, "
"classes and methods has been renamed accordingly. Customized files needs to "
"be updated following the new conventions."
msgstr ""
"此流程组件已重命名为与BPMN更加一致。 相应地重命名了文件、类和方法。 需要根据"
"新约定更新自定义文件。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:50
msgid "``TransitionAction`` to ``SequenceFlowAction``"
msgstr ""
"``TransitionAction（转换操作）`` 变为 ``SequenceFlowAction（序列流操作）``"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:50
msgid ""
"This process component does not exists in BPMN but has to be also renamed to "
"be consistent with the other changes. Files, classes and methods has been "
"renamed accordingly. Customized files needs to be updated following the new "
"conventions."
msgstr ""
"此流程组件在BPMN中不存在，但也必须重命名为与其他更改一致。 相应地重命名了文"
"件、类和方法。 需要根据新约定更新自定义文件。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:53
msgid "``TransitionActionModules`` to ``ProcessManagementModules``"
msgstr ""
"``TransitionActionModules（转换操作模块）`` 变为 "
"``ProcessManagementModules（流程管理模块）``"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:53
msgid ""
"These process components are not only used by *Sequence Flow Actions* but "
"also for *Script Tasks* activities and has been moved from ``Kernel/System/"
"ProcessManagement/TransitionAction`` to ``Kernel/System/ProcessManagement/"
"Modules``."
msgstr ""
"这些流程组件不仅用于 *序列流操作*，还用于 *脚本任务* 活动，并且已经从 "
"``Kernel/System/ProcessManagement/TransitionAction`` 转移到 ``Kernel/System/"
"ProcessManagement/Modules``。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:55
msgid ""
"The new process management modules can offer more field types and options to "
"present the parameters to the process designer. Please follow the "
"instructions in the :doc:`../how-to-extend-otrs/otrs-module-layers/process-"
"management-modules` documentation to learn more about this new feature and "
"how to improve existing modules."
msgstr ""
"新的流程管理模块可以提供更多的字段类型和选项，以向流程设计者提供参数。 请按"
"照 :doc:`../how-to-extend-otrs/otrs-module-layers/process-management-"
"modules` 文档中的说明进行操作，以了解有关此新功能以及如何改进现有模块的更多信"
"息。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:57
msgid ""
"It is needed to update any shipped process definitions to use the new name "
"schema."
msgstr "需要更新任何已发布的流程定义以使用新的名称方案。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:59
msgid "Replace ``Transition`` with ``SequenceFlow``."
msgstr "用 ``SequenceFlow`` 替换 ``Transition``。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:60
msgid "Replace ``Transitions`` with ``SequenceFlows``."
msgstr "用 ``SequenceFlows`` 替换 ``Transitions``。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:61
msgid "Replace ``TransitionAction`` with ``SequenceFlowAction``."
msgstr "用 ``SequenceFlowAction`` 替换 ``TransitionAction`` 。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:62
msgid "Replace ``TransitionActions`` with ``SequenceFlowActions``."
msgstr "用 ``SequenceFlowActions`` 替换 ``TransitionActions`` 。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:63
msgid ""
"Remove ``Kernel::System::ProcessManagement::TransitionAction`` from the "
"``Module:`` on all ``SequenceFlowAction``. For example: ``Module: Kernel::"
"System::ProcessManagement::TransitionAction::TicketLockSet`` should become "
"``Module: TicketLockSet``."
msgstr ""
"从所有 ``SequenceFlowAction`` 上的 ``Module:`` 中删除 ``Kernel::System::"
"ProcessManagement::TransitionAction`` 。 例如： ``Module: Kernel::System::"
"ProcessManagement::TransitionAction::TicketLockSet`` 应该变成 ``Module: "
"TicketLockSet`` 。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:67
msgid "Changes in the ``LayoutObject``"
msgstr "``LayoutObject`` 中的变化"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:69
msgid ""
"There are changes in ``Kernel/Output/HTML/Layout.pm`` which are necessary to "
"properly render content using Mojolicious real-time web framework."
msgstr ""
"``Kernel/Output/HTML/Layout.pm`` 中有一些变化，这些变化是使用Mojolicious实时"
"Web框架正确渲染内容所必需的。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:73
msgid "Not Shown/Empty Tables in Screens"
msgstr "屏幕中未显示表格或空白的表格"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:75
msgid ""
"Please make sure to check every screen which produces table-like output (e. "
"g. ``Kernel/Modules/AgentTicketStatusView.pm``). If the list of e. g. "
"tickets is empty or even not shown at all, check if the parameter ``Output "
"=> 1`` is used in creating the output for the page."
msgstr ""
"请确保检查每个产生表格式输出的屏幕（例如 ``Kernel/Modules/"
"AgentTicketStatusView.pm``）。 如果列表（如工单列表）是空的甚至根本没有显示，"
"检查在创建页面的输出时是否使用了参数 ``Output => 1`` 。"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:79
msgid "Encoding Issues in Legacy Front End Modules"
msgstr "传统前端模块中的编码问题"

#: ../../content/how-to-publish-otrs-extensions/package-porting.rst:81
msgid ""
"If you are getting into trouble with broken characters like umlauts, it "
"could be that the content which is meant to be shown is rendered by the "
"``Print()`` method. To fix this, please switch the code from using the "
"``Print()`` method to the normal way of returning the complete response from "
"the front end module."
msgstr ""
"如果你遇到像（日耳曼语系中的）元音变音这样的破碎字符的问题，可能是因为要显示"
"的内容是由 ``Print()`` 方法渲染的。 要解决此问题，请将代码从使用 ``Print()`` "
"方法切换到从前端模块返回完整响应的常规方法。"

#: ../../content/index.rst:3
msgid "OTRS Developer Manual"
msgstr "OTRS开发者手册"

#: ../../content/index.rst:5
msgid ""
"This work is copyrighted by OTRS AG (https://otrs.com), Zimmersmühlenweg 11, "
"61440 Oberursel, Germany."
msgstr ""
"此作品的版权归 OTRS AG 所有 (https://otrs.com) ，德国（法兰克福） 上乌瑟尔"
"Zimmersmühlenweg 路11号，61440。"

#: ../../content/index.rst:7
msgid ""
"Permission is granted to copy, distribute and/or modify this document under "
"the terms of the GNU Free Documentation License, Version 1.3 or any later "
"version published by the Free Software Foundation; with no Invariant "
"Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the "
"license can be found on the `GNU website <https://www.gnu.org/licenses/"
"fdl-1.3.txt>`__."
msgstr ""
"根据GNU自由文档许可证1.3版或自由软件基金会发布的任何更新版本的条款，允许复"
"制、分发和/或修改本文档; 没有不变的部分，没有封面文本，也没有封底文本。 许可"
"证的副本可以在 `GNU网站 <https://www.gnu.org/licenses/fdl-1.3.txt>`__ 找到。"

#~ msgid ""
#~ "The OTRS developer API documentation is available for `Perl <https://otrs."
#~ "github.io/doc/api/otrs/stable/Perl/index.html>`__ and `JavaScript "
#~ "<https://otrs.github.io/doc/api/otrs/stable/JavaScript/index.html>`__."
#~ msgstr ""
#~ "OTRS开发人员API文档包括 `Perl <https://otrs.github.io/doc/api/otrs/stable/"
#~ "Perl/index.html>`__ 和 `JavaScript <https://otrs.github.io/doc/api/otrs/"
#~ "stable/JavaScript/index.html>`__。"

#~ msgid "From"
#~ msgstr "From（发件人）"

#~ msgid "To"
#~ msgstr "To（收件人）"

#~ msgid ""
#~ "Join your `language team <https://www.transifex.com/otrs/teams/>`__ and "
#~ "wait for the acceptance."
#~ msgstr ""
#~ "加入你的 `语言团队 <https://www.transifex.com/otrs/teams/>`__ 并等待接受。"
